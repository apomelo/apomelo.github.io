<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"apomelo.cc","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"A3LWYBODE0","apiKey":"c40595ca0a82310430032a8bc32214a2","indexName":"apomelo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="我有一壶酒，足以慰风尘。尽倾江海里，赠饮天下人。">
<meta property="og:type" content="website">
<meta property="og:title" content="Apomelo - 追逐">
<meta property="og:url" content="https://apomelo.cc/page/2/index.html">
<meta property="og:site_name" content="Apomelo - 追逐">
<meta property="og:description" content="我有一壶酒，足以慰风尘。尽倾江海里，赠饮天下人。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Apomelo">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://apomelo.cc/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Apomelo - 追逐</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2KQDESYMZF"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2KQDESYMZF","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?6c01cfc90b27c8f2cf8c97e38b2f117c"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Apomelo - 追逐</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Apomelo</p>
  <div class="site-description" itemprop="description">我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/apomelo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;apomelo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:apomeloc@gmail.com" title="E-Mail → mailto:apomeloc@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2020/10/22/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2020/10/22/git/" class="post-title-link" itemprop="url">Git 笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-10-22T00:00:00+08:00">2020-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code-management/" itemprop="url" rel="index"><span itemprop="name">code-management</span></a>
        </span>
    </span>

  
    <span id="/posts/2020/10/22/git/" class="post-meta-item leancloud_visitors" data-flag-title="Git 笔记" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="配置-git"><a href="#配置-git" class="headerlink" title="配置 git"></a>配置 git</h1><h2 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h2><p>Git相关的配置文件有三个：</p>
<ol>
<li>系统级<br> 用户目录中的 .gitconfig 文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.gitconfig</span><br></pre></td></tr></table></figure></li>
<li>系统用户级<br> 用户目录中的 .gitconfig 文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.gitconfig</span><br></pre></td></tr></table></figure></li>
<li>仓库级<br> git项目目录中的 .git&#x2F;config 文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/项目目录/.git/config</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对于同一配置项，三个配置文件的优先级是 系统级 &lt; 系统用户级 &lt; 仓库级</p>
<h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p>设置的是系统用户配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your_name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="单个仓库设置"><a href="#单个仓库设置" class="headerlink" title="单个仓库设置"></a>单个仓库设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">&quot;your_name&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看-git-配置"><a href="#查看-git-配置" class="headerlink" title="查看 git 配置"></a>查看 git 配置</h2><p>查看当前配置, 在当前项目下面查看的配置是全局配置+当前项目的配置, 使用的时候会优先使用当前项目的配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h2 id="添加-git-ssh-key"><a href="#添加-git-ssh-key" class="headerlink" title="添加 git ssh-key"></a>添加 git ssh-key</h2><h3 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh-key"></a>生成 ssh-key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐 ed25519 算法</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"><span class="comment"># 不支持 ed25519 算法的话用 rsa 算法</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"><span class="comment"># 提示以下内容时: (按回车是默认)</span></span><br><span class="line">&gt;&gt; Enter a file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/YOU/.ssh/id_ALGORITHM):[Press enter]</span><br><span class="line">&gt;&gt; Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">&gt;&gt; Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<h3 id="远端仓库添加-ssh-key"><a href="#远端仓库添加-ssh-key" class="headerlink" title="远端仓库添加 ssh-key"></a>远端仓库添加 ssh-key</h3><p>把 id_ALGORITHM.pub 里面的内容复制添加到远端仓库，如: github个人账号中</p>
<h3 id="配置多个-ssh-key"><a href="#配置多个-ssh-key" class="headerlink" title="配置多个 ssh-key"></a>配置多个 ssh-key</h3><ol>
<li>&#x2F;c&#x2F;Users&#x2F;YOU&#x2F;.ssh&#x2F; 文件夹中新建文件 config</li>
<li>配置 config 文件</li>
</ol>
<p><strong>config 文件配置</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github_id_ed25519</span><br><span class="line"></span><br><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host gitlab.com</span><br><span class="line">    HostName gitlab.*.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/gitlab_id_ed25519</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件参数</span></span><br><span class="line"><span class="comment"># Host 标识了一个配置区段</span></span><br><span class="line"><span class="comment"># HostName 指定远程主机名，可以直接使用数字IP地址</span></span><br><span class="line"><span class="comment"># Port 指定远程主机端口号，默认为 22</span></span><br><span class="line"><span class="comment"># User 登录名</span></span><br><span class="line"><span class="comment"># IdentityFile 指定密钥认证使用的私钥文件路径，默认为 ~/.ssh/id_ALGORITHM (必须全路径)</span></span><br><span class="line"><span class="comment"># UserKnownHostsFile 指定一个或多个用户认证主机缓存文件，用来缓存通过认证的远程主机的密钥，多个文件用空格分隔。默认缓存文件为： ~/.ssh/known_hosts, ~/.ssh/known_hosts2</span></span><br></pre></td></tr></table></figure>

<h3 id="验证是否添加成功"><a href="#验证是否添加成功" class="headerlink" title="验证是否添加成功"></a>验证是否添加成功</h3><p>用 github 示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用以下命令即可</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 失败时加上 -v 可以查看详细log</span></span><br><span class="line">ssh -T -v git@github.com</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7030074642559664135#heading-22">Hexo -14- 利用 Markdown 语法画 mermaid 流程图</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2020/06/25/java-%E5%8E%9F%E7%94%9F%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2020/06/25/java-%E5%8E%9F%E7%94%9F%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">java原生队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-25T00:00:00+08:00">2020-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span id="/posts/2020/06/25/java-%E5%8E%9F%E7%94%9F%E9%98%9F%E5%88%97/" class="post-meta-item leancloud_visitors" data-flag-title="java原生队列" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="队列简介"><a href="#队列简介" class="headerlink" title="队列简介"></a>队列简介</h2><p>先进先出（FIFO），生产者往队列里发布事件，消费者获得通知消费事件；如果队列中没有事件时，消费者堵塞，直到生产者发布了新事件。</p>
<p>Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接口。</p>
<h2 id="Java-内置队列"><a href="#Java-内置队列" class="headerlink" title="Java 内置队列"></a>Java 内置队列</h2><table>
<thead>
<tr>
<th>队列</th>
<th>有界性</th>
<th>锁</th>
<th>阻塞</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>是</td>
<td>arraylist</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>是</td>
<td>linkedlist</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td>unbounded</td>
<td>CAS</td>
<td>否</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>CAS</td>
<td>是</td>
<td>linkedlist</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>是</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>是</td>
<td>heap</td>
</tr>
<tr>
<td>SynchronizedQueue</td>
<td>synchronized</td>
<td>CAS</td>
<td>是</td>
<td>linkedlist</td>
</tr>
</tbody></table>
<h2 id="队列加锁性能"><a href="#队列加锁性能" class="headerlink" title="队列加锁性能"></a>队列加锁性能</h2><p>现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。</p>
<p>Disruptor论文中讲述了一个实验：</p>
<ul>
<li>这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。</li>
<li>机器环境：2.4G 6核</li>
<li>运算： 64位的计数器累加5亿次</li>
</ul>
<table>
<thead>
<tr>
<th>Method</th>
<th>Time (ms)</th>
</tr>
</thead>
<tbody><tr>
<td>Single thread</td>
<td>300</td>
</tr>
<tr>
<td>Single thread with CAS</td>
<td>5,700</td>
</tr>
<tr>
<td>Single thread with lock</td>
<td>10,000</td>
</tr>
<tr>
<td>Single thread with volatile write</td>
<td>4,700</td>
</tr>
<tr>
<td>Two threads with CAS</td>
<td>30,000</td>
</tr>
<tr>
<td>Two threads with lock</td>
<td>224,000</td>
</tr>
</tbody></table>
<p>CAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下，速度比单线程无锁慢3个数量级。可见无锁速度最快。</p>
<p><strong>单线程</strong>情况下，不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能。</p>
<p><strong>多线程</strong>情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。</p>
<p>综上可知，加锁的性能是最差的。</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。</p>
<p>ArrayBlockingQueue 必须指定长度，且一旦创建，容量不能改变。</p>
<p>ArrayBlockingQueue 采用ReentrantLock来控制并发，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞；尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p>ArrayBlockingQueue 默认是非公平队列。</p>
<p>ArrayBlockingQueue 用Object[]存储对象。</p>
<ol>
<li>线程安全是指：ArrayBlockingQueue内部通过“互斥锁”保护竞争资源，实现了多线程对竞争资源的互斥访问。</li>
<li>有界是指：ArrayBlockingQueue对应的数组是有界限的。</li>
<li>阻塞：是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待。</li>
<li>所谓公平的访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，先阻塞的线程先访问ArrayBlockingQueue队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才能够访问队列。然而为了保证公平性，通常会降低吞吐量。</li>
</ol>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一个基于链表实现的阻塞队列，默认情况下，该阻塞队列的大小为Integer.MAX_VALUE，由于这个数值特别大，因此在很多地方称LinkedBlockingQueue是一个无界队列。在LinkedBlockingQueue进行初始化时，可以手动指定队列的大小，这样LinkedBlockingQueue就是一个有界队列了。所以说LinkedBlockingQueue是一个可选择的有界队列。</p>
<p>LinkedBlockingQueue 采用ReentrantLock来控制并发。但是和ArrayBlockingQueue不同的是，LinkedBlockingQueue对队头和队尾各自使用了一把锁来做并发控制。LinkedBlockingQueue采用的是wait-notify机制实现的，不过没有用Object提供的，用java.util.concurrent.locks.Condition中的await()和signal()配合锁实现。</p>
<p>在put()方法中, 关键点在于搞清楚下面俩点:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) notFull.signal();</span><br><span class="line"><span class="number">2.</span> <span class="keyword">if</span> (c == <span class="number">0</span>) signalNotEmpty();</span><br></pre></td></tr></table></figure>
<ol>
<li>语句1 是判断在多线程的环境下起到作用, 假设现在有4个线程都在await()处阻塞, take()取出一个数据, 现在唤醒了一个线程, 那么当该线程继续put的时候, 通过该判断, 如果队列非满则将阻塞在await()出的线程继续唤醒, 直到队列满了或者全部唤醒。</li>
<li>语句2 是由于前边是调用的count.getAndIncrement(), 如果c为0, 那么现在队列里就有了一个元素, 唤醒阻塞在出列的await()处的线程, 可以继续出列, 取数据了.</li>
</ol>
<p>LinkedBlockingQueue 用Node存储对象。</p>
<p><strong>总结</strong></p>
<ol>
<li>LinkedBlockingQueue是通过锁分离的方式进行控制，减少了take和put之间的锁竞争。</li>
<li>LinkedBlockingQueue是通过链表的方式实现，所以进行锁分离时不会冲突，因为入队和出队分别作用于队尾和队首。</li>
<li>内部采用了原子操作类（CAS）进行控制链表长度。</li>
<li>入队后，如果之前队列为空时，会通知take方法，队列已有数据可进行take，反之，出队后，队列之前已满，则通知put方法，队列已有空闲位置可进行put操作。</li>
</ol>
<h3 id="tip（wait-notify机制）"><a href="#tip（wait-notify机制）" class="headerlink" title="tip（wait-notify机制）"></a>tip（wait-notify机制）</h3><p>从整体上来看Object的wait和notify&#x2F;notify是与对象监视器配合完成线程间的等待&#x2F;通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。两者除了在使用方式上不同外，在功能特性上还是有很多的不同：</p>
<ol>
<li>Condition能够支持不响应中断，而通过使用Object方式不支持；</li>
<li>Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个；</li>
<li>Condition能够支持超时时间的设置，而Object不支持。</li>
</ol>
<p>Condition详细原理参见<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/28387056eeb4">TODO</a></p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>它是一个采用双向链表实现的无界并发非阻塞队列，它属于 LinkedQueue 的安全版本。ConcurrentLinkedQueue 内部采用 CAS 操作保证线程安全，这是非阻塞队列实现的基础，相比 ArrayBlockingQueue、LinkedBlockingQueue 具备较高的性能。</p>
<p>ConcurrentLinkedQueue使用约定：</p>
<ol>
<li>不允许null入列</li>
<li>在入队的最后一个元素的next为null</li>
<li>队列中所有未删除的节点的item都不能为null且都能从head节点遍历到</li>
<li>删除节点是将item设置为null, 队列迭代时跳过item为null节点</li>
<li>head节点跟tail不一定指向头节点或尾节点，可能存在滞后性</li>
</ol>
<p><strong>注意</strong></p>
<p>ConcurrentLinkedQueue 中的tail节点不一定是最后一个节点，他可能是倒数第二个。所以ConcurrentLinkedQueue判断队尾条件是节点的next为null。</p>
<h3 id="HOPS-延迟更新的策略-的设计"><a href="#HOPS-延迟更新的策略-的设计" class="headerlink" title="HOPS(延迟更新的策略)的设计"></a>HOPS(延迟更新的策略)的设计</h3><p>tail和head是延迟更新的，两者更新触发时机为： </p>
<ul>
<li>tail更新触发时机：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过casTail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。 </li>
<li>head更新触发时机：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updateHead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。</li>
</ul>
<h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>LinkedTransferQueue是在JDK1.7时，J.U.C包新增的一种比较特殊的阻塞队列，它除了具备阻塞队列的常用功能外，还有一个比较特殊的transfer方法。</p>
<p>LinkedTransferQueue提供了两种构造器，也没有参数设置队列初始容量，所以是一种无界队列</p>
<p><strong>注意</strong></p>
<p>LinkedTransferQueue的单向链表中一定会有至少一个Node节点，既是LinkedTransferQueue队列集合通过默认的构造函数进行实例化时构建的“虚”节点，该节点的isData属性被标识为true，并且和该节点item属性实际引用数据对象的情况冲突（item属性为null），这样一来无论xfer操作进行的是入队操作还是出队操作，这个虚拟节点都会被排除在操作逻辑以外。并且因为q &#x3D; p.next和p &#x3D; q两个操作语句的缘故，代表当前正在处理的p引用会向单向链表的后续结点移动。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer 方法"></a>transfer 方法</h4><p>用于将指定元素e传递给消费者线程(调用take&#x2F;poll方法)。如果有消费者线程正在阻塞等待，则调用transfer方法的线程会直接将元素传递给它；如果没有消费者线程等待获取元素，则调用transfer方法的线程会将元素插入到队尾，然后阻塞等待，直到出现一个消费者线程获取元素。</p>
<p>在普通阻塞队列中，当队列为空时，消费者线程（调用take或poll方法的线程）一般会阻塞等待生产者线程往队列中存入元素。而LinkedTransferQueue的transfer方法则比较特殊：</p>
<ol>
<li>当有消费者线程阻塞等待时，调用transfer方法的生产者线程不会将元素存入队列，而是直接将元素传递给消费者。</li>
<li>如果调用transfer方法的生产者线程发现没有正在等待的消费者线程，则会将元素入队，然后会阻塞等待，直到有一个消费者线程来获取该元素。</li>
</ol>
<p>TransferQueue还提供了两个变种方法：tryTransfer(E e)、tryTransfer(E e, long timeout, TimeUnit unit)。</p>
<h4 id="tryTransfer-E-e"><a href="#tryTransfer-E-e" class="headerlink" title="tryTransfer(E e)"></a>tryTransfer(E e)</h4><p>当生产者线程调用tryTransfer方法时，如果没有消费者等待接收元素，则会立即返回false。该方法和transfer方法的区别就是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法必须等到消费者消费后才返回。</p>
<h4 id="tryTransfer-E-e-long-timeout-TimeUnit-unit"><a href="#tryTransfer-E-e-long-timeout-TimeUnit-unit" class="headerlink" title="tryTransfer(E e, long timeout, TimeUnit unit)"></a>tryTransfer(E e, long timeout, TimeUnit unit)</h4><p>tryTransfer（E e，long timeout，TimeUnit unit）方法则是加上了限时等待功能，如果没有消费者消费该元素，则等待指定的时间再返回；如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p>
<h4 id="xfer方法"><a href="#xfer方法" class="headerlink" title="xfer方法"></a>xfer方法</h4><p>xfer方法从字面上可以直译为“传送”，它是指通过多种操作模式，利用LinkedTransferQueue队列内置的单向链表，使数据对象在生产者和消费者间进行传递。JDK 9+开始，xfer操作的逻辑做了一次较大的改造，处理逻辑变得更加高效。</p>
<p>xfer方法是LinkedTransferQueue队列最核心的操作方法之一，其支撑了诸如offer、add、put、transfer、tryTransfer、take、poll等方法的内部实现。</p>
<h5 id="xfer方法参数"><a href="#xfer方法参数" class="headerlink" title="xfer方法参数"></a>xfer方法参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">xfer</span><span class="params">(E e, <span class="type">boolean</span> haveData, <span class="type">int</span> how, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>e：该参数就是本次进行传输的数据对象，如果当前xfer方法被消费者线程端调用，则e为null。</li>
<li>haveData：该参数指示本次xfer方法的调用是否有数据对象通过上一个e参数进行传入，也就是说e和haveData这两个参数是配对使用的。当e为null时，haveData应该为false；反之当e不为nul时，haveData应该为true。</li>
<li>how：本次xfer方法的操作模式。一共有四种: NOW, ASYNC, SYNC, TIMED。</li>
<li>nanos：本次xfer方法的操作超时时间（单位纳秒），当本次操作的操作模式为TIMED时（限时&#x2F;超时模式），需要通过该参数指定本次操作的超时时间。</li>
</ol>
<h5 id="xfer工作模式"><a href="#xfer工作模式" class="headerlink" title="xfer工作模式"></a>xfer工作模式</h5><p>xfer的调用方式主要分为四种工作模式，在xfer方法的入参中表现为四个不同的数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xfer方法的入参, 不同类型的方法内部调用xfer方法时入参不同.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NOW</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// for untimed poll, tryTransfer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ASYNC</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// for offer, put, add</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SYNC</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// for transfer, take</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMED</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// for timed poll, tryTransfer</span></span><br></pre></td></tr></table></figure>

<p>这四个常量值，作为xfer方法的入参，用于标识不同操作类型。其实从常量的命名也可以看出它们对应的操作含义：</p>
<h6 id="NOW"><a href="#NOW" class="headerlink" title="NOW"></a>NOW</h6><p>表示即时操作（可能失败），即不会阻塞调用线程：</p>
<ul>
<li>poll（获取并移除队首元素，如果队列为空，直接返回null）；</li>
<li>tryTransfer（尝试将元素传递给消费者，如果没有等待的消费者，则立即返回false，也不会将元素入队）</li>
</ul>
<h6 id="ASYNC"><a href="#ASYNC" class="headerlink" title="ASYNC"></a>ASYNC</h6><p>表示异步操作（必然成功）：</p>
<ul>
<li>offer（插入指定元素至队尾，由于是无界队列，所以会立即返回true）；</li>
<li>put（插入指定元素至队尾，由于是无界队列，所以会立即返回）；add（插入指定元素至队尾，由于是无界队列，所以会立即返回true）</li>
</ul>
<h6 id="SYNC"><a href="#SYNC" class="headerlink" title="SYNC"></a>SYNC</h6><p>表示同步操作（阻塞调用线程）：</p>
<ul>
<li>transfer（阻塞直到出现一个消费者线程）；</li>
<li>take（从队首移除一个元素，如果队列为空，则阻塞线程）</li>
</ul>
<h6 id="TIMED"><a href="#TIMED" class="headerlink" title="TIMED"></a>TIMED</h6><p>表示限时同步操作（限时阻塞调用线程）：</p>
<ul>
<li>poll(long timeout, TimeUnit unit)；</li>
<li>tryTransfer(E e, long timeout, TimeUnit unit)</li>
</ul>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">xfer</span><span class="params">(E e, <span class="type">boolean</span> haveData, <span class="type">int</span> how, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="literal">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最外层的for循环，遵循cas操作思想，只要操作不符合预期，就不停的重新操作</span></span><br><span class="line">  <span class="comment">// 直到操作结果符合预期为止</span></span><br><span class="line">  restart: <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>, t = <span class="literal">null</span>, h = <span class="literal">null</span>;;) &#123;</span><br><span class="line">    <span class="comment">// 这是初始化是决定当前p的位置是依据当前单向链表的head节点进行引用还是依据当前单向链表的tail节点进行引用</span></span><br><span class="line">    <span class="comment">// 其本质判断是当前操作是入队操作还是出队操作</span></span><br><span class="line">    <span class="comment">// 其最本质的判定是当前xfer操作的性质（haveData）和当前链表tail引用位置所描述的操作性质（t.isData）是否一致</span></span><br><span class="line">    <span class="comment">// 如果操作性质一致，当前xfer操作就是从tail引用位置开始判定和进行的入队操作</span></span><br><span class="line">    <span class="comment">// 如果操作性质不一致，当前xfer操作就是从head引用位置开始判定和进行的出队操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> (t != (t = tail) &amp;&amp; t.isData == haveData) ? t : (h = head);; ) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node q; <span class="keyword">final</span> Object item;</span><br><span class="line">      <span class="comment">// 出队操作的场景，其处理策略在此代码段落 </span></span><br><span class="line">      <span class="comment">// 只有当前处理节点p的isData标识和入参的haveData标识一致 </span></span><br><span class="line">      <span class="comment">// 且当前处理节点p真实的数据对象存在情况和入参的haveData标识一致 </span></span><br><span class="line">      <span class="keyword">if</span> (p.isData != haveData &amp;&amp; haveData == ((item = p.item) == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将局部变量h引用与当前单向链表的head位置</span></span><br><span class="line">        <span class="comment">// 避免在多线程情况下head引用被改变引起的处理错误</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">          h = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对当前节点进行原子性赋值：</span></span><br><span class="line">        <span class="comment">// 如果是生产者任务从队列中取出，那么赋值成功后，当前节点p的item属性将为e（不会为null）</span></span><br><span class="line">        <span class="comment">// 如果是消费者任务从队列中取出，那么赋值成功后，当前节点p的item属性将为null</span></span><br><span class="line">        <span class="keyword">if</span> (p.tryMatch(item, e)) &#123;</span><br><span class="line">          <span class="comment">// 在双跳队列进行数据取数操作时，当前处理节点p可能和h不一致，但一定是在h代表的节点“附近”</span></span><br><span class="line">          <span class="comment">// 所以，如果条件成立，就要进行以h代表的节点为基准的链表清理操作</span></span><br><span class="line">          <span class="keyword">if</span> (h != p) &#123;</span><br><span class="line">            skipDeadNodesNearHead(h, p);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> (E) item;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 入队操作的场景，其处理策略在此代码段落</span></span><br><span class="line">      <span class="comment">// 加入队列的可能是消费者任务，也可能是生产者任务</span></span><br><span class="line">      <span class="comment">// 根据之前对单向链表tail引用位置的描述，tail引用的位置不一定是单向链表的最后一个节点</span></span><br><span class="line">      <span class="comment">// 所以首先将p节点移动到链表的最后一个节点，否则就不进行业务逻辑处理</span></span><br><span class="line">      <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 操作方式为NOW的入队操作，将会被忽略</span></span><br><span class="line">        <span class="keyword">if</span> (how == NOW) &#123;</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队操作需要生成一个新的Node节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">          s = <span class="keyword">new</span> <span class="title class_">Node</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用原子操作，将当前操作s结点引用到当前p结点的item属性</span></span><br><span class="line">        <span class="comment">// 如果操作失败，说明p结点的next操作已经被其它线程中的操作所引用，</span></span><br><span class="line">        <span class="comment">// 那么通过内层的for循环继续进行操作</span></span><br><span class="line">        <span class="keyword">if</span> (!p.casNext(<span class="literal">null</span>, s)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前p节点引用的位置和t节点引用的可能是单向链表tail处的位置可能不一样</span></span><br><span class="line">        <span class="comment">// 引起这个的原因可能有很多：</span></span><br><span class="line">        <span class="comment">// a、当前xfer操作在中为p节点关联next属性的操作：p.casNext(null, s)不停失败，</span></span><br><span class="line">        <span class="comment">// 不停的在第二层for循环中做q = p.next 和 p == (p = q) 操作</span></span><br><span class="line">        <span class="comment">// b、虽然xfer操作成功了，但是当前线程连续进行了两次xfer调用操作（不好理解？后文将进行图例化讲解）</span></span><br><span class="line">        <span class="keyword">if</span> (p != t) &#123;</span><br><span class="line">          casTail(t, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (how == ASYNC) &#123;</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> awaitMatch(s, p, e, (how == TIMED), nanos);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 让p引用指向当前节点的下一个节点</span></span><br><span class="line">      <span class="comment">// 如果当前节点的next属性指向自己，说明当前节点已经被移除队列</span></span><br><span class="line">      <span class="comment">// 按照cas的思路，本次xfer操作需要重来</span></span><br><span class="line">      <span class="keyword">if</span> (p == (p = q)) &#123;</span><br><span class="line">        <span class="keyword">continue</span> restart;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">/** Tries to CAS-match this node; if successful, wakes waiter. */</span></span><br><span class="line"><span class="comment">// 这是LinkedTransferQueue.Node类中的方法</span></span><br><span class="line"><span class="comment">// 方法尝试如果当前Node对象的item属性值为cmp的情况下，重新赋值为val</span></span><br><span class="line"><span class="comment">// 如果设置成功，则解除当前Node所代表的等待线程的阻塞状态</span></span><br><span class="line"><span class="comment">// 这个阻塞状态的线程可能是生产者，也可能是生产者。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryMatch</span><span class="params">(Object cmp, Object val)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (casItem(cmp, val)) &#123;</span><br><span class="line">    LockSupport.unpark(waiter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是LinkedTransferQueue.Node类中的方法</span></span><br><span class="line"><span class="comment">// 该方法尝试如果当前Node对象的item属性值为cmp的情况下，重新赋值为val，并返回true</span></span><br><span class="line"><span class="comment">// 否则就返回false</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casItem</span><span class="params">(Object cmp, Object val)</span> &#123;</span><br><span class="line">  <span class="comment">// assert isData == (cmp != null);</span></span><br><span class="line">  <span class="comment">// assert isData == (val == null);</span></span><br><span class="line">  <span class="comment">// assert !(cmp instanceof Node);</span></span><br><span class="line">  <span class="keyword">return</span> ITEM.compareAndSet(<span class="built_in">this</span>, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>

<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue是一个基于堆的无界并发安全的优先级队列，每次出队都返回优先级最高的元素，数据结构是一个二叉树最小堆算法维护的数组，这个数组是可扩容的，直接遍历队列元素是无序的。</p>
<p>PriorityBlockingQueue可以理解为public操作都加锁的PriorityQueue，通过排他锁保证了操作的线程安全。PriorityBlockingQueue扩容时，因为增加堆数组的长度并不影响队列中元素的出队操作，因而使用自旋CAS操作实现的锁来控制扩容操作，仅在数组引用替换和拷贝元素时才加锁，从而减少了扩容对出队操作的影响。</p>
<p>PriorityBlockingQueue不允许null值，不允许未实现Comparable接口的对象。</p>
<p><strong>PriorityQueue特点</strong></p>
<ol>
<li>PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。</li>
<li>PriorityQueue不允许 null 值，而且不支持 non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</li>
<li>PriorityQueue的头是基于自然排序或者Comparator排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。当我们获取队列时，返回队列的头对象。</li>
<li>PriorityQueue的大小是不受限制的，所以<strong>put永远不会被阻塞</strong>。但在创建时可以指定初始大小，当我们向优先队列增加元素的时候，队列大小会<strong>自动增加</strong>。</li>
<li>PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。</li>
</ol>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间<strong>最短</strong>。</p>
<p>DelayQueue不允许null值。</p>
<h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><ul>
<li>可重入锁</li>
<li>用于根据delay时间排序的优先级队列</li>
<li>用于优化阻塞通知的线程元素leader</li>
<li>用于实现阻塞和通知的Condition对象</li>
</ul>
<h2 id="SynchronizedQueue"><a href="#SynchronizedQueue" class="headerlink" title="SynchronizedQueue"></a>SynchronizedQueue</h2><p>经典的生产者-消费者模式，操作流程是这样的：</p>
<ul>
<li>有多个生产者，可以并发生产产品，把产品置入队列中，如果队列满了，生产者就会阻塞；</li>
<li>有多个消费者，并发从队列中获取产品，如果队列空了，消费者就会阻塞；</li>
</ul>
<p>SynchronousQueue 也是一个队列来的，但它的特别之处在于它内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递）</p>
<ol>
<li>SynchronousQueue没有容量。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。</li>
<li>因为没有容量，所以对应 peek, contains, clear, isEmpty … 等方法其实是无效的。例如clear是不执行任何操作的，contains始终返回false,peek始终返回null。</li>
<li>SynchronousQueue分为公平和非公平，默认情况下采用非公平性访问策略，当然也可以通过构造函数来设置为公平性访问策略（为true即可）。</li>
<li>SynchronousQueue底层有两种数据结构：队列（TransferQueue，实现公平策略）和栈（TransferStack，实现非公平策略）</li>
<li>若使用 TransferQueue, 则队列中永远会存在一个 dummy node。</li>
</ol>
<p>参考资料:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/11/18/disruptor.html">https://tech.meituan.com/2016/11/18/disruptor.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/28387056eeb4">https://www.jianshu.com/p/28387056eeb4</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6970336648710062093">https://juejin.cn/post/6970336648710062093</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/af6f83c78506">https://www.jianshu.com/p/af6f83c78506</a></li>
<li><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html">https://pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yinwenjie/article/details/106796799">https://blog.csdn.net/yinwenjie/article/details/106796799</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/myseries/p/10944211.html">https://www.cnblogs.com/myseries/p/10944211.html</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2020/06/05/disruptor%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2020/06/05/disruptor%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">disruptor笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-05T00:00:00+08:00">2020-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span id="/posts/2020/06/05/disruptor%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="disruptor笔记" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Disruptor-简介"><a href="#Disruptor-简介" class="headerlink" title="Disruptor 简介"></a>Disruptor 简介</h2><p>Disruptor是一个开源的高性能队列框架，由英国外汇交易公司LMAX开发。研发的初衷是为了解决内存队列的延迟问题，能够在无锁的情况下实现队列的并发操作，基于Disruptor开发的系统单线程能支撑每秒600万订单。</p>
<h2 id="队列的特性"><a href="#队列的特性" class="headerlink" title="队列的特性"></a>队列的特性</h2><p>先进先出（FIFO），生产者往队列里发布事件，消费者获得通知消费事件；如果队列中没有事件时，消费者堵塞，直到生产者发布了新事件。</p>
<h2 id="Java-内置队列"><a href="#Java-内置队列" class="headerlink" title="Java 内置队列"></a>Java 内置队列</h2><table>
<thead>
<tr>
<th>队列</th>
<th>有界性</th>
<th>锁</th>
<th>阻塞</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>是</td>
<td>arraylist</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>是</td>
<td>linkedlist</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td>unbounded</td>
<td>CAS</td>
<td>否</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>CAS</td>
<td>是</td>
<td>linkedlist</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>是</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>是</td>
<td>heap</td>
</tr>
<tr>
<td>SynchronizedQueue</td>
<td>synchronized</td>
<td>CAS</td>
<td>是</td>
<td>linkedlist</td>
</tr>
</tbody></table>
<p>队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。</p>
<p>我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。</p>
<p>使用CAS协议实现的队列都是无界的（无法保证队列的长度在确定的范围内），理论上来说可以是无限扩展，那么如果生产者生产过快，消费者还没来得及消费，最终可能会导致内存溢出，影响系统稳定；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array&#x2F;heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。</p>
<p><strong>更多java原生队列相关知识，参见:</strong> <a href="#">Post not found: java原生队列 [java原生队列]</a></p>
<h2 id="队列加锁性能"><a href="#队列加锁性能" class="headerlink" title="队列加锁性能"></a>队列加锁性能</h2><p>现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。</p>
<p>Disruptor论文中讲述了一个实验：</p>
<ul>
<li>这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。</li>
<li>机器环境：2.4G 6核</li>
<li>运算： 64位的计数器累加5亿次</li>
</ul>
<table>
<thead>
<tr>
<th>Method</th>
<th>Time (ms)</th>
</tr>
</thead>
<tbody><tr>
<td>Single thread</td>
<td>300</td>
</tr>
<tr>
<td>Single thread with CAS</td>
<td>5,700</td>
</tr>
<tr>
<td>Single thread with lock</td>
<td>10,000</td>
</tr>
<tr>
<td>Single thread with volatile write</td>
<td>4,700</td>
</tr>
<tr>
<td>Two threads with CAS</td>
<td>30,000</td>
</tr>
<tr>
<td>Two threads with lock</td>
<td>224,000</td>
</tr>
</tbody></table>
<p>CAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下，速度比单线程无锁慢3个数量级。可见无锁速度最快。</p>
<p><strong>单线程</strong>情况下，不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能。</p>
<p><strong>多线程</strong>情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。</p>
<p>综上可知，加锁的性能是最差的。</p>
<h2 id="Disruptor-设计方案"><a href="#Disruptor-设计方案" class="headerlink" title="Disruptor 设计方案"></a>Disruptor 设计方案</h2><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>
<ol>
<li><p>环形数组结构<br> 为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p>
</li>
<li><p>元素位置定位<br> 数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>
</li>
<li><p>无锁设计<br> 每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>
</li>
</ol>
<h2 id="Disruptor-主要实现类"><a href="#Disruptor-主要实现类" class="headerlink" title="Disruptor 主要实现类"></a>Disruptor 主要实现类</h2><ol>
<li>Disruptor：Disruptor的入口，主要封装了环形队列RingBuffer、消费者集合ConsumerRepository的引用；主要提供了获取环形队列、添加消费者、生产者向RingBuffer中添加事件（可以理解为生产者生产数据）的操作；</li>
<li>RingBuffer：Disruptor中队列具体的实现，底层封装了Object[]数组；在初始化时，会使用Event事件对数组进行填充，填充的大小就是bufferSize设置的值；此外，该对象内部还维护了Sequencer（序列生产器）具体的实现；</li>
<li>Sequencer：序列生产器，分别有MultiProducerSequencer（多生产者序列生产器） 和 SingleProducerSequencer（单生产者序列生产器）两个实现类。上面的例子中，使用的是SingleProducerSequencer；在Sequencer中，维护了消费者的Sequence（序列对象）和生产者自己的Sequence（序列对象）；以及维护了生产者与消费者序列冲突时候的等待策略WaitStrategy；</li>
<li>Sequence：序列对象，内部维护了一个long型的value，这个序列指向了 RingBuffer 中 Object[] 数组具体的角标。生产者和消费者各自维护自己的Sequence；但都是指向 RingBuffer 的 Object[] 数组；</li>
<li>Wait Strategy：等待策略。当没有可消费的事件时，消费者根据特定的策略进行等待；当没有可生产的地方时，生产者根据特定的策略进行等待；</li>
<li>Event：事件对象，就是我们Ringbuffer中存在的数据，在Disruptor中用Event来定义数据，并不存在Event类，它只是一个定义；</li>
<li>EventProcessor：事件处理器，单独在一个线程内执行，判断消费者的序列和生产者序列关系，决定是否调用我们自定义的事件处理器，也就是是否可以进行消费；</li>
<li>EventHandler：事件处理器，由用户自定义实现，也就是最终的事件消费者，需要实现EventHandler接口；</li>
<li>Producer：事件生产者；</li>
</ol>
<h2 id="无锁设计实现原理"><a href="#无锁设计实现原理" class="headerlink" title="无锁设计实现原理"></a>无锁设计实现原理</h2><p>下面忽略数组的环形结构，介绍一下如何实现无锁设计。整个过程通过原子变量CAS，保证操作的线程安全。</p>
<h3 id="多生产者"><a href="#多生产者" class="headerlink" title="多生产者"></a>多生产者</h3><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。     </p>
<p>但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。</p>
<p>下面分读数据和写数据两种情况介绍。</p>
<h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><ol>
<li>申请读取到序号n；</li>
<li>若writer cursor &gt;&#x3D; n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；</li>
<li>消费者读取元素。</li>
</ol>
<p>如下图所示，读线程读到下标为2的元素，三个线程Writer1&#x2F;Writer2&#x2F;Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。</p>
<p>读线程申请读取到下标从3到11的元素，判断writer cursor&gt;&#x3D;11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p>
<p>然后，消费者读取下标从3到6共计4个元素。</p>
<p><img src="/imgs/disruptor%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85_%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B.png" alt="多个生产者情况下，消费者消费过程示意图"></p>
<h4 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h4><ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li>
<li>生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。</li>
</ol>
<p>如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。</p>
<p>Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。</p>
<p><img src="/imgs/disruptor%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85_%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B.png" alt="多个生产者情况下，生产者生产过程示意图"></p>
<h2 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a>等待策略</h2><h3 id="生产者等待策略"><a href="#生产者等待策略" class="headerlink" title="生产者等待策略"></a>生产者等待策略</h3><p>暂时只有休眠1ns。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.parkNanos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="消费者等待策略"><a href="#消费者等待策略" class="headerlink" title="消费者等待策略"></a>消费者等待策略</h3><table>
<thead>
<tr>
<th>名称</th>
<th>措施</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>BlockingWaitStrategy</td>
<td>加锁</td>
<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td>BusySpinWaitStrategy</td>
<td>自旋</td>
<td>通过不断重试，减少切换线程导致的系统调用，而降低延迟。推荐在线程绑定到固定的CPU的场景下使用</td>
</tr>
<tr>
<td>PhasedBackoffWaitStrategy</td>
<td>自旋 + yield + 自定义策略</td>
<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td>SleepingWaitStrategy</td>
<td>自旋 + yield + sleep</td>
<td>性能和CPU资源之间有很好的折中。延迟不均匀</td>
</tr>
<tr>
<td>TimeoutBlockingWaitStrategy</td>
<td>加锁，有超时限制</td>
<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td>YieldingWaitStrategy</td>
<td>自旋 + yield + 自旋</td>
<td>性能和CPU资源之间有很好的折中。延迟比较均匀</td>
</tr>
</tbody></table>
<p>参考资料:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://lmax-exchange.github.io/disruptor/user-guide/index.html">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/11/18/disruptor.html">https://tech.meituan.com/2016/11/18/disruptor.html</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2020/04/25/Redis%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2020/04/25/Redis%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Redis笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-25T00:00:00+08:00">2020-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span id="/posts/2020/04/25/Redis%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Redis笔记" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h2><p><img src="/imgs/redis%E7%AC%94%E8%AE%B0/db-redis-overview.png" alt="知识体系"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-overview.html">https://pdai.tech/md/db/nosql-redis/db-redis-overview.html</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/09/05/jenkins%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2019/09/05/jenkins%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">jenkins部署及使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-05T00:00:00+08:00">2019-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/09/05/jenkins%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8/" class="post-meta-item leancloud_visitors" data-flag-title="jenkins部署及使用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="jdk版本"><a href="#jdk版本" class="headerlink" title="jdk版本"></a>jdk版本</h2><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>V1.8</p>
<p>也可用新版本</p>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase-downloads.html">Java jdk 下载地址</a></p>
<h2 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h2><h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><p>Ubuntu 18.04.2 LTS</p>
<h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -</span><br><span class="line">sudo sh -c <span class="string">&#x27;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&#x27;</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install jenkins</span><br></pre></td></tr></table></figure>

<p>更改<code>/etc/init.d/jenkins</code>中配置: </p>
<ol>
<li>$HTTP_PORT后面端口为想要的端口, 如: 8800</li>
<li>PATH中加上本机java所在目录, 如: &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_212&#x2F;bin</li>
</ol>
<p>更改<code>/etc/default/jenkins</code>中设置: </p>
<ol>
<li>JAVA_ARGS&#x3D;”-Djava.awt.headless&#x3D;true -Xmx512m”, 作用是限制jenkins内存, 只是本机构建, 512m就够用了</li>
<li>HTTP_PORT&#x3D;8800 修改http端口</li>
</ol>
<p>其他默认即可</p>
<p>首次启动选择默认jenkins插件即可, 其他跟着一步一步操作即可</p>
<p>用到maven或者其他构建工具，需要在<em>全局工具配置</em>中进行配置</p>
<h4 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h4><p>一般来说选择<em>构建一个自由风格的软件项目</em>这一条就好，其他后需要的请在官网查看</p>
<ol>
<li>General, 根据需要选择构建信息，如果选择参数化构建过程，参数的名称在下面能够用到</li>
<li>源码管理，根据需要选择对应的代码管理，git或者svn</li>
<li>构建触发器，自行选择</li>
<li>构建环境，一般情况用不到，可以根据项目需求选用</li>
<li>构建，可以进行maven构建、shell执行等等</li>
</ol>
<p><strong>注意事项</strong></p>
<ol>
<li>部署应用之后如果应用刚起来就被jenkins杀掉，则需要在启动前加 <code>BUILD_ID=project</code> 这一行, project替换为自己的项目名<br> 如：构建好java应用，然后在<em>构建</em>那一栏增加执行shell，把构建好的Java应用部署到指定目录，然后用命令启动该程序，在启动该程序前需要加入该语句<br>代码示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;pwd: &quot;</span>`<span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">cd</span> ./target</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;pwd: &quot;</span>`<span class="built_in">pwd</span>`</span><br><span class="line">tar -xzvf project-deploy.tar.gz</span><br><span class="line"></span><br><span class="line">BUILD_ID=project</span><br><span class="line">bash ./project/bin/deploy.sh <span class="variable">$&#123;deploy_path&#125;</span> <span class="variable">$&#123;run_mode&#125;</span></span><br></pre></td></tr></table></figure>
上面的<code>deploy.sh</code>脚本自己根据需要自行编写，<em>deploy_path</em>和<em>run_mode</em>是<em>General</em>步骤中的参数名称</li>
</ol>
<p>除了BUILD_ID还有其他的可用的环境变量，<em>构建</em>步骤中的<em>执行shell</em>下面可以查看比较全的变量，也可以在官网看可以使用的<a target="_blank" rel="noopener" href="https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></p>
<p><a target="_blank" rel="noopener" href="https://jenkins.io/zh/doc/book/installing/">官方参考文档</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/07/26/REST%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2019/07/26/REST%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">REST软件架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-26T00:00:00+08:00">2019-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-07-30 00:00:00" itemprop="dateModified" datetime="2019-07-30T00:00:00+08:00">2019-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/architecture/" itemprop="url" rel="index"><span itemprop="name">architecture</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/07/26/REST%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/" class="post-meta-item leancloud_visitors" data-flag-title="REST软件架构" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Web技术发展"><a href="#Web技术发展" class="headerlink" title="Web技术发展"></a>Web技术发展</h4><p>World Wide Web（万维网），简称Web，是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。</p>
<h5 id="web形式发展"><a href="#web形式发展" class="headerlink" title="web形式发展"></a>web形式发展</h5><p>先后经历了web 1.0 —&gt; web 2.0 —&gt; web 3.0</p>
<p><strong>web 1.0</strong><br>开始于1994年，主要是静态的HTML页面发布信息，其特点是：信息杂乱无序，只满足了人们对信息的搜索、传递需求。</p>
<p><strong>web 2.0</strong><br>开始于2004年，在web 2.0中，软件被当成一种服务，Internet从一系列网站演化成一个成熟的为最终用户提供网络应用的服务平台，强调用户的参与、在线的网络协作、数据储存的网络化、社会关系网络、RSS应用以及文件的共享等成为了web 2.0发展的主要支撑和表现。web 2.0模式大大激发了创造和创新的积极性，使Internet重新变得生机勃勃。web 2.0的典型应用包括Blog、Wiki、RSS、Tag、SNS、P2P、IM等。其特点是：更加注重交互性；核心是指导思想；与1.0没有绝对的界限。</p>
<p><strong>web 3.0</strong><br>正在步入3.0，其特点是：智能化及个性化搜索引擎；数据的自由整合与有效聚合；适合多种终端平台，实现信息服务的普适性。</p>
<h6 id="web开发技术几个阶段"><a href="#web开发技术几个阶段" class="headerlink" title="web开发技术几个阶段"></a>web开发技术几个阶段</h6><ol>
<li><p>静态内容阶段<br>这个阶段web服务器作为共享文件服务器，存的大多是静态的HTML文档。</p>
</li>
<li><p>CGI程序阶段<br>这个阶段web服务器增加了一些编程API，通过API可以向客户端提供一些动态变化的内容。通信使用CGI（Common Gateway Interface）协议。</p>
</li>
<li><p>脚本语言阶段<br>这个阶段服务端出现ASP、PHP、JSP等，浏览器端出现Java Applet、Js等，提供了更加丰富的内容。</p>
</li>
<li><p>瘦客户端应用阶段<br>这个阶段出现了MVC模式，服务器端生成全部的动态内容。</p>
</li>
<li><p>RIA应用阶段<br>这个阶段出现了大量的RIA（Rich Internet Applications）技术，极大的完善了Web的用户体验，比如Ajax。</p>
</li>
<li><p>移动Web应用阶段<br>这个阶段出现了大量面向移动设备的Web应用技术，除了IOS、Android等操作系统平台原声的开发技术外，基于H5的开发技术越来越流行。</p>
</li>
</ol>
<h5 id="web技术结构基石"><a href="#web技术结构基石" class="headerlink" title="web技术结构基石"></a>web技术结构基石</h5><ol>
<li><p>URI</p>
</li>
<li><p>HTTP</p>
</li>
<li><p>HTML</p>
</li>
<li><p>MIME</p>
</li>
</ol>
<h4 id="REST介绍"><a href="#REST介绍" class="headerlink" title="REST介绍"></a>REST介绍</h4><p>REST（Representational State Transfer, 表现层状态转换）软件架构是由Roy Thomas Fielding博士在2000年首次提出的。他为我们描绘了开发基于互联网的网络软件的蓝图。REST软件架构是一个抽象的概念，是一种为了实现这一互联网的超媒体分布式系统的行动指南。</p>
<p>REST是目前世界上最成功的分布式应用架构风格（Web），<br>REST是所有Web应用都应该遵守的架构指导原则，违反了REST<br>的指导原则，网站应用功能仍能实现，但会付出很多代价，特别是<br>大流量的网站。</p>
<p>在不同阶段，REST给我们不同的印象：</p>
<ul>
<li>没接触REST时，会认为REST是一个技术</li>
<li>没有深入理解REST，日常使用仅限于修改REST风格的URI、增加PUT、DELETE操作等，会认为REST是一种具体的规范</li>
<li>深入理解之后，会发现REST是一种内含丰富的架构风格</li>
</ul>
<h4 id="REST的五个关键词"><a href="#REST的五个关键词" class="headerlink" title="REST的五个关键词"></a>REST的五个关键词</h4><h5 id="1-资源（Resource）"><a href="#1-资源（Resource）" class="headerlink" title="1. 资源（Resource）"></a>1. 资源（Resource）</h5><p>资源是一种看待服务器的方式，服务器就是由很多离散的资源组成。资源是以名词为核心来组织的，首先关注的应该是名词。一个资源由一个或多个URI来标识，URI也即是资源的名称，客户端对某个资源感兴趣即通过URI来交互。</p>
<h5 id="2-资源的表述（Representation）"><a href="#2-资源的表述（Representation）" class="headerlink" title="2. 资源的表述（Representation）"></a>2. 资源的表述（Representation）</h5><p>资源表述是指某一个资源某个时刻的状态描述，用于在客户端和服务端转移。例如：HTML&#x2F;XML&#x2F;JSON&#x2F;图片&#x2F;音频都是资源表述的格式。在通常的REST开发下，一般使用JSON作为HTTP请求响应的资源表述。</p>
<h5 id="3-状态转移（State-Transfer）"><a href="#3-状态转移（State-Transfer）" class="headerlink" title="3. 状态转移（State Transfer）"></a>3. 状态转移（State Transfer）</h5><p>状态转移是指通过转移和操作资源的表述，来实现操作资源的目的。在REST开发下，通常使用HTTP的GET&#x2F;POST&#x2F;PUT&#x2F;DELETE方法操作。</p>
<h5 id="4-统一接口（Uniform-Interface）"><a href="#4-统一接口（Uniform-Interface）" class="headerlink" title="4. 统一接口（Uniform Interface）"></a>4. 统一接口（Uniform Interface）</h5><p><span id="统一接口"></span>REST要求必须使用统一的接口来对资源进行操作。</p>
<p>REST要求对资源执行的操作，操作语义必须在HTPP消息体之前的部分完全表达，不能将操作语义封装到消息体内部。这样做为了提高交互可见性，便于通信的中间件实现缓存和安全审核。</p>
<p>REST是不依赖于任何协议的，但目前几乎所有的REST都是基于HTTP协议的。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p>
<p>非REST的接口，1000个人能写出1000个接口，例如对机器人的操作：<br>（1）&#x2F;api&#x2F;findRobots<br>（2）&#x2F;api&#x2F;robots&#x2F;select<br>REST API：<br>&amp;emsp;GET    &#x2F;rest&#x2F;robots&#x2F;{id} 查询一个机器人<br>&amp;emsp;POST   &#x2F;rest&#x2F;robots      新建一个机器人<br>&amp;emsp;PUT    &#x2F;rest&#x2F;robots&#x2F;{id} 更新一个机器人<br>&amp;emsp;DELETE &#x2F;rest&#x2F;robots&#x2F;{id} 删除一个机器人</p>
<p><strong>统一接口主要包括：</strong><br>（1）7个HTTP方法：GET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;PATCH&#x2F;HEAD&#x2F;OPTIONS<br>（2）HTTP头信息（可自定义）<br>（3）HTTP响应状态代码（可自定义）<br>（4）一套标准的内容协商机制<br>（5）一套标准的缓存机制<br>（6）一套标准的客户端身份认证机制</p>
<p><strong>HTTP方法幂等性</strong><br>幂等是指一次或多次请求一个资源的时候，应该具有相同的副作用。<br><strong>HTTP方法安全性</strong><br>安全是指对原有资源没有任何影响，安全性不代表请求一定不产生副作用。比如GET请求增加计数器，这种产生的副作用是服务端自作主张，服务端在设计的时候应该不让副作用太大，客户端可以这些请求不会产生副作用。</p>
<p>GET: 安全且幂等，用来获取资源表示<br>POST: 不安全且不幂等，用来创建资源或用于部分更新资源<br>PUT: 不安全且幂等，用替换的方式更新资源<br>DELETE: 不安全且幂等，用于删除一个资源</p>
<p>PUT和POST的区别：<br>PUT和POST最大的区别是PUT是幂等的，此外PUT需要完成的URI。<br>PUT    &#x2F;rest&#x2F;robots&#x2F;        是不会成功的，URI不能定位到具体的资源<br>PUT    &#x2F;rest&#x2F;robots&#x2F;{1234}  是会成功的，如果存在，则更新这个robots</p>
<h5 id="5-超文本驱动（Hypertext-Driven）"><a href="#5-超文本驱动（Hypertext-Driven）" class="headerlink" title="5. 超文本驱动（Hypertext Driven）"></a>5. 超文本驱动（Hypertext Driven）</h5><p>2008.10.28Fielding博士针对REST的滥用，发表了《REST API 必须是超文本驱动的》。他指出除非应用状态引擎是超文本驱动的，否则它就不是RESTFUL。</p>
<p>超文本驱动是客户端不再需要将某些接口的 URI 硬编码在代码中，唯一需要存储的只是 API 的 HOST 地址，能够非常有效的降低客户端与服务端之间的耦合，服务端对 URI 的任何改动都不会影响到客户端的稳定。</p>
<h4 id="REST架构约束"><a href="#REST架构约束" class="headerlink" title="REST架构约束"></a>REST架构约束</h4><h5 id="1-客户-服务器（Client-Server）"><a href="#1-客户-服务器（Client-Server）" class="headerlink" title="1. 客户-服务器（Client-Server）"></a>1. 客户-服务器（Client-Server）</h5><p>这个约束是基于客户端-服务器架构背后的原则—–关注点分离。通过分离用户界面和数据存储这两个关注点，提高了用户界面跨平台的可能性，通过简化服务器组件提高了其伸缩性。</p>
<h5 id="2-无状态（Stateless）"><a href="#2-无状态（Stateless）" class="headerlink" title="2. 无状态（Stateless）"></a>2. 无状态（Stateless）</h5><p>服务器不保存除单次请求外的通信状态，REST要求状态要么被放入资源状态中，要么保存在客户端，从客户端发出的每个请求都包含了服务端所必须的信息。</p>
<p>无状态约束使服务器的变化对客户端不可见，因而在连续的请求中，客户端并不依赖于同一台服务器，一台服务器坏掉了，客户端感知不到。</p>
<h5 id="3-可缓存（Cachable）"><a href="#3-可缓存（Cachable）" class="headerlink" title="3. 可缓存（Cachable）"></a>3. 可缓存（Cachable）</h5><p>互联网中的客户端和中间层服务器可以缓存响应。</p>
<p>因此响应必须直接或间接定义自身是否可被缓存，以免客户端使用过期的响应数据来发送其它请求。</p>
<p>良好的缓存策略可以有效减少客户端-服务器之间的交互，从而进一步提高系统的可伸缩性和性能。</p>
<h5 id="4-分层系统-（Layered-system）"><a href="#4-分层系统-（Layered-system）" class="headerlink" title="4. 分层系统 （Layered system）"></a>4. 分层系统 （Layered system）</h5><p>通过限制组件的行为（即，每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。</p>
<p>客户端通常无法判断它是否是直接连接到后端服务器，还是中间服务器。</p>
<p>中间服务器可通过启用负载平衡，并通过提供共享高速缓存来提高系统的可扩展性。</p>
<p>当然也可以强制执行安全政策。</p>
<h5 id="5-统一接口-（Unitform-interface）"><a href="#5-统一接口-（Unitform-interface）" class="headerlink" title="5. 统一接口 （Unitform interface）"></a>5. 统一接口 （Unitform interface）</h5><p><a href="#%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3">如上</a><br>(1) 资源标志的唯一性<br>(2) 资源的自描述性<br>(3) 超媒体驱动型<br>(4) 消息的自描述性</p>
<h5 id="6-按需代码（可选）"><a href="#6-按需代码（可选）" class="headerlink" title="6. 按需代码（可选）"></a>6. 按需代码（可选）</h5><p>支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Web/150564">https://baike.baidu.com/item/Web/150564</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/REST%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/2018579?fr=aladdin">https://baike.baidu.com/item/REST%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/2018579?fr=aladdin</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Roy Thomas Fielding博士论文地址</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/06/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2019/06/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">杂七杂八笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-29 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-29T00:00:00+08:00">2019-06-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/06/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="杂七杂八笔记" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>平日积累的一些小笔记，因比较杂且短，先放到本文中。</p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>$0——$9</p>
<p>$0代表完整的模式匹配文本（想index.css的话它全部都变成的斜体）,$1代表第一个x小括号的字串</p>
<p>比如 &#x2F;gai([\w]+?)over([\d]+)&#x2F; 匹配 gainover123 $1&#x3D; 括号里的 n $2&#x3D; 第2个括号里的 123</p>
<h3 id="jdb命令"><a href="#jdb命令" class="headerlink" title="jdb命令"></a>jdb命令</h3><p>jdb -connect sun.jvm.hotspot.jdi.SAPIDAttachingConnector:pid&#x3D;<br>jdb -attach 127.0.0.1:<br>stop in org.zoolu.iax.protocol.peer.Peer.handleRecvFrame(byte[])<br>clear org.zoolu.iax.protocol.peer.Peer.handleRecvFrame(byte[])</p>
<h3 id="Component和Repository注入两次解决方案"><a href="#Component和Repository注入两次解决方案" class="headerlink" title="Component和Repository注入两次解决方案"></a>Component和Repository注入两次解决方案</h3><p>因为一些需要，所以需要加个定时器，并且在InitializingBean中的afterPropertiesSet中启动。完成后，加了一些log，看一下是否成功。</p>
<p>最初的时候是在加了@Repository注解的类里面实现的，当时日志就重复打印了一次，一共打印了两次，但是当时在调试主要功能，也没太注意。后来，为了Dao类的纯粹性，就把定时器移到了加了@Service的类里面。这时候，日志打印次数正常。</p>
<p>后来，功能调试OK后，觉得放在Service中也不太合适，就新建了一个类，把定时器移到了Component中，然后运行，如果无误，就准备提交代码了。这时候，日志又重新打印了两次。</p>
<p>然后首先想到的是去网上搜索，搜到的都是 加上@Scope(“singleton”)改为单例、把类上的@Component改为只加载一次的注解等等。</p>
<p>后来，我就用debug模式，自己去跟踪，后来发现，我的代码中@Component和@Repository被加载了两次，@Controller和@Service被加载了一次。试了很多种方案，都没有用，想加个全局变量类控制一下定时任务，但是第二次注入相当于是重新注入，所以也没有用。后来发现是配置中自动扫描注解的配置有交集。</p>
<p>在很多配置中一般都会把Spring-common.xml和Spring-MVC.xml进行分开配置，这种配置就行各施其职一样，显得特别清晰。</p>
<p>在Spring-MVC.xml中只对@Controller进行扫描就可，作为一个控制器，其他的事情不做。</p>
<p>在Spring-common.xml中只对一些事务逻辑的注解扫描。</p>
<p>现在给定一个项目包的机构:<br>com.fq.controlller<br>com.fq.service</p>
<p>正确的是：</p>
<!-- 扫描@Controller注解 -->
<p>&lt;context:component-scan base-package&#x3D;”com.fq.controller”&gt;<br>    &lt;context:include-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Controller” &#x2F;&gt;<br></context:component-scan></p>
<p>我的配置里面Spring-MVC.xml并没有具体到controller，而是com.fq.*</p>
<p>所以我在Spring-MVC.xml中加入了exclude-filter</p>
<!-- 扫描@Controller注解 -->
<p>&lt;context:component-scan base-package&#x3D;”com.fq.controller”&gt;<br>    &lt;context:include-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Controller” &#x2F;&gt;<br>    &lt;context:exclude-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Service” &#x2F;&gt;<br>    &lt;context:exclude-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Repository” &#x2F;&gt;<br>    &lt;context:exclude-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Component” &#x2F;&gt;<br></context:component-scan></p>
<p>这样，确实是加载了一次，但是访问不了Controller。经过排查，发现Controlle并没有被加载，经过测试，发现是<br>&lt;context:exclude-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Component” &#x2F;&gt;<br>这条语句导致的。</p>
<p>我把改为具体到Controller包，把那些exclude-filter都去掉之后，所有都正常了，但是还是对这个原因有些疑惑，然后我就看了一下include-filter和exclude-filter的区别。比较好的是下面这个文章，虽然短，但是描述的很清晰。</p>
<p>include-filter和exclude-filter的区别 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/hanguocai/p/7783078.html">https://www.cnblogs.com/hanguocai/p/7783078.html</a></p>
<p>需要把<a href="context:component-scan">context:component-scan</a>的use-default-filters属性设置为false，默认为true，同时需要把那些exclude-filter去掉</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)</p>
<p>workQueue 还可能是 SynchronousQueue 队列</p>
<p>当 workQueue 是 LinkedBlockingDeque<Runnable> 时，当需要执行的线程数大于 corePoolSize，则忽略 maximumPoolSize 和 keepAliveTime，在线程池里线程数达到 corePoolSize 后把之后的任务放到队列里，在队列满的时候才创建线程直到线程数达到 maximumPoolSize ，继续有任务时，抛出异常。</p>
<p>当 workQueue 是 SynchronousQueue 时，当需要执行的线程数大于 corePoolSize，在线程池里的线程数达到 corePoolSize 后，继续创建线程执行任务；当线程池里的线程数达到 maximumPoolSize 后，则继续处理之前的任务，其他任务不再处理，且抛出异常。</p>
<h3 id="yaml配置"><a href="#yaml配置" class="headerlink" title="yaml配置"></a>yaml配置</h3><p>Yaml文件被解析为Map形式</p>
<p>“:”前是key，后是value</p>
<p>每一行之前加”- “表示是数组或List</p>
<p>字符串用双引号括起来，不会对里面的内容进行转意；<br>用单引号括起来，会对里面的内容进行转意，特殊字符最终只是一个普通的字符串数据，该是什么还是什么</p>
<h3 id="Java-nio-空轮询bug"><a href="#Java-nio-空轮询bug" class="headerlink" title="Java nio 空轮询bug"></a>Java nio 空轮询bug</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-nio-select-epoll.html">https://pdai.tech/md/java/io/java-io-nio-select-epoll.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45076180/article/details/113242674">https://blog.csdn.net/qq_45076180/article/details/113242674</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>暂无</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/05/28/protobuf%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2019/05/28/protobuf%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">protobuf使用详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-28 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-28T00:00:00+08:00">2019-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-06-28 00:00:00" itemprop="dateModified" datetime="2019-06-28T00:00:00+08:00">2019-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/protocol/" itemprop="url" rel="index"><span itemprop="name">protocol</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/05/28/protobuf%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="protobuf使用详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>proto2</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="字段域类型（Specifying-Field-Rules）"><a href="#字段域类型（Specifying-Field-Rules）" class="headerlink" title="字段域类型（Specifying Field Rules）"></a>字段域类型（Specifying Field Rules）</h5><p>You specify that message fields are one of the following:</p>
<ol>
<li><strong>required</strong>: a well-formed message must have exactly one of this field.</li>
<li><strong>optional</strong>: a well-formed message can have zero or one of this field (but not more than one).</li>
<li><strong>repeated</strong>: this field can be repeated any number of times (including zero) in a well-formed message. The order of the repeated values will be preserved.</li>
</ol>
<p>也可以用<strong>map</strong>: map&lt;string, int32&gt; param &#x3D; 1;</p>
<h5 id="字段值类型（Scalar-Value-Types）"><a href="#字段值类型（Scalar-Value-Types）" class="headerlink" title="字段值类型（Scalar Value Types）"></a>字段值类型（Scalar Value Types）</h5><table>
<thead>
<tr>
<th align="left">.proto Type</th>
<th align="left">Notes</th>
<th align="left">C++ Type</th>
<th align="left">Java Type</th>
<th align="left">Python Type<a href="#refer-anchor-2"><sup>2</sup></a></th>
<th align="left">Go Type</th>
</tr>
</thead>
<tbody><tr>
<td align="left">double</td>
<td align="left"></td>
<td align="left">double</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">*float64</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left"></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">*float32</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">*int32</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long<a href="#refer-anchor-3"><sup>3</sup></a></td>
<td align="left">*int64</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">Uses variable-length encoding.</td>
<td align="left">uint32</td>
<td align="left">int<a href="#refer-anchor-1"><sup>1</sup></a></td>
<td align="left">int&#x2F;long<a href="#refer-anchor-3"><sup>3</sup></a></td>
<td align="left">*uint32</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">Uses variable-length encoding.</td>
<td align="left">uint64</td>
<td align="left">long<a href="#refer-anchor-1"><sup>1</sup></a></td>
<td align="left">int&#x2F;long<a href="#refer-anchor-3"><sup>3</sup></a></td>
<td align="left">*uint64</td>
</tr>
<tr>
<td align="left">sint32</td>
<td align="left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">*int32</td>
</tr>
<tr>
<td align="left">sint64</td>
<td align="left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long<a href="#refer-anchor-3"><sup>3</sup></a></td>
<td align="left">*int64</td>
</tr>
<tr>
<td align="left">fixed32</td>
<td align="left">Always four bytes. More efficient than uint32 if values are often greater than 228.</td>
<td align="left">uint32</td>
<td align="left">int<a href="#refer-anchor-1"><sup>1</sup></a></td>
<td align="left">int&#x2F;long<a href="#refer-anchor-3"><sup>3</sup></a></td>
<td align="left">*uint32</td>
</tr>
<tr>
<td align="left">fixed64</td>
<td align="left">Always eight bytes. More efficient than uint64 if values are often greater than 256.</td>
<td align="left">uint64</td>
<td align="left">long<a href="#refer-anchor-1"><sup>1</sup></a></td>
<td align="left">int&#x2F;long<a href="#refer-anchor-3"><sup>3</sup></a></td>
<td align="left">*uint64</td>
</tr>
<tr>
<td align="left">sfixed32</td>
<td align="left">Always four bytes.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">*int32</td>
</tr>
<tr>
<td align="left">sfixed64</td>
<td align="left">Always eight bytes.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long<a href="#refer-anchor-3"><sup>3</sup></a></td>
<td align="left">*int64</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">bool</td>
<td align="left">*bool</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">A string must always contain UTF-8 encoded or 7-bit ASCII text.</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">unicode (Python 2) or str (Python 3)</td>
<td align="left">*string</td>
</tr>
<tr>
<td align="left">bytes</td>
<td align="left">May contain any arbitrary sequence of bytes.</td>
<td align="left">string</td>
<td align="left">ByteString</td>
<td align="left">bytes</td>
<td align="left">[]byte</td>
</tr>
</tbody></table>
<p>You can find out more about how these types are encoded when you serialize your message in Protocol Buffer Encoding.</p>
<ul>
<li><div id="refer-anchor-1"> [1] In Java, unsigned 32-bit and 64-bit integers are represented using their signed counterparts, with the top bit simply being stored in the sign bit.</div>
</li>
<li><div id="refer-anchor-2">[2] In all cases, setting values to a field will perform type checking to make sure it is valid.</div>
</li>
<li><div id="refer-anchor-3">[3] 64-bit or unsigned 32-bit integers are always represented as long when decoded, but can be an int if an int is given when setting the field. In all cases, the value must fit in the type represented when set. See [2].</div></li>
</ul>
<h4 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h4><p><strong>示例</strong></p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> pageNumber = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> resultPerPage = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enum可以定义在message中, 也可以定义在外面。</p>
<p>proto文件批量编译</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (*.proto) <span class="keyword">do</span> (</span><br><span class="line">    .\protoc.exe --java_out=.\java\ <span class="variable">%%i</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ol>
<li>syntax &#x3D; “proto2”表示用的是proto2, 不声明默认proto3<br> 原因: 某些语言不支持proto3，如：lua</li>
<li>package表示在的包目录</li>
<li>option java_outer_classname表示生成的java文件名</li>
<li>message中引用自定义的message类型, 被引用的message需要放在上方<br> 原因: 某些语言是顺序读取, 不支持乱序读取，如：lua</li>
</ol>
<!-- #### 程序中请求定义

**示例**
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.apomelo.test.protobuf;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;TestMessage&quot;</span>;</span><br><span class="line"><span class="comment">//range: 101---199</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">TestReq</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> query = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">TestResp</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> query = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ol>
<li>&#x2F;&#x2F;range: 101—199 这个必须有, 格式也要一样, 数值可以更改, 如: &#x2F;&#x2F;range: 201—299<br> 原因: proto生成工具需要用到</li>
<li>请求必须以Req结尾, 响应必须以Resp结尾<br> 原因: 这样定义之后可以直接用工具生成相应的请求处理器</li>
</ol>
<h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><h4 id="proto编译工具"><a href="#proto编译工具" class="headerlink" title="proto编译工具"></a>proto编译工具</h4><ol>
<li>根据请求生成请求类型<br> 工具: src&#x2F;main&#x2F;resources&#x2F;bin&#x2F;build&#x2F;proto_handler_generate.py<br> 命令: python proto_handler_generate.py<br> 可选参数: proto_path（proto文件所在目录）, build_path（生成的Java请求处理器所在的目录）, rebuild（是否重新构建所有的请求, 默认false）</li>
<li>编译proto<br> 工具: src&#x2F;main&#x2F;resources&#x2F;proto&#x2F;build.bat<br> 命令: 直接运行（根据需求自己修改生成的目录）</li>
<li>复制proto文件并提交到项目的proto文件夹中<br> 工具: src&#x2F;main&#x2F;resources&#x2F;proto&#x2F;copy.bat<br> 命令: 直接运行（根据需求自己修改复制的目录） –&gt;</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/02/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2019/02/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">基础算法专题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-19T00:00:00+08:00">2019-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-04-23 00:00:00" itemprop="dateModified" datetime="2019-04-23T00:00:00+08:00">2019-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/02/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="post-meta-item leancloud_visitors" data-flag-title="基础算法专题" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>最近发现自己基础算法方面还有些欠缺。虽然之前也看过数据结构、算法导论、计算机网络等等一些基础书籍，也都理解基础算法和数据结构，但因为没有每道都手写过，所以当真正去实现时还需要去查阅参考资料。由此，下定决心弥补这些不足。基础算法在工作中对业务理解、代码编写并没有非常显著的提升，但是个人觉得这些影响是潜在的，它会潜在的影响你的思考和解决方案。总之，基础夯实终归是没错的。</p>
<p>目前较为推荐的有牛客的剑指offer、LeetCode的Top 100 Liked Questions。个人更推荐LeetCode，但是牛客有手机App，如果想在上下班路上刷一刷，可以选择牛客。我也是因此选择先刷牛客，下面是相关的题目和个人通过编译的答案，不定期更新，如答案中有错误之处烦请指出。</p>
<h1 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h1><h2 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="JZ6-从尾到头打印链表"><a href="#JZ6-从尾到头打印链表" class="headerlink" title="JZ6 从尾到头打印链表"></a>JZ6 从尾到头打印链表</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p>
<p>如输入{1,2,3}的链表，返回一个数组为[3,2,1]</p>
<p>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</p>
<p><strong>示例1</strong><br>输入: {1,2,3}<br>返回值: [3,2,1]<br><strong>示例2</strong><br>输入: {67,0,24,58}<br>返回值: [58,24,0,67]</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: </span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (listNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(listNode);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            result.add(stack.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ24-反转链表"><a href="#JZ24-反转链表" class="headerlink" title="JZ24 反转链表"></a>JZ24 反转链表</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>给定一个单链表的头结点pHead，长度为n，反转该链表后，返回新链表的表头。</p>
<p>数据范围: n≤1000<br>要求: 空间复杂度 O(1)，时间复杂度 O(n)。</p>
<p>如当输入链表{1,2,3}时，<br>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p>
<p><strong>示例1</strong><br>输入: {1,2,3}<br>返回值: {3,2,1}<br><strong>示例2</strong><br>输入: {}<br>返回值: {}<br>说明: 空链表则输出空</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ25-合并两个排序的链表"><a href="#JZ25-合并两个排序的链表" class="headerlink" title="JZ25 合并两个排序的链表"></a>JZ25 合并两个排序的链表</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。<br>数据范围:  0≤n≤1000，−1000≤节点值≤1000<br>要求: 空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}<br>输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}</p>
<p><strong>示例1</strong><br>输入: {1,3,5},{2,4,6}<br>返回值: {1,2,3,4,5,6}<br><strong>示例2</strong><br>输入: {},{}<br>返回值: {}</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="literal">null</span>) cur.next = list1;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="literal">null</span>) cur.next = list2;</span><br><span class="line">        <span class="keyword">return</span> h.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ52-两个链表的第一个公共结点"><a href="#JZ52-两个链表的第一个公共结点" class="headerlink" title="JZ52 两个链表的第一个公共结点"></a>JZ52 两个链表的第一个公共结点</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p>数据范围：n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p>
<p><strong>示例1</strong><br>输入: {1,2,3},{4,5},{6,7}<br>返回值: {6,7}<br>说明: 第一个参数{1,2,3}代表是第一个链表非公共部分，第二个参数{4,5}代表是第二个链表非公共部分，最后的{6,7}表示的是2个链表的公共部分。这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的。<br><strong>示例2</strong><br>输入: {1},{2,3},{}<br>返回值: {}<br>说明: 2个链表没有公共节点 ,返回null，后台打印{}</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法：使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。</span></span><br><span class="line"><span class="comment">// 让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。</span></span><br><span class="line"><span class="comment">// 因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> pHead1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> pHead2;</span><br><span class="line">        <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">            l1 = (l1 == <span class="literal">null</span>) ? pHead2 : l1.next;</span><br><span class="line">            l2 = (l2 == <span class="literal">null</span>) ? pHead1 : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ23-链表中环的入口结点"><a href="#JZ23-链表中环的入口结点" class="headerlink" title="JZ23 链表中环的入口结点"></a>JZ23 链表中环的入口结点</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 链表 哈希 双指针</p>
<p><strong>描述</strong></p>
<p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p>
<p>数据范围： n≤10000，1&lt;&#x3D;结点值&lt;&#x3D;10000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p>
<p>返回值描述：<br>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p>
<p><strong>示例1</strong><br>输入: {1,2},{3,4,5}<br>返回值: “null”<br>说明: 没有环，返回对应编程语言的空结点，后台程序会打印”null”<br><strong>示例2</strong><br>输入: {},{2}<br>返回值: 2<br>说明: 环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 用HashMap (不推荐)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用set来记录出现的结点</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当set中包含结点，说明第一次出现重复的结点，即环的入口结点</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(pHead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// set中加入未重复的结点</span></span><br><span class="line">            set.add(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用快慢指针</span></span><br><span class="line"><span class="comment">// 在环上的时候快指针与慢指针之间差N步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差(N+1-2)-&gt; N-1步。</span></span><br><span class="line"><span class="comment">// 所以快指针必然与慢指针相遇。又因为快指针速度是慢指针的两倍，所以相遇时必然只绕了一圈。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 快指针是满指针的两倍速度</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 记录快慢指针第一次相遇的结点</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若是快指针指向null，则不存在环</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新指向链表头部</span></span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ22-链表中倒数最后k个结点"><a href="#JZ22-链表中倒数最后k个结点" class="headerlink" title="JZ22 链表中倒数最后k个结点"></a>JZ22 链表中倒数最后k个结点</h4><p>时间限制: 1秒<br>空间限制: 256M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。<br>如果该链表长度小于k，请返回一个长度为 0 的链表。</p>
<p>数据范围：0≤n≤10<sup>5</sup>，0≤a<sub>i</sub>≤10<sup>9</sup>，0≤k≤10<sup>9</sup></p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例1</strong><br>输入: {1,2,3,4,5},2<br>返回值: {4,5}<br>说明：返回倒数第2个节点4，系统会打印后面所有的节点来比较。<br><strong>示例2</strong><br>输入: {2},8<br>返回值: {}</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor1</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor2</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor1 = cursor1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cursor1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cursor1 = cursor1.next;</span><br><span class="line">            cursor2 = cursor2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 直接遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> ((cursor = cursor.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i - k; j ++) &#123;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3: 用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//链表节点压栈</span></span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断栈的元素是否小于k</span></span><br><span class="line">        <span class="keyword">if</span> (stack.size() &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在出栈串成新的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstNode</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">while</span> (--k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将出栈的元素重新连接成为链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            temp.next = firstNode;</span><br><span class="line">            firstNode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ35-复杂链表的复制"><a href="#JZ35-复杂链表的复制" class="headerlink" title="JZ35 复杂链表的复制"></a>JZ35 复杂链表的复制</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。</p>
<p>示例:<br>输入:<code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>输出:<code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>解析:我们将链表分为两段，前半部分<code>&#123;1,2,3,4,5&#125;</code>为ListNode，后半部分<code>&#123;3,5,#,2,#&#125;</code>是随机指针域表示。<br>以上示例前半部分可以表示链表为的ListNode:1-&gt;2-&gt;3-&gt;4-&gt;5<br>后半部分，<code>3，5，#，2，#</code>分别的表示为<br>1的位置指向3，2的位置指向5，3的位置指向null，4的位置指向2，5的位置指向null</p>
<p><strong>示例1</strong><br>输入: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>返回值: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 借助map构建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pHead;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(cur.label));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 链表拼接、拆分</span></span><br><span class="line"><span class="comment">// 考虑构建 原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 克隆基础链表</span></span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RandomListNode</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(cur.label);</span><br><span class="line">            clone.next = cur.next;</span><br><span class="line">            cur.next = clone;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 克隆随机链表</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next.random = cur.random != <span class="literal">null</span> ? cur.random.next : <span class="literal">null</span>;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拆分链表</span></span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cloneHead</span> <span class="operator">=</span> pHead.next;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">old</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">clone</span> <span class="operator">=</span> cloneHead;</span><br><span class="line">        <span class="keyword">while</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            old.next = clone.next;</span><br><span class="line">            <span class="keyword">if</span> (old.next != <span class="literal">null</span>) &#123; </span><br><span class="line">                clone.next = old.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            old = old.next;</span><br><span class="line">            clone = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ76-删除链表中重复的结点"><a href="#JZ76-删除链表中重复的结点" class="headerlink" title="JZ76 删除链表中重复的结点"></a>JZ76 删除链表中重复的结点</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5  处理后为 1-&gt;2-&gt;5</p>
<p>数据范围：链表长度满足 0≤n≤1000  ，链表中的值满足 1≤val≤1000 </p>
<p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>例如输入{1,2,3,3,4,4,5}时，对应的输出为{1,2,5}</p>
<p><strong>示例1</strong><br>输入: {1,2,3,3,4,4,5}<br>返回值: {1,2,5}<br><strong>示例2</strong><br>输入: {1,1,1,8}<br>返回值: {8}</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 给链表前加上表头，删除所有重复的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplication</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在链表前加一个表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        res.next = pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//遇到相邻两个节点值相同</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == temp)</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时去掉表头</span></span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用HashMap计数</span></span><br></pre></td></tr></table></figure>

<h4 id="JZ18-删除链表的节点"><a href="#JZ18-删除链表的节点" class="headerlink" title="JZ18 删除链表的节点"></a>JZ18 删除链表的节点</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<p>1.此题对比原题有改动<br>2.题目保证链表中节点的值互不相同<br>3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<p>数据范围:<br>0&lt;&#x3D;链表节点值&lt;&#x3D;10000<br>0&lt;&#x3D;链表长度&lt;&#x3D;10000</p>
<p><strong>示例1</strong><br>输入: {2,5,1,9},5<br>返回值: {2,1,9}<br>说明: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 1 -&gt; 9<br><strong>示例2</strong><br>输入: {2,5,1,9},1<br>返回值: {2,5,9}<br>说明: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 5 -&gt; 9</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法: 添加头结点，找到对应节点后退出循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span> <span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 添加头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        res.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="JZ55-二叉树的深度"><a href="#JZ55-二叉树的深度" class="headerlink" title="JZ55 二叉树的深度"></a>JZ55 二叉树的深度</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。</p>
<p>数据范围：节点的数量满足 0≤n≤100 ，节点上的值满足 0≤val≤100<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例1</strong><br>输入: {1,2,3,4,5,#,6,#,#,7}<br>返回值: 4<br><strong>示例2</strong><br>输入: {}<br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(TreeDepth(root.left), TreeDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ77-按之字形顺序打印二叉树"><a href="#JZ77-按之字形顺序打印二叉树" class="headerlink" title="JZ77 按之字形顺序打印二叉树"></a>JZ77 按之字形顺序打印二叉树</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 栈 树 队列</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p>
<p>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;&#x3D;1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)<br>例如：<br>给定的二叉树是<code>&#123;1,2,3,#,#,4,5&#125;</code><br>该二叉树之字形层序遍历的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1],</span><br><span class="line">[3,2],</span><br><span class="line">[4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例1</strong><br>输入: <code>&#123;1,2,3,#,#,4,5&#125;</code><br>返回值: <code>[[1],[3,2],[4,5]]</code><br><strong>示例2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>[[8],[10,6],[5,7,9,11]]</code><br><strong>示例3</strong><br>输入: <code>&#123;1,2,3,4,5&#125;</code><br>返回值: <code>[[1],[3,2],[4,5]]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 用链表，一个链表记录当前层，一个链表记录下一层，也可用栈</span></span><br><span class="line"><span class="comment">// 注意: 每次都从后往前遍历，即可翻转，但是第一层节点右节点先入下一层，第二层左节点先，如此反复</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        layer.add(pRoot);</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;() &#123;&#123;add(pRoot.val);&#125;&#125;);</span><br><span class="line">        <span class="keyword">while</span> (layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;TreeNode&gt; nextLayer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; nextLayerValue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (result.size() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> layer.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> layer.get(i);</span><br><span class="line">                    addTreeNode(treeNode.right, nextLayer, nextLayerValue);</span><br><span class="line">                    addTreeNode(treeNode.left, nextLayer, nextLayerValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> layer.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> layer.get(i);</span><br><span class="line">                    addTreeNode(treeNode.left, nextLayer, nextLayerValue);</span><br><span class="line">                    addTreeNode(treeNode.right, nextLayer, nextLayerValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            layer = nextLayer;</span><br><span class="line">            <span class="keyword">if</span> (nextLayerValue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(nextLayerValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTreeNode</span><span class="params">(TreeNode treeNode, ArrayList&lt;TreeNode&gt; nextLayer, ArrayList&lt;Integer&gt; nextLayerValue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextLayer.add(treeNode);</span><br><span class="line">            nextLayerValue.add(treeNode.val);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ54-二叉搜索树的第k个节点"><a href="#JZ54-二叉搜索树的第k个节点" class="headerlink" title="JZ54 二叉搜索树的第k个节点"></a>JZ54 二叉搜索树的第k个节点</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树 dfs 递归</p>
<p><strong>描述</strong></p>
<p>给定一棵结点数为n 二叉搜索树，请找出其中的第 k 小的TreeNode结点值。<br>1.返回第k小的节点值即可<br>2.不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1<br>3.保证n个节点的值不一样</p>
<p>数据范围：0≤n≤1000，0≤k≤1000，树上每个结点的值满足 0≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>如输入<code>&#123;5,3,7,2,4,6,8&#125;,3</code>时。该二叉树所有节点按结点值升序排列后可得<code>[2,3,4,5,6,7,8]</code>，所以第3个结点的结点值为4，故返回对应结点值为4的结点即可。</p>
<p><strong>示例1</strong><br>输入: {5,3,7,2,4,6,8},3<br>返回值: 4<br><strong>示例2</strong><br>输入: {},1<br>返回值: -1<br>说明: 当树是空</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 递归 用链表存储数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KthNode</span><span class="params">(TreeNode proot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (proot == <span class="literal">null</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        addNode(list, proot);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; list.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(List&lt;Integer&gt; list, TreeNode curNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(list, curNode.left);</span><br><span class="line">        list.add(curNode.val);</span><br><span class="line">        addNode(list, curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 递归 计数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KthNode</span><span class="params">(TreeNode proot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 记录返回的节点</span></span><br><span class="line">        TreeNode[] res = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[] &#123;<span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="comment">// 记录中序遍历了多少个</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        midOrder(res, count, proot, k);</span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">0</span>].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midOrder</span><span class="params">(TreeNode[] res, <span class="type">int</span>[] count, TreeNode curNode, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//当遍历到节点为空或者超过k时，返回</span></span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="literal">null</span> || count[<span class="number">0</span>] &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        midOrder(res, count, curNode.left, k);</span><br><span class="line">        count[<span class="number">0</span>] ++;</span><br><span class="line">        <span class="comment">// 只记录第k个</span></span><br><span class="line">        <span class="keyword">if</span> (count[<span class="number">0</span>] == k) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        midOrder(res, count, curNode.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ7-重建二叉树"><a href="#JZ7-重建二叉树" class="headerlink" title="JZ7 重建二叉树"></a>JZ7 重建二叉树</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树 dfs 数组</p>
<p><strong>描述</strong></p>
<p>给定节点数为 n 二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。<br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628"></p>
<p>提示:<br>1.vin.length &#x3D;&#x3D; pre.length<br>2.pre 和 vin 均无重复元素<br>3.vin出现的元素均出现在 pre里<br>4.只需要返回根结点，系统会自动输出整颗树做答案对比</p>
<p>数据范围：n≤2000，节点的值 −10000≤val≤10000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例1</strong><br>输入: <code>[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]</code><br>返回值: {1,2,3,4,#,5,6,#,7,#,#,8}<br>说明：返回根节点，系统会输出整颗二叉树对比结果，重建结果如题面图示<br><strong>示例2</strong><br>输入: <code>[1],[1]</code><br>返回值: {1}<br><strong>示例3</strong><br>输入: <code>[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</code><br>返回值: {1,2,5,3,4,6,7}</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 算法思想：</span></span><br><span class="line"><span class="comment"> 1. 先序遍历第一个位置肯定是根节点node</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 2. 中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 3. 先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 4. 把四个数组找出来，分左右递归调用即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 每次直接拷贝出对应的四个数组，然后递归调用</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span> || in.length == <span class="number">0</span> || pre.length != in.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[<span class="number">0</span>] == in[i]) &#123;</span><br><span class="line">                node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i+<span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+<span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 传递原数组、以及数组中对应的开始位置和长度，然后递归调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] in)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reConstructBinaryTree(pre, in, <span class="number">0</span>, <span class="number">0</span>, pre.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次都传递原数组的引用，不需要进行数组拷贝，但是要注意：</span></span><br><span class="line"><span class="comment">     *   先序和中序开始的位置是不一样的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre 原先序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 原中序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preBeginIndex 先序数组中开始的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inBeginIndex 中序数组中开始的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 本次要重建的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> preBeginIndex, <span class="type">int</span> inBeginIndex, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否越界，以及本次长度是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (preBeginIndex &lt; <span class="number">0</span> || preBeginIndex + length &gt; pre.length</span><br><span class="line">                || inBeginIndex &lt; <span class="number">0</span> || inBeginIndex + length &gt; pre.length || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先序遍历第一个位置肯定是根节点node</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preBeginIndex]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> preBeginIndex;</span><br><span class="line">        <span class="comment">// 左子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inBeginIndex; i &lt; inBeginIndex + length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[preBeginIndex] == in[i]) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                leftLength = i - inBeginIndex;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> length - leftLength - <span class="number">1</span>;</span><br><span class="line">        root.left = reConstructBinaryTree(pre, in, preBeginIndex + <span class="number">1</span>, inBeginIndex, leftLength);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, in, preBeginIndex + leftLength + <span class="number">1</span>, rootIndex + <span class="number">1</span>, rightLength);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ26-树的子结构"><a href="#JZ26-树的子结构" class="headerlink" title="JZ26 树的子结构"></a>JZ26 树的子结构</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 二叉树 树</p>
<p><strong>描述</strong></p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）<br>假如给定A为{8,8,7,9,2,#,#,#,#,4,7}，B为{8,9,2}，2个树的结构如下，可以看出B是A的子结构</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211027/557336_1635320187489/B1C70B05B2BA3AAA854EE032F2A8D826"></p>
<p>数据范围:<br>0 &lt;&#x3D; A的节点个数 &lt;&#x3D; 10000<br>0 &lt;&#x3D; B的节点个数 &lt;&#x3D; 10000</p>
<p><strong>示例1</strong><br>输入: {8,8,7,9,2,#,#,#,#,4,7},{8,9,2}<br>返回值: true<br><strong>示例2</strong><br>输入: {1,2,3,4,5},{2,4}<br>返回值: true<br><strong>示例3</strong><br>输入: {1,2,3},{3,1}<br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 双遍历 先遍历A，在每个节点都去去对比B是否是子树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历A</span></span><br><span class="line">        <span class="keyword">return</span> traverse(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(TreeNode root1,TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// A的该节点是空</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 和B对比</span></span><br><span class="line">        <span class="keyword">if</span> (compare(root1, root2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历A的左右子树</span></span><br><span class="line">            <span class="keyword">return</span> traverse(root1.left, root2) || traverse(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1.val != root2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> compare(root1.left, root2.left) &amp;&amp; compare(root1.right, root2.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ27-二叉树的镜像"><a href="#JZ27-二叉树的镜像" class="headerlink" title="JZ27 二叉树的镜像"></a>JZ27 二叉树的镜像</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: </p>
<p><strong>描述</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>数据范围：二叉树的节点数 0≤n≤1000 ， 二叉树每个节点的值 0≤val≤1000<br>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1) 的解法，时间复杂度 O(n)</p>
<p>比如：<br>源二叉树<br><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888"><br>镜像二叉树<br><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A"></p>
<p><strong>示例1</strong><br>输入: {8,6,10,5,7,9,11}<br>返回值: {8,10,6,11,9,7,5}<br>说明: 如题面所示<br><strong>示例2</strong><br>输入: {}<br>返回值: {}</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 先交换左右子节点，然后遍历子节点交换子节点的左右子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pRoot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = tmp;</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 见下图</span></span><br><span class="line"><span class="comment">// 算法流程：一层一层进栈并交换左右节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 构建辅助栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 根节点入栈</span></span><br><span class="line">        stack.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 节点出栈</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="comment">// 根节点的左右子树入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">            <span class="comment">// 左右子树交换</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2<br><img src="https://uploadfiles.nowcoder.com/images/20210625/889362376_1624613381635/984D3CF58361D4880F35C93DBDB46F37"></p>
<h4 id="JZ32-从上往下打印二叉树"><a href="#JZ32-从上往下打印二叉树" class="headerlink" title="JZ32 从上往下打印二叉树"></a>JZ32 从上往下打印二叉树</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 队列 树</p>
<p><strong>描述</strong></p>
<p>不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如输入{8,6,10,#,#,2,1}，如以下图中的示例二叉树，则依次打印8,6,10,2,1(空节点不打印，跳过)，请你将打印的结果存放到一个数组里面，返回。<br><img src="https://uploadfiles.nowcoder.com/images/20211029/557336_1635477973725/6C502E0240CAC668843969AFF396B5E4"></p>
<p>数据范围:<br>0&lt;&#x3D;节点总数&lt;&#x3D;1000<br>-1000&lt;&#x3D;节点值&lt;&#x3D;1000</p>
<p><strong>示例1</strong><br>输入: {8,6,10,#,#,2,1}<br>返回值: [8,6,10,2,1]<br><strong>示例2</strong><br>输入: {5,4,#,3,#,2,#,1}<br>返回值: [5,4,3,2,1]</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 层次遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回列表</span></span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 暂存当前层节点</span></span><br><span class="line">        List&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        layer.add(root);</span><br><span class="line">        <span class="keyword">while</span> (layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建当前层缓存</span></span><br><span class="line">            List&lt;TreeNode&gt; tmp = layer;</span><br><span class="line">            <span class="comment">// 新建下一层</span></span><br><span class="line">            layer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                    result.add(node.val);</span><br><span class="line">                    layer.add(node.left);</span><br><span class="line">                    layer.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ33-二叉搜索树的后序遍历序列"><a href="#JZ33-二叉搜索树的后序遍历序列" class="headerlink" title="JZ33 二叉搜索树的后序遍历序列"></a>JZ33 二叉搜索树的后序遍历序列</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 栈 树</p>
<p><strong>描述</strong></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同。</p>
<p>数据范围： 节点数量 0≤n≤1000 ，节点上的值满足 1≤val≤10<sup>5</sup>，保证节点上的值各不相同<br>要求：空间复杂度 O(n) ，时间时间复杂度 O(n^2)</p>
<p>提示：<br>1.二叉搜索树是指父亲节点大于左子树中的全部节点，但是小于右子树中的全部节点的树。<br>2.该题我们约定空树不是二叉搜索树<br>3.后序遍历是指按照 “左子树-右子树-根节点” 的顺序遍历<br>4.参考下面的二叉搜索树，示例 1</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211031/557336_1635645087543/44496AC711FE9478BABD9207180C3423"></p>
<p><strong>示例1</strong><br>输入: [1,3,2]<br>返回值: true<br>说明: 是上图的后序遍历 ，返回true<br><strong>示例2</strong><br>输入: [3,1,2]<br>返回值: false<br>说明: 不属于上图的后序遍历，从另外的二叉搜索树也不能后序遍历出该序列 ，因为最后的2一定是根节点，前面一定是孩子节点，可能是左孩子，右孩子，根节点，也可能是全左孩子，根节点，也可能是全右孩子，根节点，但是[3,1,2]的组合都不能满足这些情况，故返回false<br><strong>示例3</strong><br>输入: [5,7,6,9,11,10,8]<br>返回值: true</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 将一个序列划分为3段, 左子树+右子树+根，然后遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">VerifySquenceOfBST</span><span class="params">(<span class="type">int</span> [] sequence)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> sequence.length;</span><br><span class="line">        <span class="keyword">if</span> (sequence.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(<span class="type">int</span>[] sequence, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">// 子树只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子树根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> sequence[r];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 划分右子树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; sequence[j] &gt; root) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查左子树是否存在大于根节点的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= j; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &gt; root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> verify(sequence, l, j) &amp;&amp; verify(sequence, j + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ82-二叉树中和为某一值的路径-一"><a href="#JZ82-二叉树中和为某一值的路径-一" class="headerlink" title="JZ82 二叉树中和为某一值的路径(一)"></a>JZ82 二叉树中和为某一值的路径(一)</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树 dfs</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n</p>
<p>例如：<br>给出如下的二叉树，sum&#x3D;22，<br><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159"></p>
<p>返回true，因为存在一条路径 5→4→11→2 的节点值之和为 22</p>
<p>数据范围：<br>1.树上的节点数满足 0≤n≤10000<br>2.每 个节点的值都满足 ∣val∣≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>进阶：空间复杂度 O(树的高度)，时间复杂度 O(n)</p>
<p><strong>示例1</strong><br>输入: {5,4,8,1,11,#,9,#,#,2,7},22<br>返回值: true<br><strong>示例2</strong><br>输入: {1,2},0<br>返回值: false<br><strong>示例3</strong><br>输入: {1,2},3<br>返回值: true<br><strong>示例4</strong><br>输入: {},0<br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 递归 加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root, sum, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum, <span class="type">int</span> res)</span> &#123;</span><br><span class="line">        <span class="comment">// 左右子节点都为空才是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == sum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                left = hasPathSum(root.left, sum, res + root.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                right = hasPathSum(root.right, sum, res + root.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left || right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 递归 减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ34-二叉树中和为某一值的路径-二"><a href="#JZ34-二叉树中和为某一值的路径-二" class="headerlink" title="JZ34 二叉树中和为某一值的路径(二)"></a>JZ34 二叉树中和为某一值的路径(二)</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径。<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n</p>
<p>如二叉树root为 {10,5,12,4,7}, expectNumber为22<br><img src="https://uploadfiles.nowcoder.com/images/20210929/557336_1632915294911/0A4B8F161306A7054899D42C0C6937FD"><br>则合法路径有 <code>[[10,5,7],[10,12]]</code></p>
<p>数据范围:<br>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; 节点值 &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; expectNumber &lt;&#x3D; 1000</p>
<p><strong>示例1</strong><br>输入: <code>&#123;10,5,12,4,7&#125;,22</code><br>返回值: <code>[[10,5,7],[10,12]]</code><br>说明: 返回 <code>[[10,12],[10,5,7]]</code> 也是对的<br><strong>示例2</strong><br>输入: {10,5,12,4,7},15<br>返回值: []<br><strong>示例3</strong><br>输入: {2,3},0<br>返回值: []<br><strong>示例4</strong><br>输入: {1,3,4},7<br>返回值: []</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 深度优先搜索 加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> expectNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        findPath(root, expectNumber, root.val, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findPath</span><span class="params">(TreeNode root, <span class="type">int</span> expectNumber, <span class="type">int</span> sum,</span></span><br><span class="line"><span class="params">                          ArrayList&lt;Integer&gt; path, </span></span><br><span class="line"><span class="params">                          ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum == expectNumber) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.add(root.left.val);</span><br><span class="line">            findPath(root.left, expectNumber, sum + root.left.val, path, result);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.add(root.right.val);</span><br><span class="line">            findPath(root.right, expectNumber, sum + root.right.val, path, result);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 深度优先搜索 减法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> expectNumber)</span> &#123;</span><br><span class="line">        dfs(root, expectNumber);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理树为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 路径更新</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">// number更新</span></span><br><span class="line">        number -= root.val;</span><br><span class="line">        <span class="comment">// 如果递归当前节点为叶子节点且该条路径的值已经达到了expectNumber，则更新ret</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; number == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树递归</span></span><br><span class="line">        dfs(root.left, number);</span><br><span class="line">        dfs(root.right, number);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ36-二叉搜索树与双向链表"><a href="#JZ36-二叉搜索树与双向链表" class="headerlink" title="JZ36 二叉搜索树与双向链表"></a>JZ36 二叉搜索树与双向链表</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 分治</p>
<p><strong>描述</strong></p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2"></p>
<p>数据范围：输入二叉树的节点数 0≤n≤1000，二叉树中每个节点的值 0≤val≤1000<br>要求：空间复杂度 O(1)（即在原树上操作），时间复杂度 O(n)</p>
<p>注意:<br>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br>2.返回链表中的第一个节点的指针<br>3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构<br>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p>
<p>输入描述：<br>二叉树的根节点</p>
<p>返回值描述：<br>双向链表的其中一个头节点。</p>
<p><strong>示例1</strong><br>输入: {10,6,14,4,8,12,16}<br>返回值: From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;<br>说明: 输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。<br><strong>示例2</strong><br>输入: {5,4,#,3,#,2,#,1}<br>返回值: From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;<br>说明:<br>                        5<br>                      &#x2F;<br>                    4<br>                  &#x2F;<br>                3<br>              &#x2F;<br>            2<br>          &#x2F;<br>        1<br>    树的形状如上图</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 方法1: 递归中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//返回的第一个指针，即为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//中序遍历当前值的上一位，初值为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//中序递归，叶子为空则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先递归到最左最小值 </span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="comment">//找到最小值，初始化head与pre</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;      </span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2: 非递归中序遍历 （栈）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//设置栈用于遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//确认第一个遍历到最左，即为首位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFirst</span> <span class="operator">=</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">while</span> (pRootOfTree != <span class="literal">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//直到没有左节点</span></span><br><span class="line">            <span class="keyword">while</span> (pRootOfTree != <span class="literal">null</span>) &#123;  </span><br><span class="line">                s.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree.left;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = s.pop();</span><br><span class="line">            <span class="comment">//最左元素即表头</span></span><br><span class="line">            <span class="keyword">if</span> (isFirst) &#123;  </span><br><span class="line">                head = pRootOfTree;</span><br><span class="line">                pre = head;</span><br><span class="line">                isFirst = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                pre.right = pRootOfTree;</span><br><span class="line">                pRootOfTree.left = pre;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = pRootOfTree.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ79-判断是不是平衡二叉树"><a href="#JZ79-判断是不是平衡二叉树" class="headerlink" title="JZ79 判断是不是平衡二叉树"></a>JZ79 判断是不是平衡二叉树</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树 dfs</p>
<p><strong>描述</strong></p>
<p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。<br>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树<br>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>样例解释：<br><img src="https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6"></p>
<p>样例二叉树如图，为一颗平衡二叉树<br>注：我们约定空树是平衡二叉树。</p>
<p>数据范围：n≤100,树上节点的val值满足 0≤n≤1000<br>要求：空间复杂度O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入一棵二叉树的根节点</p>
<p>返回值描述：<br>输出一个布尔类型的值</p>
<p><strong>示例1</strong><br>输入: {1,2,3,4,5,6,7}<br>返回值: true<br><strong>示例2</strong><br>输入: {}<br>返回值: true</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1: 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.abs(treeDepth(root.left) - treeDepth(root.right)) &lt;= <span class="number">1</span> </span><br><span class="line">            &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> treeDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> treeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ8-二叉树的下一个结点"><a href="#JZ8-二叉树的下一个结点" class="headerlink" title="JZ8 二叉树的下一个结点"></a>JZ8 二叉树的下一个结点</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。</p>
<p>示例:<br>输入:{8,6,10,5,7,9,11},8<br>返回:9<br>解析:这个组装传入的子树根节点，其实就是整颗树，中序遍历{5,6,7,8,9,10,11}，根节点8的下一个节点就是9，应该返回{9,10,11}，后台只打印子树的下一个节点，所以只会打印9，如下图，其实都有指向左右孩子的指针，还有指向父节点的指针，下图没有画出来</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210616/557336_1623845692021/E647707AEF2A4AE2C40F0FCCB549B6A5"></p>
<p>数据范围：节点数满足 1≤n≤50  ，节点上的值满足 1≤val≤100 </p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n) </p>
<p><strong>示例1</strong><br>输入: {8,6,10,5,7,9,11},8<br>返回值: 9<br><strong>示例2</strong><br>输入: {8,6,10,5,7,9,11},6<br>返回值: 7<br><strong>示例3</strong><br>输入: {1,2,#,#,3,#,4},4<br>返回值: 1<br><strong>示例4</strong><br>输入: {5},5<br>返回值: “null”<br>说明: 不存在，后台打印”null”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 递归中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;TreeLinkNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取根节点</span></span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">root</span> <span class="operator">=</span> pNode;</span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="literal">null</span>) root = root.next;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 中序遍历打造nodes</span></span><br><span class="line">        InOrder(root);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 进行匹配</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nodes.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">TreeLinkNode</span> <span class="variable">cur</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">            <span class="keyword">if</span>(pNode == cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> nodes.get(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">InOrder</span><span class="params">(TreeLinkNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            InOrder(root.left);</span><br><span class="line">            nodes.add(root);</span><br><span class="line">            InOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ28-对称的二叉树"><a href="#JZ28-对称的二叉树" class="headerlink" title="JZ28 对称的二叉树"></a>JZ28 对称的二叉树</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：<br>下面这棵二叉树是对称的<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F"><br>下面这棵二叉树不对称<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372"></p>
<p>数据范围：节点数满足 0≤n≤1000，节点上的值满足 ∣val∣≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>备注：<br>你可以用递归和迭代两种方法解决这个问题</p>
<p><strong>示例1</strong><br>输入: {1,2,2,3,4,4,3}<br>返回值: true<br><strong>示例2</strong><br>输入: {8,6,9,5,7,7,5}<br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursion(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recursion</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 可以两个都为空</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个为空或者节点值不同，必定不对称</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>  || root2 == <span class="literal">null</span> || root1.val != root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每层对应的节点进入递归比较</span></span><br><span class="line">        <span class="keyword">return</span> recursion(root1.left, root2.right) &amp;&amp; recursion(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ78-把二叉树打印成多行"><a href="#JZ78-把二叉树打印成多行" class="headerlink" title="JZ78 把二叉树打印成多行"></a>JZ78 把二叉树打印成多行</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树 广度优先搜索(BFS)</p>
<p><strong>描述</strong></p>
<p>给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。<br>例如：<br>给定的二叉树是{1,2,3,#,#,4,5}<br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05"></p>
<p>该二叉树多行打印层序遍历的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1],</span><br><span class="line">[2,3],</span><br><span class="line">[4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>数据范围：二叉树的节点数 0≤n≤1000，0≤val≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>输入描述：<br>给定一个二叉树的根节点</p>
<p><strong>示例1</strong><br>输入: <code>&#123;1,2,3,#,#,4,5&#125;</code><br>返回值: <code>[[1],[2,3],[4,5]]</code><br><strong>示例2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>[[8],[6,10],[5,7,9,11]]</code><br><strong>示例3</strong><br>输入: <code>&#123;1,2,3,4,5&#125;</code><br>返回值: <code>[[1],[2,3],[4,5]]</code><br><strong>示例4</strong><br>输入: <code>&#123;&#125;</code><br>返回值: <code>[]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法: 用ArrayList做缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        layer.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : layer) &#123;</span><br><span class="line">                values.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    tmp.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    tmp.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(values);</span><br><span class="line">            layer = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ37-序列化二叉树"><a href="#JZ37-序列化二叉树" class="headerlink" title="JZ37 序列化二叉树"></a>JZ37 序列化二叉树</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 队列 树</p>
<p><strong>描述</strong></p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p>
<p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p>
<p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>例如，可以根据层序遍历的方案序列化，如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E"></p>
<p>层序序列化(即用函数Serialize转化)如上的二叉树转为”{1,2,3,#,#,6,7}”，再能够调用反序列化(Deserialize)将”{1,2,3,#,#,6,7}”构造成如上的二叉树。</p>
<p>当然你也可以根据满二叉树结点位置的标号规律来序列化，还可以根据先序遍历和中序遍历的结果来序列化。不对序列化之后的字符串进行约束，所以欢迎各种奇思妙想。</p>
<p>数据范围：节点数 n≤100，树上每个节点的值满足 0≤val≤150<br>要求：序列化和反序列化都是空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)</p>
<p><strong>示例1</strong><br>输入: {1,2,3,#,#,6,7}<br>返回值: {1,2,3,#,#,6,7}<br>说明: 如题面图<br><strong>示例2</strong><br>输入: {8,6,10,5,7,9,11}<br>返回值: {8,6,10,5,7,9,11}</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: 前序遍历</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//序列的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//处理序列化的功能函数（递归）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">SerializeFunction</span><span class="params">(TreeNode root, StringBuilder str)</span>&#123;</span><br><span class="line">        <span class="comment">//如果节点为空，表示左子节点或右子节点为空，用#表示</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            str.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        str.append(root.val).append(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        SerializeFunction(root.left, str); </span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        SerializeFunction(root.right, str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//处理空树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        SerializeFunction(root, res);</span><br><span class="line">        <span class="comment">//把str转换成char</span></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理反序列化的功能函数（递归）</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">DeserializeFunction</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//到达叶节点时，构建完毕，返回继续构建父节点</span></span><br><span class="line">        <span class="comment">//空节点</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(index) == <span class="string">&#x27;#&#x27;</span>)&#123; </span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数字转换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遇到分隔符或者结尾</span></span><br><span class="line">        <span class="keyword">while</span>(str.charAt(index) != <span class="string">&#x27;!&#x27;</span> &amp;&amp; index != str.length())&#123; </span><br><span class="line">            val = val * <span class="number">10</span> + ((str.charAt(index)) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="comment">//序列到底了，构建完成</span></span><br><span class="line">        <span class="keyword">if</span>(index == str.length()) </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index++;</span><br><span class="line">        <span class="comment">//反序列化与序列化一致，都是前序</span></span><br><span class="line">        root.left = DeserializeFunction(str);  </span><br><span class="line">        root.right = DeserializeFunction(str);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Deserialize</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//空序列对应空树</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;#&quot;</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> DeserializeFunction(str);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ84-二叉树中和为某一值的路径-三"><a href="#JZ84-二叉树中和为某一值的路径-三" class="headerlink" title="JZ84 二叉树中和为某一值的路径(三)"></a>JZ84 二叉树中和为某一值的路径(三)</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。<br>1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点<br>2.总节点数目为n<br>3.保证最后返回的路径个数在整形范围内(即路径个数小于2<sup>31</sup>-1)</p>
<p>数据范围:<br>0&lt;&#x3D;n&lt;&#x3D;1000<br>-10^9&lt;&#x3D;节点值&lt;&#x3D;10^9</p>
<p>假如二叉树root为{1,2,3,4,5,4,3,#,#,-1}，sum&#x3D;6，那么总共如下所示，有3条路径符合要求</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211103/301499_1635923010369/C47185D4980F108BC73F790D8D2F6709"></p>
<p><strong>示例1</strong><br>输入: {1,2,3,4,5,4,3,#,#,-1},6<br>返回值: 3<br>说明: 如图所示，有3条路径符合<br><strong>示例2</strong><br>输入: {0,1},1<br>返回值: 2<br><strong>示例3</strong><br>输入: {1,#,2,#,3},3<br>返回值: 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: dfs算法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以每个节点作为根查询路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FindPath</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 为空则返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询以某节点为根的路径数</span></span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="comment">// 以其子节点为新根</span></span><br><span class="line">        FindPath(root.left, sum);</span><br><span class="line">        FindPath(root.right, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs查询以某节点为根的路径数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 符合目标值</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点值可以为负数，所以进入子节点继续寻找</span></span><br><span class="line">        dfs(root.left, sum - root.val);</span><br><span class="line">        dfs(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ86-在二叉树中找到两个节点的最近公共祖先"><a href="#JZ86-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="JZ86 在二叉树中找到两个节点的最近公共祖先"></a>JZ86 在二叉树中找到两个节点的最近公共祖先</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。</p>
<p>数据范围：树上节点数满足 1≤n≤10^5, 节点值val满足区间 [0,n)<br>要求：时间复杂度 O(n)</p>
<p>注：本题保证二叉树中每个节点的val值均不相同。</p>
<p>如当输入{3,5,1,6,2,0,8,#,#,7,4},5,1时，二叉树{3,5,1,6,2,0,8,#,#,7,4}如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22"></p>
<p>所以节点值为5和节点值为1的节点的最近公共祖先节点的节点值为3，所以对应的输出为3。<br>节点本身可以视为自己的祖先</p>
<p><strong>示例1</strong><br>输入: {3,5,1,6,2,0,8,#,#,7,4},5,1<br>返回值: 3<br><strong>示例2</strong><br>输入: {3,5,1,6,2,0,8,#,#,7,4},2,7<br>返回值: 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法: dfs遍历回溯找到两个目标值的路径，再进行路径对比</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录是否找到o的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;Integer&gt; path1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 求根节点到o1的路径</span></span><br><span class="line">        dfs(root, path1, o1);</span><br><span class="line">        <span class="comment">// 重置flag</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 求根节点到o2的路径</span></span><br><span class="line">        dfs(root, path2, o2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 比较路径，找到最后一个相同点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path1.size() &amp;&amp; i &lt; path2.size(); i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path1.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> path2.get(i);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                res = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; path, <span class="type">int</span> o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag || root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">// 节点的值都不同，可以直接用值比较</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == o) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs遍历查找</span></span><br><span class="line">        dfs(root.left, path, o);</span><br><span class="line">        dfs(root.right, path, o);</span><br><span class="line">        <span class="comment">// 找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ68-二叉搜索树的最近公共祖先"><a href="#JZ68-二叉搜索树的最近公共祖先" class="headerlink" title="JZ68 二叉搜索树的最近公共祖先"></a>JZ68 二叉搜索树的最近公共祖先</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 树 递归</p>
<p><strong>描述</strong></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<ol>
<li>对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</li>
<li>二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</li>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ol>
<p>数据范围:<br>3&lt;&#x3D;节点总数&lt;&#x3D;10000<br>0&lt;&#x3D;节点值&lt;&#x3D;10000</p>
<p>如果给定以下搜索二叉树: {7,1,12,0,4,11,14,#,#,3,5}，如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A"></p>
<p><strong>示例1</strong><br>输入: {7,1,12,0,4,11,14,#,#,3,5},1,12<br>返回值: 7<br>说明: 节点1 和 节点12的最近公共祖先是7<br><strong>示例2</strong><br>输入: {7,1,12,0,4,11,14,#,#,3,5},12,11<br>返回值: 12<br>说明: 因为一个节点也可以是它自己的祖先.所以输出12</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 利用二叉搜索树的性质向下查找即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; cur.val &amp;&amp; q &lt; cur.val) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; cur.val &amp;&amp; q &gt; cur.val) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列-amp-栈"><a href="#队列-amp-栈" class="headerlink" title="队列 &amp; 栈"></a>队列 &amp; 栈</h3><h4 id="JZ9-用两个栈实现队列"><a href="#JZ9-用两个栈实现队列" class="headerlink" title="JZ9 用两个栈实现队列"></a>JZ9 用两个栈实现队列</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
<p>数据范围： n≤1000<br>要求：存储n个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)</p>
<p><strong>示例1</strong></p>
<p>输入: <code>[&quot;PSH1&quot;,&quot;PSH2&quot;,&quot;POP&quot;,&quot;POP&quot;]</code><br>返回值: 1,2<br>说明:<br>“PSH1”:代表将1插入队列尾部<br>“PSH2”:代表将2插入队列尾部<br>“POP”:代表删除一个元素，先进先出&#x3D;&gt;返回1<br>“POP”:代表删除一个元素，先进先出&#x3D;&gt;返回2</p>
<p><strong>示例2</strong><br>输入: <code>[&quot;PSH2&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;POP&quot;]</code><br>返回值: 2,1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ30-包含min函数的栈"><a href="#JZ30-包含min函数的栈" class="headerlink" title="JZ30 包含min函数的栈"></a>JZ30 包含min函数的栈</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p>
<p>此栈包含的方法有：<br>push(value):将value压入栈中<br>pop():弹出栈顶元素<br>top():获取栈顶元素<br>min():获取栈中最小元素</p>
<p>数据范围：操作数量满足 0≤n≤300，输入的元素满足 ∣val∣≤10000<br>进阶：栈的各个操作的时间复杂度是 O(1)，空间复杂度是 O(n)</p>
<p>示例:<br>输入: [“PSH-1”,”PSH2”,”MIN”,”TOP”,”POP”,”PSH1”,”TOP”,”MIN”]<br>输出: -1,2,1,-1<br>解析:<br>“PSH-1”表示将-1压入栈中，栈中元素为-1<br>“PSH2”表示将2压入栈中，栈中元素为2，-1<br>“MIN”表示获取此时栈中最小元素&#x3D;&#x3D;&gt;返回-1<br>“TOP”表示获取栈顶元素&#x3D;&#x3D;&gt;返回2<br>“POP”表示弹出栈顶元素，弹出2，栈中元素为-1<br>“PSH1”表示将1压入栈中，栈中元素为1，-1<br>“TOP”表示获取栈顶元素&#x3D;&#x3D;&gt;返回1<br>“MIN”表示获取此时栈中最小元素&#x3D;&#x3D;&gt;返回-1</p>
<p><strong>示例1</strong><br>输入:  [“PSH-1”,”PSH2”,”MIN”,”TOP”,”POP”,”PSH1”,”TOP”,”MIN”]<br>返回值: -1,2,1,-1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">// 解法: 维护一个非严格对应的降序最小栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用于栈的push 与 pop</span></span><br><span class="line">    Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 用于存储最小min</span></span><br><span class="line">    Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        s1.push(node);</span><br><span class="line">        <span class="comment">// 空或者新元素小于等于最小值，则入栈</span></span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty() || node &lt;= s2.peek()) &#123;</span><br><span class="line">            s2.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> s1.pop();</span><br><span class="line">        <span class="keyword">if</span> (s2.peek() == v) &#123;</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ31-栈的压入、弹出序列"><a href="#JZ31-栈的压入、弹出序列" class="headerlink" title="JZ31 栈的压入、弹出序列"></a>JZ31 栈的压入、弹出序列</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<ol>
<li>0 &lt;&#x3D; pushV.length &#x3D;&#x3D; popV.length &lt;&#x3D;1000</li>
<li>-1000 &lt;&#x3D; pushV[i] &lt;&#x3D; 1000</li>
<li>pushV 的所有数字均不相同</li>
</ol>
<p><strong>示例1</strong><br>输入: [1,2,3,4,5],[4,5,3,2,1]<br>返回值: true<br>说明: 可以通过<br>    push(1)&#x3D;&gt;push(2)&#x3D;&gt;push(3)&#x3D;&gt;push(4)&#x3D;&gt;pop()&#x3D;&gt;push(5)&#x3D;&gt;pop()&#x3D;&gt;pop()&#x3D;&gt;pop()&#x3D;&gt;pop()<br>    这样的顺序得到[4,5,3,2,1]这个序列，返回true<br><strong>示例2</strong><br>输入: [1,2,3,4,5],[4,3,5,1,2]<br>返回值: false<br>说明: 由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前弹出，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false </p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 辅助栈模拟出入栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsPopOrder</span><span class="params">(<span class="type">int</span> [] pushA,<span class="type">int</span> [] popA)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pushA.length;</span><br><span class="line">        <span class="comment">// 辅助栈</span></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历入栈的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历出栈的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="comment">// 入栈：栈为空或者栈顶不等于出栈数组</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; (s.isEmpty() || s.peek() != popA[i])) &#123;</span><br><span class="line">                s.push(pushA[j]);</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈顶等于出栈数组</span></span><br><span class="line">            <span class="keyword">if</span> (s.peek() == popA[i]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ73-翻转单词序列"><a href="#JZ73-翻转单词序列" class="headerlink" title="JZ73 翻转单词序列"></a>JZ73 翻转单词序列</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 字符串 双指针</p>
<p><strong>描述</strong></p>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>数据范围：1≤n≤100<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)，保证没有只包含空格的字符串</p>
<p><strong>示例1</strong><br>输入: “nowcoder. a am I”<br>返回值: “I am a nowcoder.”<br><strong>示例2</strong><br>输入: “”<br>返回值: “”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ReverseSentence</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span>[] cs = str.toCharArray();</span><br><span class="line">        <span class="comment">// 翻转句子</span></span><br><span class="line">        reverse(cs, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 以空格为界找到一个单词</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; cs[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; cs[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将单词翻转</span></span><br><span class="line">            reverse(cs, i, j - <span class="number">1</span>);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            swap(cs, l ++, r --);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> cs[l];</span><br><span class="line">        cs[l] = cs[r];</span><br><span class="line">        cs[r] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ59-滑动窗口的最大值"><a href="#JZ59-滑动窗口的最大值" class="headerlink" title="JZ59 滑动窗口的最大值"></a>JZ59 滑动窗口的最大值</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 堆 双指针 队列</p>
<p><strong>描述</strong></p>
<p>给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组<code>&#123;2,3,4,2,6,2,5,1&#125;</code>及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为<code>&#123;4,4,6,6,6,5&#125;</code>；针对数组<code>&#123;2,3,4,2,6,2,5,1&#125;</code>的滑动窗口有以下6个：<code>&#123;[2,3,4],2,6,2,5,1&#125;</code>, <code>&#123;2,[3,4,2],6,2,5,1&#125;</code>, <code>&#123;2,3,[4,2,6],2,5,1&#125;</code>, <code>&#123;2,3,4,[2,6,2],5,1&#125;</code>, <code>&#123;2,3,4,2,[6,2,5],1&#125;</code>, <code>&#123;2,3,4,2,6,[2,5,1]&#125;</code>。</p>
<p>数据范围：1≤size≤n≤10000，数组中每个元素的值满足∣val∣≤10000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例1</strong><br>输入: [2,3,4,2,6,2,5,1],3<br>返回值: [4,4,6,6,6,5]<br><strong>示例2</strong><br>输入: [9,10,9,-7,-3,8,2,-6],5<br>返回值: [10,10,9,8]<br><strong>示例3</strong><br>输入: [1,2,3,4],3<br>返回值: [3,4]</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 依次移动窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= num.length - size; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxIndex) &#123;</span><br><span class="line">                maxIndex = findMax(num, i, r);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[r] &gt;= num[maxIndex]) &#123;</span><br><span class="line">                maxIndex = r;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(num[maxIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt;= r; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt;= num[minIndex]) &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用双向队列记递减序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里本不需要这个判断，但是提供的用例和题目中的条件不符</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || size &gt; num.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双向队列</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 遍历第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            addMaxDeque(num, dq, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历后续元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= num.length - size; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; i &gt; dq.peekFirst()) &#123;</span><br><span class="line">                dq.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            addMaxDeque(num, dq, r);</span><br><span class="line">            res.add(num[dq.peekFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addMaxDeque</span><span class="params">(<span class="type">int</span>[] num, ArrayDeque&lt;Integer&gt; dq, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; num[dq.peekLast()] &lt;= num[i]) &#123;</span><br><span class="line">            dq.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><h4 id="JZ53-数字在升序数组中出现的次数"><a href="#JZ53-数字在升序数组中出现的次数" class="headerlink" title="JZ53 数字在升序数组中出现的次数"></a>JZ53 数字在升序数组中出现的次数</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 数组 二分</p>
<p><strong>描述</strong></p>
<p>给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数</p>
<p>数据范围：0≤n≤1000,0≤k≤100，数组中每个元素的值满足 0≤val≤100<br>要求：空间复杂度 O(1)，时间复杂度 O(logn)</p>
<p><strong>示例1</strong><br>输入: [1,2,3,3,3,3,4,5],3<br>返回值: 4<br><strong>示例2</strong><br>输入: [1,3,4,5],6<br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1: 二分法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetNumberOfK</span><span class="params">(<span class="type">int</span> [] array , <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(array, k, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt; array.length &amp;&amp; array[i] == array[index]; i ++) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; array[i] == array[index]; i --) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIndex(array, k, l, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIndex(array, k, mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 二分法查找目标值加减0.5的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bisearch</span><span class="params">(<span class="type">int</span>[] data, <span class="type">double</span> k)</span>&#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> data.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分左右界</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &lt; k)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &gt; k)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetNumberOfK</span><span class="params">(<span class="type">int</span> [] array , <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//分别查找k+0.5和k-0.5应该出现的位置，中间的部分就全是k</span></span><br><span class="line">        <span class="keyword">return</span> bisearch(array, k + <span class="number">0.5</span>) - bisearch(array, k - <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ4-二维数组中的查找"><a href="#JZ4-二维数组中的查找" class="headerlink" title="JZ4 二维数组中的查找"></a>JZ4 二维数组中的查找</h4><p>时间限制: 1秒 空间限制: 64M<br>本题知识点: 数组<br>题目描述<br>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1,2,8,9],</span><br><span class="line">[2,4,9,12],</span><br><span class="line">[4,7,10,13],</span><br><span class="line">[6,8,11,15]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target &#x3D; 7，返回 true。<br>给定 target &#x3D; 3，返回 false。</p>
<p>数据范围：矩阵的长宽满足 0≤n,m≤500 ， 矩阵中的值满足0≤val≤10<sup>9</sup><br>进阶：空间复杂度O(1)，时间复杂度O(n+m)</p>
<p><strong>示例1</strong><br>输入: <code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code><br>返回值: true<br>说明：存在7，返回true<br><strong>示例2</strong><br>输入: <code>1,[[2]]</code><br>返回值: false<br><strong>示例3</strong><br>输入：<code>3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code><br>返回值：false<br>说明：不存在3，返回false   </p>
<p>答案: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> [][] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> rows - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[row][col] &gt; target) &#123;</span><br><span class="line">                row --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[row][col] &lt; target) &#123;</span><br><span class="line">                col ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ11-旋转数组的最小数字"><a href="#JZ11-旋转数组的最小数字" class="headerlink" title="JZ11 旋转数组的最小数字"></a>JZ11 旋转数组的最小数字</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 二分</p>
<p><strong>描述</strong></p>
<p>有一个长度为 n 的非降序数组，比如<code>[1,2,3,4,5]</code>，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了<code>[3,4,5,1,2]</code>，或者<code>[4,5,1,2,3]</code>这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000<br>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p>
<p><strong>示例1</strong><br>输入: <code>[3,4,5,1,2]</code><br>返回值: 1<br><strong>示例2</strong><br>输入: <code>[3,100,200,3]</code><br>返回值: 3</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1，arr[mid] &gt; target：4 5 6 1 2 3</span></span><br><span class="line"><span class="comment">// arr[mid] 为 6， target为右端点 3， arr[mid] &gt; target, 说明[first ... mid] 都是 &gt;= target 的，因为原始数组是非递减，所以可以确定答案为 [mid+1...last]区间,所以 first = mid + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2，arr[mid] &lt; target:5 6 1 2 3 4</span></span><br><span class="line"><span class="comment">// arr[mid] 为 1， target为右端点 4， arr[mid] &lt; target, 说明答案肯定不在[mid+1...last]，但是arr[mid] 有可能是答案,所以答案在[first, mid]区间，所以last = mid;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况3，arr[mid] == target:</span></span><br><span class="line"><span class="comment">// 如果是 1 0 1 1 1， arr[mid] = target = 1, 显然答案在左边</span></span><br><span class="line"><span class="comment">// 如果是 1 1 1 0 1, arr[mid] = target = 1, 显然答案在右边</span></span><br><span class="line"><span class="comment">// 所以这种情况，不能确定答案在左边还是右边，那么就让last = last - 1;慢慢缩少区间，同时也不会错过答案。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution2(array);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(array).min().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">            <span class="comment">// 提前退出</span></span><br><span class="line">            <span class="keyword">if</span> (array[first] &lt; array[last]) &#123; </span><br><span class="line">                <span class="keyword">return</span> array[first];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (last - first) / <span class="number">2</span> + first;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; array[last]) &#123;</span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; array[last]) &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ38-字符串的排列"><a href="#JZ38-字符串的排列" class="headerlink" title="JZ38 字符串的排列"></a>JZ38 字符串的排列</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 字符串 递归</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。<br>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB"></p>
<p>数据范围：n &lt; 10<br>要求：空间复杂度 O(n!)，时间复杂度 O(n!)<br>输入描述：<br>输入一个字符串,长度不超过10,字符只包括大小写字母。</p>
<p><strong>示例1</strong><br>输入: “ab”<br>返回值: [“ab”,”ba”]<br>说明: 返回[“ba”,”ab”]也是正确的<br><strong>示例2</strong><br>输入: “aab”<br>返回值: [“aab”,”aba”,”baa”]<br><strong>示例3</strong><br>输入: “abc”<br>返回值: [“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]<br><strong>示例4</strong><br>输入: “”<br>返回值: []</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">Permutation</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 转换数组</span></span><br><span class="line">       <span class="type">char</span>[] charStr = str.toCharArray();</span><br><span class="line">       <span class="comment">// 按字典序排序</span></span><br><span class="line">       Arrays.sort(charStr);</span><br><span class="line">       <span class="comment">// 标记每个位置的字符是否被使用过</span></span><br><span class="line">       <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[str.length()];</span><br><span class="line">       Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="comment">// 递归获取</span></span><br><span class="line">       recursion(res, charStr, tmp, vis);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(ArrayList&lt;String&gt; res, <span class="type">char</span>[] str, StringBuilder tmp, <span class="type">boolean</span>[] vis)</span> &#123;</span><br><span class="line">        <span class="comment">// 临时字符串满了加入输出</span></span><br><span class="line">        <span class="keyword">if</span> (tmp.length() == str.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">String</span>(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历所有元素选取一个加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i ++) &#123;</span><br><span class="line">            <span class="comment">// 如果该元素已经被加入了，则不需要再加入了</span></span><br><span class="line">            <span class="keyword">if</span>  (vis[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了</span></span><br><span class="line">            <span class="keyword">if</span>  (i &gt; <span class="number">0</span> &amp;&amp; str[i - <span class="number">1</span>] == str[i] &amp;&amp; vis[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记为使用过</span></span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 加入临时字符串</span></span><br><span class="line">            tmp.append(str[i]);</span><br><span class="line">            recursion(res, str, tmp, vis);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            tmp.deleteCharAt(tmp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ44-数字序列中某一位的数字"><a href="#JZ44-数字序列中某一位的数字" class="headerlink" title="JZ44 数字序列中某一位的数字"></a>JZ44 数字序列中某一位的数字</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 模拟</p>
<p><strong>描述</strong></p>
<p>数字以 0123456789101112131415… 的格式作为一个字符序列，在这个序列中第 2 位（从下标 0 开始计算）是 2 ，第 10 位是 1 ，第 13 位是 1 ，以此类题，请你输出第 n 位对应的数字。</p>
<p>数据范围：0&lt;&#x3D;n&lt;&#x3D;10^9</p>
<p><strong>示例1</strong><br>输入: 0<br>返回值: 0<br><strong>示例2</strong><br>输入: 2<br>返回值: 2<br><strong>示例3</strong><br>输入: 10<br>返回值: 1<br><strong>示例4</strong><br>输入: 13<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 位数减法</span></span><br><span class="line"><span class="comment">// 找规律:</span></span><br><span class="line"><span class="comment">// 小于10的数字一位数，1～9，共9个数字，9位；</span></span><br><span class="line"><span class="comment">// 小于100的数字两位数，10～99，共90个数字，180位；</span></span><br><span class="line"><span class="comment">// 小于1000的数字三位数，100～999，共900个数字，2700位；</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 记录n是几位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录当前位数区间的起始数字: 1,10,100...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录当前区间之前总共有多少位数字</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="comment">// 将n定位在某个位数的区间中</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; sum) &#123;</span><br><span class="line">            n -= sum;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digit ++;</span><br><span class="line">            sum = <span class="number">9</span> * start * digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位n在哪个数字上</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + (start + (n - <span class="number">1</span>) / digit);</span><br><span class="line">        <span class="comment">// 定位n在数字的哪一位上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) % digit;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(num.charAt(index)) - (<span class="type">int</span>)(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="JZ42-连续子数组的最大和"><a href="#JZ42-连续子数组的最大和" class="headerlink" title="JZ42 连续子数组的最大和"></a>JZ42 连续子数组的最大和</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 动态规划 贪心</p>
<p><strong>描述</strong></p>
<p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。<br>数据范围:<br>1 &lt;&#x3D; n &lt;&#x3D; 2 * 10^5</p>
<p>-100 &lt;&#x3D; a[i] &lt;&#x3D; 100</p>
<p>要求:时间复杂度为 O(n)，空间复杂度为 O(n)<br>进阶:时间复杂度为 O(n)，空间复杂度为 O(1)</p>
<p><strong>示例1</strong><br>输入: [1,-2,3,10,-4,7,2,-5]<br>返回值: 18<br>说明: 经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18<br><strong>示例2</strong><br>输入: [2]<br>返回值: 2<br><strong>示例3</strong><br>输入: [-10]<br>返回值: -10</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: 动态规划，列出状态转移方程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FindGreatestSumOfSubArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> lastMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">            lastMax = Math.max(lastMax + array[i], array[i]);</span><br><span class="line">            <span class="keyword">if</span> (lastMax &gt; max) &#123;</span><br><span class="line">                max = lastMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ85-连续子数组的最大和-二"><a href="#JZ85-连续子数组的最大和-二" class="headerlink" title="JZ85 连续子数组的最大和(二)"></a>JZ85 连续子数组的最大和(二)</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 贪心 动态规划 数组 双指针</p>
<p><strong>描述</strong></p>
<p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。</p>
<ol>
<li>子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</li>
<li>如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个</li>
<li>该题定义的子数组的最小长度为1，不存在为空的子数组，即不存在[]是某个数组的子数组</li>
<li>返回的数组不计入空间复杂度计算</li>
</ol>
<p>数据范围:<br>1&lt;&#x3D;n&lt;&#x3D;10^5</p>
<p>-100 &lt;&#x3D; a[i] &lt;&#x3D; 100</p>
<p>要求:时间复杂度O(n)，空间复杂度O(n)<br>进阶:时间复杂度O(n)，空间复杂度O(1)</p>
<p><strong>示例1</strong><br>输入: [1,-2,3,10,-4,7,2,-5]<br>返回值: [3,10,-4,7,2]<br>说明: 经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18，故返回[3,10,-4,7,2]<br><strong>示例2</strong><br>输入: [1]<br>返回值: [1]<br><strong>示例3</strong><br>输入: [1,2,-3,4,-1,1,-3,2]<br>返回值: [1,2,-3,4,-1,1]<br>说明: 经分析可知，最大子数组的和为4，有[4],[4,-1,1],[1,2,-3,4],[1,2,-3,4,-1,1]，故返回其中长度最长的[1,2,-3,4,-1,1]<br><strong>示例4</strong><br>输入: [-2,-1]<br>返回值: [-1]<br>说明: 子数组最小长度为1，故返回[-1]</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划，列出状态转移方程，记录对应状态即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] FindGreatestSumOfSubArray (<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> lastMax;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastStartIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> array[i];</span><br><span class="line">            <span class="comment">// 求最长子串，所以这里是&gt;=</span></span><br><span class="line">            <span class="keyword">if</span> (lastMax + num &gt;= num) &#123;</span><br><span class="line">                lastMax += num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastMax = num;</span><br><span class="line">                lastStartIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求最长子串，所以这里是&gt;=</span></span><br><span class="line">            <span class="keyword">if</span> (lastMax &gt;= max) &#123;</span><br><span class="line">                max = lastMax;</span><br><span class="line">                startIndex = lastStartIndex;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(array, startIndex, maxIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ69-跳台阶"><a href="#JZ69-跳台阶" class="headerlink" title="JZ69 跳台阶"></a>JZ69 跳台阶</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 递归 动态规划 记忆化搜索</p>
<p><strong>描述</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>数据范围：1≤n≤40<br>要求：时间复杂度：O(n)，空间复杂度：O(1)</p>
<p><strong>示例1</strong><br>输入: 2<br>返回值: 2<br>说明: 青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为2<br><strong>示例2</strong><br>输入: 7<br>返回值: 21</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= target; i ++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ10-斐波那契数列"><a href="#JZ10-斐波那契数列" class="headerlink" title="JZ10 斐波那契数列"></a>JZ10 斐波那契数列</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 数组 动态规划 记忆化搜索 快速幂 递归</p>
<p><strong>描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。<br>要求：空间复杂度 O(1)，时间复杂度 O(n) ，本题也有时间复杂度 O(logn) 的解法</p>
<p><strong>示例1</strong><br>输入: 4<br>返回值: 3<br><strong>示例2</strong><br>输入: 1<br>返回值: 1<br><strong>示例3</strong><br>输入: 2<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution1(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans[i] = ans[i-<span class="number">1</span>] + ans[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solution2(n - <span class="number">2</span>) + solution2(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ19-正则表达式匹配"><a href="#JZ19-正则表达式匹配" class="headerlink" title="JZ19 正则表达式匹配"></a>JZ19 正则表达式匹配</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 字符串 动态规划 递归</p>
<p><strong>描述</strong></p>
<p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。<br>1.模式中的字符’.’表示任意一个字符<br>2.模式中的字符’</em>‘表示它前面的字符可以出现任意次（包含0次）。<br>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>数据范围:<br>1.str 只包含从 a-z 的小写字母。<br>2.pattern 只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。<br>3. 0≤str.length≤26<br>4. 0≤pattern.length≤26</p>
<p><strong>示例1</strong><br>输入: “aaa”,”a<em>a”<br>返回值: true<br>说明: 中间的</em>可以出现任意次的a，所以可以出现1次a，能匹配上<br><strong>示例2</strong><br>输入: “aad”,”c<em>a</em>d”<br>返回值: true<br>说明: 因为这里 c 为 0 个，a被重复一次， * 表示零个或多个a。因此可以匹配字符串 “aad”。<br><strong>示例3</strong><br>输入: “a”,”.<em>“<br>返回值: true<br>说明: “.</em>“ 表示可匹配零个或多个（’<em>‘）任意字符（’.’）<br><strong>示例4</strong><br>输入: “aaab”,”a</em>a<em>a</em>c”<br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="comment">// 解法1: java中的正则匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span> <span class="params">(String str, String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> Pattern.matches(pattern, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解法2: 动态规划</span></span><br><span class="line"><span class="comment">// 具体做法：</span></span><br><span class="line"><span class="comment">// step 1：设dp[i][j]表示str前i个字符和pattern前j个字符是否匹配。（需要注意这里的i，j是长度，比对应的字符串下标要多1）</span></span><br><span class="line"><span class="comment">// step 2： （初始条件） 首先，毋庸置疑，两个空串是直接匹配，因此dp[0][0]=truedp[0][0]=truedp[0][0]=true。然后我们假设str字符串为空，那么pattern要怎么才能匹配空串呢？答案是利用&#x27;*&#x27;字符出现0次的特性。遍历pattern字符串，如果遇到&#x27;*&#x27;意味着它前面的字符可以出现0次，要想匹配空串也只能出现0，那就相当于考虑再前一个字符是否能匹配，因此dp[0][i]=dp[0][i−2]dp[0][i] = dp[0][i - 2]dp[0][i]=dp[0][i−2]。</span></span><br><span class="line"><span class="comment">// step 3： （状态转移） 然后分别遍历str与pattern的每个长度，开始寻找状态转移。首先考虑字符不为&#x27;*&#x27;的简单情况，只要遍历到的两个字符相等，或是pattern串中为&#x27;.&#x27;即可匹配，因此最后一位匹配，即查看二者各自前一位是否能完成匹配，即dp[i][j]=dp[i−1][j−1]dp[i][j] = dp[i - 1][j - 1]dp[i][j]=dp[i−1][j−1]。然后考虑&#x27;*&#x27;出现的情况：</span></span><br><span class="line"><span class="comment">// 1. pattern[j - 2] == &#x27;.&#x27; || pattern[j - 2] == str[i - 1]：即pattern前一位能够多匹配一位，可以用&#x27;*&#x27;让它多出现一次或是不出现，因此有转移方程: dp[i][j] = dp[i - 1][j] || dp[i][j - 2]</span></span><br><span class="line"><span class="comment">// 2. 不满足上述条件，只能不匹配，让前一个字符出现0次，dp[i][j] = dp[i][j - 2].</span></span><br><span class="line"><span class="comment">// 原答案: https://blog.nowcoder.net/n/a3d770a390da4683aa6e6a9020d59945</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span> <span class="params">(String str, String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">        <span class="comment">// dp[i][j]表示str前i个字符和pattern前j个字符是否匹配</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 遍历str每个长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n1; i ++) &#123;</span><br><span class="line">            <span class="comment">// 遍历pattern每个长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n2; j ++) &#123;</span><br><span class="line">                <span class="comment">// 空正则的情况</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = i == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 非空的情况下 星号、点号、字符</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当前字符不为*，用.去匹配或者字符直接相同</span></span><br><span class="line">                    <span class="keyword">if</span> (pattern.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (str.charAt(i - <span class="number">1</span>) == pattern.charAt(j - <span class="number">1</span>) || pattern.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 当前字符是*</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若是前一位为.或者前一位可以与这个数字匹配</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (str.charAt(i - <span class="number">1</span>) == pattern.charAt(j - <span class="number">2</span>) || pattern.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ71-跳台阶扩展问题"><a href="#JZ71-跳台阶扩展问题" class="headerlink" title="JZ71 跳台阶扩展问题"></a>JZ71 跳台阶扩展问题</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 动态规划 递归 记忆化搜索</p>
<p><strong>描述</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。</p>
<p>数据范围：1≤n≤20<br>进阶：空间复杂度 O(1) ， 时间复杂度 O(1)</p>
<p><strong>示例1</strong><br>输入: 3<br>返回值: 4<br><strong>示例2</strong><br>输入: 1<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题思路：</span></span><br><span class="line"><span class="comment">// 设f[i] 表示 当前跳道第 i 个台阶的方法数。那么f[n]就是所求答案。</span></span><br><span class="line"><span class="comment">// 假设现在已经跳到了第 n 个台阶，那么前一步可以从哪些台阶到达呢？</span></span><br><span class="line"><span class="comment">// 如果上一步跳 1 步到达第 n 个台阶，说明上一步在第 n-1 个台阶。已知跳到第n-1个台阶的方法数为f[n-1]</span></span><br><span class="line"><span class="comment">// 如果上一步跳 2 步到达第 n 个台阶，说明上一步在第 n-2 个台阶。已知跳到第n-2个台阶的方法数为f[n-2]</span></span><br><span class="line"><span class="comment">// 。。。</span></span><br><span class="line"><span class="comment">// 如果上一步跳 n 步到达第 n 个台阶，说明上一步在第 0 个台阶。已知跳到 第0个台阶的方法数为f[0]</span></span><br><span class="line"><span class="comment">// 那么总的方法数就是所有可能的和。也就是f[n] = f[n-1] + f[n-2] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 显然初始条件f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// 所以我们就可以先求f[2]，然后f[3]...f[n-1]， 最后f[n]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++ j) &#123;</span><br><span class="line">                f[i] += f[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 对于方法一中的：f[n] = f[n-1] + f[n-2] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 那么f[n-1] 为多少呢？</span></span><br><span class="line"><span class="comment">// f[n-1] = f[n-2] + f[n-3] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 所以一合并，f[n] = 2*f[n-1]，初始条件f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// 所以可以采用递归，记忆化递归，动态规划，递推。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            b = a &lt;&lt; <span class="number">1</span>; <span class="comment">//  口诀：左移乘2，右移除2</span></span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 这时候，你会发现一个规律：</span></span><br><span class="line"><span class="comment">// f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// f[2] = 2 = 2&lt;&lt;0 = 1&lt;&lt;1</span></span><br><span class="line"><span class="comment">// f[3] = 4 = 2&lt;&lt;1 = 1&lt;&lt;2</span></span><br><span class="line"><span class="comment">// f[4] = 8 = 2&lt;&lt;2 = 1&lt;&lt;3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ70-矩形覆盖"><a href="#JZ70-矩形覆盖" class="headerlink" title="JZ70 矩形覆盖"></a>JZ70 矩形覆盖</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 递归 动态规划</p>
<p><strong>描述</strong></p>
<p>我们可以用 2<em>1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2</em>1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？</p>
<p>数据范围：0≤n≤38<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>注意：约定 n &#x3D;&#x3D; 0 时，输出 0</p>
<p>比如n&#x3D;3时，2*3的矩形块有3种不同的覆盖方法(从同一个方向看):</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995"></p>
<p><strong>示例1</strong><br>输入: 0<br>返回值: 0<br><strong>示例2</strong><br>输入: 1<br>返回值: 1<br><strong>示例3</strong><br>输入: 4<br>返回值: 5</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题思路：</span></span><br><span class="line"><span class="comment">// 因为小矩形长宽是2*1，所以每次新增加的一列，如果竖着放对应的情况与 target 为 n-1 时相同；如果横着放，对应的情况与 target 为 n-2 时相同。所以：f[n] = f[n-1] + f[n-2]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rectCover</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= target; i ++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ63-买卖股票的最好时机-一"><a href="#JZ63-买卖股票的最好时机-一" class="headerlink" title="JZ63 买卖股票的最好时机(一)"></a>JZ63 买卖股票的最好时机(一)</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 动态规划 贪心</p>
<p><strong>描述</strong></p>
<p>假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益<br>1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天<br>2.如果不能获取到任何利润，请返回0<br>3.假设买入卖出均无手续费</p>
<p>数据范围： 0≤n≤10^5, 0≤val≤10^4</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例1</strong><br>输入: [8,9,2,5,4,7,1]<br>返回值: 5<br>说明: 在第3天(股票价格 &#x3D; 2)的时候买入，在第6天(股票价格 &#x3D; 7)的时候卖出，最大利润 &#x3D; 7-2 &#x3D; 5 ，不能选择在第2天买入，第3天卖出，这样就亏损7了；同时，你也不能在买入前卖出股票。<br><strong>示例2</strong><br>输入: [2,4,1]<br>返回值: 2<br><strong>示例3</strong><br>输入: [3,2,1]<br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span> <span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//dp[i][0]表示某一天不持股到该天为止的最大收益，dp[i][1]表示某天持股，到该天为止的最大收益</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//第一天不持股，总收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一天持股，总收益为减去该天的股价</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历后续每天，状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一天不持股，到该天为止的最大收益</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ47-礼物的最大价值"><a href="#JZ47-礼物的最大价值" class="headerlink" title="JZ47 礼物的最大价值"></a>JZ47 礼物的最大价值</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 动态规划 数组</p>
<p><strong>描述</strong></p>
<p>在一个m\times nm×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<br>如输入这样的一个二维数组，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1,3,1],</span><br><span class="line">[1,5,1],</span><br><span class="line">[4,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为12</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0&lt;grid.length≤200 </span><br><span class="line">0&lt;grid[0].length≤200</span><br></pre></td></tr></table></figure>

<p><strong>示例1</strong><br>输入: <code>[[1,3,1],[1,5,1],[4,2,1]]</code><br>返回值: 12</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span> <span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j ++) &#123;</span><br><span class="line">                <span class="comment">// 取左边或者上面最大值加上当前格子的值</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ48-最长不含重复字符的子字符串"><a href="#JZ48-最长不含重复字符的子字符串" class="headerlink" title="JZ48 最长不含重复字符的子字符串"></a>JZ48 最长不含重复字符的子字符串</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 字符串 哈希 双指针</p>
<p><strong>描述</strong></p>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br>数据范围:<br>s.length≤40000</p>
<p><strong>示例1</strong><br>输入: “abcabcbb”<br>返回值: 3<br>说明: 因为无重复字符的最长子串是”abc”，所以其长度为 3。<br><strong>示例2</strong><br>输入: “bbbbb”<br>返回值: 1<br>说明: 因为无重复字符的最长子串是”b”，所以其长度为 1。<br><strong>示例3</strong><br>输入: “pwwkew”<br>返回值: 3<br>说明: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>    请注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 哈希表记录窗口内非重复的字符</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置窗口左右边界</span></span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; right &lt; cs.length; right ++) &#123;</span><br><span class="line">            <span class="comment">// 窗口右移进入哈希表统计出现次数</span></span><br><span class="line">            map.merge(cs[right], <span class="number">1</span>, Integer::sum);</span><br><span class="line">            <span class="comment">// 出现次数大于1，则窗口内有重复</span></span><br><span class="line">            <span class="keyword">while</span> (map.get(cs[right]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 窗口左移，同时减去该字符的出现次数</span></span><br><span class="line">                map.merge(cs[left ++], -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 维护子串长度最大值</span></span><br><span class="line">            res = Math.max(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希表记录窗口内非重复的字符及其下标</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i]表示以下标i结尾的字符串最长不含重复子串的长度</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 哈希表中没有，说明不重复</span></span><br><span class="line">            <span class="keyword">if</span>(!mp.containsKey(s.charAt(i - <span class="number">1</span>)))</span><br><span class="line">                <span class="comment">//前一个加1</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 遇到重复字符</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = Math.min(dp[i - <span class="number">1</span>] + <span class="number">1</span>, i - mp.get(s.charAt(i - <span class="number">1</span>)));</span><br><span class="line">            <span class="comment">// 加入哈希表</span></span><br><span class="line">            mp.put(s.charAt(i - <span class="number">1</span>), i);</span><br><span class="line">            <span class="comment">// 维护最大值</span></span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ46-把数字翻译成字符串"><a href="#JZ46-把数字翻译成字符串" class="headerlink" title="JZ46 把数字翻译成字符串"></a>JZ46 把数字翻译成字符串</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 动态规划</p>
<p><strong>描述</strong></p>
<p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p>
<p>现在给一串数字，返回有多少种可能的译码结果</p>
<p>数据范围：字符串长度满足 0&lt;n≤90<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例1</strong><br>输入: “12”<br>返回值: 2<br>说明: 2种可能的译码结果（”ab” 或”l”）<br><strong>示例2</strong><br>输入: “31717126241541717”<br>返回值: 192<br>说明: 192种可能的译码结果</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划，需要考虑无法编译的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solve</span> <span class="params">(String nums)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 排除0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 辅助数组初始化为1</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= nums.length(); i ++) &#123;</span><br><span class="line">            <span class="comment">// 当0的前面部署1或2时，无法译码，0种</span></span><br><span class="line">            <span class="keyword">if</span> (nums.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在11-19，21-26之间的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nums.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">                || (nums.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) &lt; <span class="string">&#x27;7&#x27;</span>)) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="JZ15-二进制中1的个数"><a href="#JZ15-二进制中1的个数" class="headerlink" title="JZ15 二进制中1的个数"></a>JZ15 二进制中1的个数</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<p>数据范围：−2<sup>31</sup>&lt;&#x3D;n&lt;&#x3D;2<sup>31</sup>−1<br>即范围为: −2147483648&lt;&#x3D;n&lt;&#x3D;2147483647</p>
<p><strong>示例1</strong><br>输入: 10<br>返回值: 2<br>说明: 十进制中10的32位二进制表示为0000 0000 0000 0000 0000 0000 0000 1010，其中有两个1。<br><strong>示例2</strong><br>输入: -1<br>返回值: 32<br>说明: 负数使用补码表示，-1的32位二进制表示为1111 1111 1111 1111 1111 1111 1111 1111，其中32个1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution1(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解题思路：</span></span><br><span class="line">    <span class="comment">// 对从右向左的第一位1直接判断，遇到0直接略过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (mark != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; mark) != <span class="number">0</span>) &#123;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">            mark &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ16-数值的整数次方"><a href="#JZ16-数值的整数次方" class="headerlink" title="JZ16 数值的整数次方"></a>JZ16 数值的整数次方</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>实现函数 double Power(double base, int exponent)，求base的exponent次方。</p>
<p>注意：<br>1.保证base和exponent不同时为0。<br>2.不得使用库函数，同时不需要考虑大数问题<br>3.有特殊判题，不用考虑小数点后面0的位数。</p>
<p>数据范围：|base|≤100，|exponent|≤100,保证最终结果一定满足 |val|≤10<sup>4</sup><br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例1</strong><br>输入: 2.00000,3<br>返回值: 8.00000<br><strong>示例2</strong><br>输入: 2.10000,3<br>返回值: 9.26100<br><strong>示例3</strong><br>输入: 2.00000,-2<br>返回值: 0.25000<br>说明: 2的-2次方等于1&#x2F;4&#x3D;0.25</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 预处理: b 的 n 次方，当 n 是负数时转换成 1/b 的 n 次方</span></span><br><span class="line"><span class="comment">// 然后暴力解：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            ret *= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 用递归法（快速幂）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q_power(b, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">q_power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> q_power(b, n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">return</span> ret * ret * b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret * ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 用非递归的快速幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> b; <span class="comment">// 记录x^0, x^1, x^2 ...</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><h4 id="JZ5-替换空格"><a href="#JZ5-替换空格" class="headerlink" title="JZ5 替换空格"></a>JZ5 替换空格</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 字符串</p>
<p><strong>描述</strong></p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>数据范围: 0≤len(s)≤1000 。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。</p>
<p><strong>示例1</strong><br>输入: “We Are Happy”<br>返回值: “We%20Are%20Happy”<br><strong>示例2</strong><br>输入: “ “<br>返回值: “%20”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法:2：</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                stringBuilder.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ21-调整数组顺序使奇数位于偶数前面-一"><a href="#JZ21-调整数组顺序使奇数位于偶数前面-一" class="headerlink" title="JZ21 调整数组顺序使奇数位于偶数前面(一)"></a>JZ21 调整数组顺序使奇数位于偶数前面(一)</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点: 数组</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>数据范围：0≤n≤5000，数组中每个数的值 0≤val≤10000<br>要求：时间复杂度 O(n)，空间复杂度 O(n)<br>进阶：时间复杂度 O(n<sup>2</sup>)，空间复杂度 O(1)</p>
<p><strong>示例1</strong><br>输入: <code>[1,2,3,4]</code><br>返回值: <code>[1,3,2,4]</code><br><strong>示例2</strong><br>输入: <code>[2,4,6,5,7]</code><br>返回值: <code>[5,7,2,4,6]</code><br><strong>示例3</strong><br>输入: <code>[1,3,5,6,7]</code><br>返回值: <code>[1,3,5,7,6]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 用stream特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(array).boxed().sorted(Comparator.comparing(Integer::intValue, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 插入排序思想,时间复杂度 O(n^2)，空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">// 记录已经是奇数的位置下标（视作为有序区域），然后向后遍历，一经发现是奇数则进行“插入排序”，然后有序区下标加1。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//使用插入排序的思想</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 首先是对数值长度进行特判</span></span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录已经是奇数的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i ++)&#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="comment">// 如果该值为偶数</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//该值为奇数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span> (k &gt; j) &#123;</span><br><span class="line">                    <span class="comment">//这区间整体向后移动一位</span></span><br><span class="line">                    array[k] = array[k - <span class="number">1</span>];</span><br><span class="line">                    k --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移位之后将对应的值赋值</span></span><br><span class="line">                array[k] = temp;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果数数组</span></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 双指针, 一个处理基数，一个处理偶数，时间复杂度 O(n)，空间复杂度 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 所给数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="comment">// 辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 双指针：left right并初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 循环终止条件：left &lt; len || right &gt;= 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">numLeft</span> <span class="operator">=</span> left, numRight = right; left &lt; len || right &gt;= <span class="number">0</span>; left ++, right --) &#123;</span><br><span class="line">            <span class="comment">// 处理奇数情况</span></span><br><span class="line">            <span class="keyword">if</span> (array[left] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                num[numLeft] = array[left];</span><br><span class="line">                numLeft++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理偶数情况</span></span><br><span class="line">            <span class="keyword">if</span> (array[right] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                num[numRight] = array[right];</span><br><span class="line">                numRight--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<!-- 
#### JZ

时间限制: 1秒
空间限制: 64M
知识点: 

**描述**



**示例1**
输入: 
返回值: 
说明: 
**示例2**
输入: 
返回值: 
说明: 
**示例3**
输入: 
返回值: 
说明: 

**答案**
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h2 id="华为机试"><a href="#华为机试" class="headerlink" title="华为机试"></a>华为机试</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="HJ"><a href="#HJ" class="headerlink" title="HJ"></a>HJ</h4><p>时间限制: 1秒<br>空间限制: 32M<br>知识点: 基础数学 语法题</p>
<p><strong>描述</strong></p>
<p>写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。</p>
<p>数据范围：保证输入的数字在 32 位浮点数范围内</p>
<p><strong>输入描述：</strong><br>输入一个正浮点数值</p>
<p><strong>输出描述：</strong><br>输出该数值的近似整数值</p>
<p><strong>示例1</strong><br>输入: 5.5<br>返回值: 6<br>说明: 0.5&gt;&#x3D;0.5，所以5.5需要向上取整为6<br><strong>示例2</strong><br>输入: 2.499<br>返回值: 2.5<br>说明: 0.499&lt;0.5，2.499向下取整为2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">float</span> <span class="variable">fNum</span> <span class="operator">=</span> sc.nextFloat();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Math.round(fNum);</span><br><span class="line">        <span class="comment">// 或者用下面这句</span></span><br><span class="line">        <span class="comment">// int result = (int) (fNum + 0.5);</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><h3 id="较难"><a href="#较难" class="headerlink" title="较难"></a>较难</h3><h4 id="HJ3-明明的随机数"><a href="#HJ3-明明的随机数" class="headerlink" title="HJ3 明明的随机数"></a>HJ3 明明的随机数</h4><p>时间限制: 1秒<br>空间限制: 32M<br>知识点: 数组</p>
<p><strong>描述</strong><br>明明生成了N个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。</p>
<p>数据范围： 1≤n≤1000，输入的数字大小满足 1≤val≤500 </p>
<p><strong>输入描述：</strong><br>第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的”示例”。</p>
<p><strong>输出描述：</strong><br>输出多行，表示输入数据处理后的结果</p>
<p><strong>示例1</strong><br>输入:<br>3<br>2<br>2<br>1<br>返回值:<br>1<br>2<br>说明:<br>输入解释：<br>第一个数字是3，也即这个小样例的N&#x3D;3，说明用计算机生成了3个1到500之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：<br>2<br>2<br>1<br>所以样例的输出为：<br>1<br>2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            numSet.add(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; numList = numSet.stream().sorted().collect(Collectors.toList());</span><br><span class="line">        numList.forEach(num -&gt; &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//获取个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//创建TreeSet进行去重排序</span></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i &lt; num ;i++)&#123;</span><br><span class="line">            set.add(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><h4 id="HJ28-素数伴侣"><a href="#HJ28-素数伴侣" class="headerlink" title="HJ28 素数伴侣"></a>HJ28 素数伴侣</h4><p>时间限制: 1秒<br>空间限制: 32M<br>知识点: 查找 排序</p>
<p><strong>描述</strong></p>
<p>题目描述<br>若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的 N （ N 为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。</p>
<p>输入:<br>有一个正偶数 n ，表示待挑选的自然数的个数。后面给出 n 个具体的数字。</p>
<p>输出:<br>输出一个整数 K ，表示你求得的“最佳方案”组成“素数伴侣”的对数。</p>
<p>数据范围：1≤n≤100，输入的数据大小满足2≤val≤30000</p>
<p><strong>输入描述：</strong><br>输入说明<br>1 输入一个正偶数 n<br>2 输入 n 个整数</p>
<p><strong>输出描述：</strong><br>求得的“最佳方案”组成“素数伴侣”的对数。</p>
<p><strong>示例1</strong><br>输入: 4<br>    2 5 6 13<br>返回值: 2<br><strong>示例2</strong><br>输入: 2<br>    3 6<br>返回值: 0<br><strong>示例3</strong><br>输入: 2<br>    3 6<br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小技巧！！！素数不是偶数，那么和是素数的话就是奇数+偶数</span></span><br><span class="line">    <span class="comment">// 那么可以分成两堆,一堆偶数，一堆奇数</span></span><br><span class="line">    <span class="comment">// 匈牙利算法，先到先得，能让就让</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">            <span class="comment">// 标准输入</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="comment">// 用于记录输入的n个整数</span></span><br><span class="line">            <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="comment">// 用于存储所有的奇数</span></span><br><span class="line">            ArrayList&lt;Integer&gt; odds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 用于存储所有的偶数</span></span><br><span class="line">            ArrayList&lt;Integer&gt; evens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    odds.add(num);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    evens.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 下标对应偶数的下标，值对应这个偶数的伴侣</span></span><br><span class="line">            <span class="type">int</span>[] evenMatch = <span class="keyword">new</span> <span class="title class_">int</span>[evens.size()];</span><br><span class="line">            <span class="comment">// 记录伴侣的对数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; odds.size(); i ++) &#123;</span><br><span class="line">                <span class="comment">// 用于标记对应的偶数是否查找过</span></span><br><span class="line">                <span class="type">boolean</span>[] evenUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[evens.size()];</span><br><span class="line">                <span class="comment">// 如果匹配上，则计数加1</span></span><br><span class="line">                <span class="keyword">if</span> (find(odds.get(i), evens, evenMatch, evenUsed)) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断奇数x能否找到伴侣</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> odd, ArrayList&lt;Integer&gt; evens, <span class="type">int</span>[] evenMatch, <span class="type">boolean</span>[] evenUsed)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; evens.size(); i ++) &#123;</span><br><span class="line">            <span class="comment">// 该位置偶数能与x组成素数伴侣，并且没被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (isPrime(odd + evens.get(i)) &amp;&amp; !evenUsed[i]) &#123;</span><br><span class="line">                evenUsed[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 如果第i个偶数没有伴侣，或者第i个偶数原来有伴侣，并且该伴侣能够重新找到伴侣的话(这里有递归调用)</span></span><br><span class="line">                <span class="comment">// 则奇数x可以设置为第i个偶数的伴侣</span></span><br><span class="line">                <span class="comment">// 这里采用了匈牙利算法，能让则让</span></span><br><span class="line">                <span class="keyword">if</span> (evenMatch[i] == <span class="number">0</span> || find(evenMatch[i], evens, evenMatch, evenUsed)) &#123;</span><br><span class="line">                    evenMatch[i] = odd;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历完偶数都没有可以与传入奇数做伴侣的，该奇数只能孤独终老了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否是素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= num; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HJ44-Sudoku"><a href="#HJ44-Sudoku" class="headerlink" title="HJ44 Sudoku"></a>HJ44 Sudoku</h4><p>时间限制: 1秒<br>空间限制: 32M<br>知识点: 思维 基础数学 搜索</p>
<p><strong>描述</strong><br>问题描述：数独（Sudoku）是一款大众喜爱的数字逻辑游戏。玩家需要根据9X9盘面上的已知数字，推算出所有剩余空格的数字，并且满足每一行、每一列、每一个3X3粗线宫内的数字均含1-9，并且不重复。</p>
<p>数据范围：输入一个 9*9 的矩阵</p>
<p><strong>输入描述：</strong><br>包含已知数字的9X9盘面数组[空缺位以数字0表示]</p>
<p><strong>输出描述：</strong><br>完整的9X9盘面数组</p>
<p><strong>示例1</strong><br>输入:<br>0 9 2 4 8 1 7 6 3<br>4 1 3 7 6 2 9 8 5<br>8 6 7 3 5 9 4 1 2<br>6 2 4 1 9 5 3 7 8<br>7 5 9 8 4 3 1 2 6<br>1 3 8 6 2 7 5 9 4<br>2 7 1 5 3 8 6 4 9<br>3 8 6 9 1 4 2 5 7<br>0 4 5 2 7 6 8 3 1<br>返回值:<br>5 9 2 4 8 1 7 6 3<br>4 1 3 7 6 2 9 8 5<br>8 6 7 3 5 9 4 1 2<br>6 2 4 1 9 5 3 7 8<br>7 5 9 8 4 3 1 2 6<br>1 3 8 6 2 7 5 9 4<br>2 7 1 5 3 8 6 4 9<br>3 8 6 9 1 4 2 5 7<br>9 4 5 2 7 6 8 3 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从左上角开始去遍历这个数独。</span></span><br><span class="line"><span class="comment">// 对于没有填入的格子（即格子数值为0），我们去枚举1～9每个数字填入，然后根据数独的性质（同行、同列、同一个九宫格不能有相同数字）去判断填入。</span></span><br><span class="line"><span class="comment">// 如果可以成功填完所有格子那么就是找到了答案。找到答案后可以用一个bool变量，然后注意在回溯的地方根据这个变量及时的return，防止已经找到答案后又回溯为0。</span></span><br><span class="line"><span class="comment">// 对于初始化就有值的格子，我们往右走（列数值加一），那么因为一行只有9个，所以当列走到头的时候，列的值变成0，行的值加1（其实就是换到了下一行的开头）。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">            <span class="comment">// 初始化数独</span></span><br><span class="line">            <span class="type">int</span>[][] sd = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++) &#123;</span><br><span class="line">                    sd[i][j] = sc.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 填充数独</span></span><br><span class="line">            dfs(sd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 打印数独</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++) &#123;</span><br><span class="line">                    System.out.print(sd[i][j]);</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] sd, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">9</span>; k ++) &#123;</span><br><span class="line">                <span class="comment">// check后满足</span></span><br><span class="line">                <span class="keyword">if</span> (check(sd, i, j, k)) &#123;</span><br><span class="line">                    sd[i][j] = k;</span><br><span class="line">                    <span class="comment">// 已经找到答案了，直接return</span></span><br><span class="line">                    <span class="keyword">if</span> (dfs(sd, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没找到答案，回溯</span></span><br><span class="line">                    sd[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(sd, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[][] sd, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 同行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sd[i][k] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sd[k][j] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同九宫格</span></span><br><span class="line">        <span class="comment">// 九宫格行的终点</span></span><br><span class="line">        <span class="comment">// 九宫格列的终点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">limitRow</span> <span class="operator">=</span> i / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limitCol</span> <span class="operator">=</span> j / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> limitRow; k &lt; limitRow + <span class="number">3</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> limitCol; l &lt; limitCol + <span class="number">3</span>; l ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sd[k][l] == val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- 
#### HJ

时间限制: 1秒
空间限制: 32M
知识点: 

**描述**


**输入描述：**


**输出描述：**


**示例1**
输入: 
返回值: 
说明: 
**示例2**
输入: 
返回值: 
说明: 
**示例3**
输入: 
返回值: 
说明: 

**答案**
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/coding-interviews">https://www.nowcoder.com/ta/coding-interviews</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problemset/top-100-liked-questions/">https://leetcode.com/problemset/top-100-liked-questions/</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/04/17/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2019/04/17/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4/" class="post-title-link" itemprop="url">修改文件、文件夹——创建、修改、访问时间</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-17 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-17T00:00:00+08:00">2019-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/04/17/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4/" class="post-meta-item leancloud_visitors" data-flag-title="修改文件、文件夹——创建、修改、访问时间" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>因为一些原因，需要进行修改文件或者文件夹的创建、修改、访问时间。</p>
<p>上网上搜索了一波，有的要修改系统当前时间，然后再对文件做一次修改；有的要下载某些工具（各种各样的工具）。实话说，很多乱七八糟的软件本人并不是很信任，所以就想自己做一个工具出来。</p>
<p>最初的时候我是考虑用Java进行编写，但为了方便快捷，后选择了Python编写，毕竟脚本语言，在这方面还是有优势的。总共写了两个版本：</p>
<ul>
<li>版本1<br>用了os、sys、time包，只能对文件、文件夹的修改时间、访问时间做修改</li>
<li>版本2<br>用了win32file、pywintypes、time中的组件，能对文件、文件夹的创建时间、修改时间、访问时间做修改，但是与系统耦合较大，与系统的类型、版本等等都有关系（不建议用这种方式）</li>
</ul>
<p>如果一定要修改创建时间，推荐用工具：<a target="_blank" rel="noopener" href="https://www.ghisler.com/">Total Commande</a></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>版本1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#_*_coding: utf-8 _*_</span></span><br><span class="line"><span class="comment">#@Time    : 2019/4/11 13:15</span></span><br><span class="line"><span class="comment">#@Author  : C</span></span><br><span class="line"><span class="comment">#@FileName: modifyFileTimeModule.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modifyFileTime</span>(<span class="params">path, ctime_t, mtime_t, atime_t</span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">        os.utime(path, (atime_t, mtime_t))</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">        file_list = os.listdir(path)</span><br><span class="line">        <span class="keyword">for</span> fName <span class="keyword">in</span> file_list:</span><br><span class="line">            modifyFileTime(path + <span class="string">&quot;/&quot;</span> + fName, ctime_t, mtime_t, atime_t)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 字符串前面 +r 表示不对字符串进行转义, 如: \\表示双斜杠,而非转义后的单斜杠</span></span><br><span class="line">path = <span class="string">r&#x27;C:/Users/viruser.v-desktop/Desktop/test/test.py&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get arguments  </span></span><br><span class="line"><span class="comment"># cTime = fName[4:-7]</span></span><br><span class="line"><span class="comment"># mTime = cTime</span></span><br><span class="line"><span class="comment"># aTime = cTime</span></span><br><span class="line">cTime = <span class="string">&quot;2015-02-02 00:01:02&quot;</span> <span class="comment"># 创建时间</span></span><br><span class="line">mTime = <span class="string">&quot;2015-02-02 00:01:03&quot;</span> <span class="comment"># 修改时间</span></span><br><span class="line">aTime = <span class="string">&quot;2015-02-02 00:01:04&quot;</span> <span class="comment"># 访问时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># specify time format</span></span><br><span class="line"><span class="comment"># format = &quot;%Y%m%d_%H%M%S&quot;</span></span><br><span class="line"><span class="built_in">format</span> = <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create struct_time object</span></span><br><span class="line">ctime_t = time.mktime(time.strptime(cTime, <span class="built_in">format</span>))</span><br><span class="line">mtime_t = time.mktime(time.strptime(mTime, <span class="built_in">format</span>))</span><br><span class="line">atime_t = time.mktime(time.strptime(aTime, <span class="built_in">format</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">modifyFileTime(path, ctime_t, mtime_t, atime_t)</span><br></pre></td></tr></table></figure>

<p>版本2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#_*_coding: utf-8 _*_</span></span><br><span class="line"><span class="comment">#@Time    : 2019/4/11 13:15</span></span><br><span class="line"><span class="comment">#@Author  : C</span></span><br><span class="line"><span class="comment">#@FileName: modifyFileTimeModule.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> win32file <span class="keyword">import</span> CreateFile, SetFileTime, GetFileTime, CloseHandle</span><br><span class="line"><span class="keyword">from</span> win32file <span class="keyword">import</span> GENERIC_READ, GENERIC_WRITE, OPEN_EXISTING</span><br><span class="line"><span class="keyword">from</span> pywintypes <span class="keyword">import</span> Time</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modifyFileTime</span>(<span class="params">filePath,createTime,modifyTime,accessTime,offset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用来修改任意文件的相关时间属性，时间格式：YYYY-MM-DD HH:MM:SS 例如：2019-02-02 00:01:02</span></span><br><span class="line"><span class="string">    :param filePath: 文件路径名</span></span><br><span class="line"><span class="string">    :param createTime: 创建时间</span></span><br><span class="line"><span class="string">    :param modifyTime: 修改时间</span></span><br><span class="line"><span class="string">    :param accessTime: 访问时间</span></span><br><span class="line"><span class="string">    :param offset: 时间偏移的秒数,tuple格式，顺序和参数时间对应</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">format</span> = <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span> <span class="comment">#时间格式</span></span><br><span class="line">        cTime_t = timeOffsetAndStruct(createTime, <span class="built_in">format</span>, offset[<span class="number">0</span>])</span><br><span class="line">        mTime_t = timeOffsetAndStruct(modifyTime, <span class="built_in">format</span>, offset[<span class="number">1</span>])</span><br><span class="line">        aTime_t = timeOffsetAndStruct(accessTime, <span class="built_in">format</span>, offset[<span class="number">2</span>])</span><br><span class="line"> </span><br><span class="line">        fh = CreateFile(filePath, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">None</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        createTimes, accessTimes, modifyTimes = GetFileTime(fh)</span><br><span class="line"> </span><br><span class="line">        createTimes = Time(time.mktime(cTime_t))</span><br><span class="line">        accessTimes = Time(time.mktime(aTime_t))</span><br><span class="line">        modifyTimes = Time(time.mktime(mTime_t))</span><br><span class="line">        SetFileTime(fh, createTimes, accessTimes, modifyTimes)</span><br><span class="line">        CloseHandle(fh)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeOffsetAndStruct</span>(<span class="params">times, <span class="built_in">format</span>, offset</span>):</span><br><span class="line">    <span class="keyword">return</span> time.localtime(time.mktime(time.strptime(times, <span class="built_in">format</span>)) + offset)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">cTime = <span class="string">&quot;2016-02-02 00:01:02&quot;</span> <span class="comment"># 创建时间</span></span><br><span class="line">mTime = <span class="string">&quot;2016-02-02 00:01:03&quot;</span> <span class="comment"># 修改时间</span></span><br><span class="line">aTime = <span class="string">&quot;2016-02-02 00:01:04&quot;</span> <span class="comment"># 访问时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件路径，字符串前面 +r 表示不对字符串进行转义, 如: \\表示双斜杠,而非转义后的单斜杠</span></span><br><span class="line">fName = <span class="string">r&quot;C:\Users\viruser.v-desktop\Desktop\python\你好答案 - 副本.png&quot;</span></span><br><span class="line"><span class="comment"># 偏移的秒数</span></span><br><span class="line">offset = (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">r=modifyFileTime(fName,cTime,mTime,aTime,offset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r==<span class="number">0</span>:<span class="built_in">print</span>(<span class="string">&#x27;修改完成&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> r==<span class="number">1</span>:<span class="built_in">print</span>(<span class="string">&#x27;修改失败&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1、<a target="_blank" rel="noopener" href="https://blog.csdn.net/dengnihuilaiwpl/article/details/86551720">https://blog.csdn.net/dengnihuilaiwpl/article/details/86551720</a><br>2、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/38430949">https://www.zhihu.com/question/38430949</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Apomelo</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.2/algoliasearch-lite.umd.js" integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.43.1/instantsearch.production.min.js" integrity="sha256-jLNoKrKRDKAOg8JBqkl8jSy2tpqCGQ1/++9QRYtWl8k=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.3/mermaid.min.js","integrity":"sha256-TIYL00Rhw/8WaoUhYTLX9SKIEFdXxg+yMWSLVUbhiLg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"N5VN0ybf5xGuqDFhjzC5RlRL-MdYXbMMI","app_key":"ru1RlOeEotFp87wLFIHucgVu","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
