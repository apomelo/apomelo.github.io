<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"apomelo.cc","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"HQMNR1OKHR","apiKey":"cf13855186697063811959d3e9cf03be","indexName":"apomelo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="正文最近发现自己基础算法方面还有些欠缺。虽然之前也看过数据结构、算法导论、计算机网络等等一些基础书籍，也都理解基础算法和数据结构，但因为没有每道都手写过，所以当真正去实现时还需要去查阅参考资料。由此，下定决心弥补这些不足。基础算法在工作中对业务理解、代码编写并没有非常显著的提升，但是个人觉得这些影响是潜在的，它会潜在的影响你的思考和解决方案。总之，基础夯实终归是没错的。 目前较为推荐的有牛客的剑指">
<meta property="og:type" content="article">
<meta property="og:title" content="基础算法示例和解法">
<meta property="og:url" content="https://apomelo.cc/posts/2019/02/19/basic-algorithm/index.html">
<meta property="og:site_name" content="Apomelo - 追逐">
<meta property="og:description" content="正文最近发现自己基础算法方面还有些欠缺。虽然之前也看过数据结构、算法导论、计算机网络等等一些基础书籍，也都理解基础算法和数据结构，但因为没有每道都手写过，所以当真正去实现时还需要去查阅参考资料。由此，下定决心弥补这些不足。基础算法在工作中对业务理解、代码编写并没有非常显著的提升，但是个人觉得这些影响是潜在的，它会潜在的影响你的思考和解决方案。总之，基础夯实终归是没错的。 目前较为推荐的有牛客的剑指">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210616/557336_1623831920130/2CD1CC917CD1875FF9CD391C2924DF09">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210616/557336_1623836735191/971325772A17A314D3C44EBCDB6E7209">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211027/557336_1635320187489/B1C70B05B2BA3AAA854EE032F2A8D826">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210625/889362376_1624613381635/984D3CF58361D4880F35C93DBDB46F37">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211029/557336_1635477973725/6C502E0240CAC668843969AFF396B5E4">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211031/557336_1635645087543/44496AC711FE9478BABD9207180C3423">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210929/557336_1632915294911/0A4B8F161306A7054899D42C0C6937FD">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210616/557336_1623845692021/E647707AEF2A4AE2C40F0FCCB549B6A5">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211103/301499_1635923010369/C47185D4980F108BC73F790D8D2F6709">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211008/557336_1633683919444/969B0F1641FC5D27A2F517347991EB78">
<meta property="article:published_time" content="2019-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2019-04-22T16:00:00.000Z">
<meta property="article:author" content="Apomelo">
<meta property="article:tag" content="java">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uploadfiles.nowcoder.com/images/20210616/557336_1623831920130/2CD1CC917CD1875FF9CD391C2924DF09">


<link rel="canonical" href="https://apomelo.cc/posts/2019/02/19/basic-algorithm/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://apomelo.cc/posts/2019/02/19/basic-algorithm/","path":"posts/2019/02/19/basic-algorithm/","title":"基础算法示例和解法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>基础算法示例和解法 | Apomelo - 追逐</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2KQDESYMZF"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2KQDESYMZF","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?6c01cfc90b27c8f2cf8c97e38b2f117c"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Apomelo - 追逐</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">1.</span> <span class="nav-text">正文</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%9B%E5%AE%A2"><span class="nav-number">2.</span> <span class="nav-text">牛客</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer"><span class="nav-number">2.1.</span> <span class="nav-text">剑指 offer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">JZ6 从尾到头打印链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">JZ24 反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">JZ25 合并两个排序的链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">JZ52 两个链表的第一个公共结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">JZ23 链表中环的入口结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8E-k-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">JZ22 链表中倒数最后 k 个结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">JZ35 复杂链表的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ76-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">JZ76 删除链表中重复的结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">JZ18 删除链表的节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">2.1.2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ55-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">JZ55 二叉树的深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ77-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">JZ77 按之字形顺序打印二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">JZ54 二叉搜索树的第 k 个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">JZ7 重建二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">JZ26 树的子结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">2.1.2.6.</span> <span class="nav-text">JZ27 二叉树的镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ32-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.7.</span> <span class="nav-text">JZ32 从上往下打印二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-number">2.1.2.8.</span> <span class="nav-text">JZ33 二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ82-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%80"><span class="nav-number">2.1.2.9.</span> <span class="nav-text">JZ82 二叉树中和为某一值的路径(一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%BA%8C"><span class="nav-number">2.1.2.10.</span> <span class="nav-text">JZ34 二叉树中和为某一值的路径(二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.11.</span> <span class="nav-text">JZ36 二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ79-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.12.</span> <span class="nav-text">JZ79 判断是不是平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.2.13.</span> <span class="nav-text">JZ8 二叉树的下一个结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.14.</span> <span class="nav-text">JZ28 对称的二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ78-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C"><span class="nav-number">2.1.2.15.</span> <span class="nav-text">JZ78 把二叉树打印成多行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.16.</span> <span class="nav-text">JZ37 序列化二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ84-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%89"><span class="nav-number">2.1.2.17.</span> <span class="nav-text">JZ84 二叉树中和为某一值的路径(三)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ86-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.1.2.18.</span> <span class="nav-text">JZ86 在二叉树中找到两个节点的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ68-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.1.2.19.</span> <span class="nav-text">JZ68 二叉搜索树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97-%E6%A0%88"><span class="nav-number">2.1.3.</span> <span class="nav-text">队列 &amp; 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">JZ9 用两个栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ30-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">JZ30 包含 min 函数的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">JZ31 栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ73-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">JZ73 翻转单词序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">JZ59 滑动窗口的最大值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.4.</span> <span class="nav-text">搜索算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ53-%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">JZ53 数字在升序数组中出现的次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">JZ4 二维数组中的查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">JZ11 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">JZ38 字符串的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">2.1.4.5.</span> <span class="nav-text">JZ44 数字序列中某一位的数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.1.5.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">JZ42 连续子数组的最大和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ85-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-%E4%BA%8C"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">JZ85 连续子数组的最大和(二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ69-%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">JZ69 跳台阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">JZ10 斐波那契数列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">2.1.5.5.</span> <span class="nav-text">JZ19 正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ71-%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.5.6.</span> <span class="nav-text">JZ71 跳台阶扩展问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ70-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="nav-number">2.1.5.7.</span> <span class="nav-text">JZ70 矩形覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ63-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA-%E4%B8%80"><span class="nav-number">2.1.5.8.</span> <span class="nav-text">JZ63 买卖股票的最好时机(一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">2.1.5.9.</span> <span class="nav-text">JZ47 礼物的最大价值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.5.10.</span> <span class="nav-text">JZ48 最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.5.11.</span> <span class="nav-text">JZ46 把数字翻译成字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">2.1.6.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">JZ12 矩阵中的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">JZ13 机器人的运动范围</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.7.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">JZ3 数组中重复的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">JZ51 数组中的逆序对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ40-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">JZ40 最小的K个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">2.1.7.4.</span> <span class="nav-text">JZ41 数据流中的中位数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">2.1.8.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-number">2.1.8.1.</span> <span class="nav-text">JZ65 不用加减乘除做加法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">2.1.8.2.</span> <span class="nav-text">JZ15 二进制中 1 的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">2.1.8.3.</span> <span class="nav-text">JZ16 数值的整数次方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ56"><span class="nav-number">2.1.8.4.</span> <span class="nav-text">JZ56</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ64-%E6%B1%821-2-3-%E2%80%A6-n"><span class="nav-number">2.1.8.5.</span> <span class="nav-text">JZ64 求1+2+3+…+n</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F"><span class="nav-number">2.1.9.</span> <span class="nav-text">模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">2.1.9.1.</span> <span class="nav-text">JZ29 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ61-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90"><span class="nav-number">2.1.9.2.</span> <span class="nav-text">JZ61 扑克牌顺子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0-atoi"><span class="nav-number">2.1.9.3.</span> <span class="nav-text">JZ67 把字符串转换成整数(atoi)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.9.4.</span> <span class="nav-text">JZ20 表示数值的字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.10.</span> <span class="nav-text">其他算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">JZ66 构建乘积数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-number">2.1.10.2.</span> <span class="nav-text">JZ50 第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">2.1.10.3.</span> <span class="nav-text">JZ5 替换空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2-%E4%B8%80"><span class="nav-number">2.1.10.4.</span> <span class="nav-text">JZ21 调整数组顺序使奇数位于偶数前面(一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">2.1.10.5.</span> <span class="nav-text">JZ39 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ43-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89"><span class="nav-number">2.1.10.6.</span> <span class="nav-text">JZ43 整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-number">2.1.10.7.</span> <span class="nav-text">JZ45 把数组排成最小的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ49-%E4%B8%91%E6%95%B0"><span class="nav-number">2.1.10.8.</span> <span class="nav-text">JZ49 丑数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ74-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-number">2.1.10.9.</span> <span class="nav-text">JZ74 和为S的连续正数序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ57-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">2.1.10.10.</span> <span class="nav-text">JZ57 和为S的两个数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.10.11.</span> <span class="nav-text">JZ58 左旋转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ62-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0"><span class="nav-number">2.1.10.12.</span> <span class="nav-text">JZ62 孩子们的游戏(圆圈中最后剩下的数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ75-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-number">2.1.10.13.</span> <span class="nav-text">JZ75 字符流中第一个不重复的字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ14-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">2.1.10.14.</span> <span class="nav-text">JZ14 剪绳子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ81-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2-%E4%BA%8C"><span class="nav-number">2.1.10.15.</span> <span class="nav-text">JZ81 调整数组顺序使奇数位于偶数前面(二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ83-%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%88%E8%BF%9B%E9%98%B6%E7%89%88%EF%BC%89"><span class="nav-number">2.1.10.16.</span> <span class="nav-text">JZ83 剪绳子（进阶版）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="nav-number">2.1.10.17.</span> <span class="nav-text">JZ17 打印从1到最大的n位数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95"><span class="nav-number">2.2.</span> <span class="nav-text">华为机试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%83%E9%9A%BE"><span class="nav-number">2.2.1.</span> <span class="nav-text">较难</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HJ3-%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">HJ3 明明的随机数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%B0%E9%9A%BE"><span class="nav-number">2.2.2.</span> <span class="nav-text">困难</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HJ28-%E7%B4%A0%E6%95%B0%E4%BC%B4%E4%BE%A3"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">HJ28 素数伴侣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HJ44-Sudoku"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">HJ44 Sudoku</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Apomelo</p>
  <div class="site-description" itemprop="description">我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/apomelo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;apomelo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:apomeloc@gmail.com" title="E-Mail → mailto:apomeloc@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/02/19/basic-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="基础算法示例和解法 | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基础算法示例和解法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-19T00:00:00+08:00">2019-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-04-23 00:00:00" itemprop="dateModified" datetime="2019-04-23T00:00:00+08:00">2019-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/02/19/basic-algorithm/" class="post-meta-item leancloud_visitors" data-flag-title="基础算法示例和解法" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>最近发现自己基础算法方面还有些欠缺。虽然之前也看过数据结构、算法导论、计算机网络等等一些基础书籍，也都理解基础算法和数据结构，但因为没有每道都手写过，所以当真正去实现时还需要去查阅参考资料。由此，下定决心弥补这些不足。基础算法在工作中对业务理解、代码编写并没有非常显著的提升，但是个人觉得这些影响是潜在的，它会潜在的影响你的思考和解决方案。总之，基础夯实终归是没错的。</p>
<p>目前较为推荐的有牛客的剑指 offer、LeetCode 的 Top 100 Liked Questions。个人更推荐 LeetCode，但是牛客有手机 App，如果想在上下班路上刷一刷，可以选择牛客。我也是因此选择先刷牛客，下面是相关的题目和个人通过编译的答案，不定期更新，如答案中有错误之处烦请指出。</p>
<span id="more"></span>

<h1 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h1><h2 id="剑指-offer"><a href="#剑指-offer" class="headerlink" title="剑指 offer"></a>剑指 offer</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="JZ6-从尾到头打印链表"><a href="#JZ6-从尾到头打印链表" class="headerlink" title="JZ6 从尾到头打印链表"></a>JZ6 从尾到头打印链表</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p>
<p>如输入 <code>&#123;1,2,3&#125;</code> 的链表，返回一个数组为 <code>[3,2,1]</code></p>
<p>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3&#125;</code><br>返回值: <code>[3,2,1]</code><br><strong>示例 2</strong><br>输入: {67,0,24,58}<br>返回值: [58,24,0,67]</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1:</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (listNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(listNode);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            result.add(stack.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ24-反转链表"><a href="#JZ24-反转链表" class="headerlink" title="JZ24 反转链表"></a>JZ24 反转链表</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>给定一个单链表的头结点 pHead，长度为 n，反转该链表后，返回新链表的表头。</p>
<p>数据范围: n≤1000<br>要求: 空间复杂度 O(1)，时间复杂度 O(n)。</p>
<p>如当输入链表 <code>&#123;1,2,3&#125;</code> 时，<br>经反转后，原链表变为 <code>&#123;3,2,1&#125;</code>，所以对应的输出为 <code>&#123;3,2,1&#125;</code>。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3&#125;</code><br>返回值: <code>&#123;3,2,1&#125;</code><br><strong>示例 2</strong><br>输入: <code>&#123;&#125;</code><br>返回值: <code>&#123;&#125;</code><br>说明: 空链表则输出空</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ25-合并两个排序的链表"><a href="#JZ25-合并两个排序的链表" class="headerlink" title="JZ25 合并两个排序的链表"></a>JZ25 合并两个排序的链表</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入两个递增的链表，单个链表的长度为 n，合并这两个链表并使新链表中的节点仍然是递增排序的。<br>数据范围: 0≤n≤1000，−1000≤ 节点值 ≤1000<br>要求: 空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>如输入 <code>&#123;1,3,5&#125;,&#123;2,4,6&#125;</code> 时，合并后的链表为 <code>&#123;1,2,3,4,5,6&#125;</code>，所以对应的输出为 <code>&#123;1,2,3,4,5,6&#125;</code><br>输入 <code>&#123;-1,2,4&#125;,&#123;1,3,4&#125;</code>时，合并后的链表为 <code>&#123;-1,1,2,3,4,4&#125;</code>，所以对应的输出为 <code>&#123;-1,1,2,3,4,4&#125;</code></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,3,5&#125;,&#123;2,4,6&#125;</code><br>返回值: <code>&#123;1,2,3,4,5,6&#125;</code><br><strong>示例 2</strong><br>输入: <code>&#123;&#125;,&#123;&#125;</code><br>返回值: <code>&#123;&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="literal">null</span>) cur.next = list1;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="literal">null</span>) cur.next = list2;</span><br><span class="line">        <span class="keyword">return</span> h.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ52-两个链表的第一个公共结点"><a href="#JZ52-两个链表的第一个公共结点" class="headerlink" title="JZ52 两个链表的第一个公共结点"></a>JZ52 两个链表的第一个公共结点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p>数据范围：n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入分为是 3 段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这 3 个参数组装为两个链表，并将这两个链表对应的头节点传入到函数 FindFirstCommonNode 里面，用户得到的输入只有 pHead1 和 pHead2。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7&#125;</code><br>返回值: <code>&#123;6,7&#125;</code><br>说明: 第一个参数 <code>&#123;1,2,3&#125;</code> 代表是第一个链表非公共部分，第二个参数 <code>&#123;4,5&#125;</code> 代表是第二个链表非公共部分，最后的 <code>&#123;6,7&#125;</code> 表示的是 2 个链表的公共部分。这 3 个参数最后在后台会组装成为 2 个两个无环的单链表，且是有公共节点的。<br><strong>示例 2</strong><br>输入: <code>&#123;1&#125;,&#123;2,3&#125;,&#123;&#125;</code><br>返回值: <code>&#123;&#125;</code><br>说明: 2 个链表没有公共节点 ,返回 null，后台打印 <code>&#123;&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法：使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。</span></span><br><span class="line"><span class="comment">// 让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。</span></span><br><span class="line"><span class="comment">// 因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> pHead1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> pHead2;</span><br><span class="line">        <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">            l1 = (l1 == <span class="literal">null</span>) ? pHead2 : l1.next;</span><br><span class="line">            l2 = (l2 == <span class="literal">null</span>) ? pHead1 : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ23-链表中环的入口结点"><a href="#JZ23-链表中环的入口结点" class="headerlink" title="JZ23 链表中环的入口结点"></a>JZ23 链表中环的入口结点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表 哈希 双指针</p>
<p><strong>描述</strong></p>
<p>给一个长度为 n 链表，若其中包含环，请找出该链表的环的入口结点，否则，返回 null。</p>
<p>数据范围： n≤10000，1&lt;&#x3D;结点值&lt;&#x3D;10000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入分为 2 段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p>
<p>返回值描述：<br>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2&#125;,&#123;3,4,5&#125;</code><br>返回值: “null”<br>说明: 没有环，返回对应编程语言的空结点，后台程序会打印 “null”<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;,&#123;2&#125;</code><br>返回值: 2<br>说明: 环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 用HashMap (不推荐)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用set来记录出现的结点</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当set中包含结点，说明第一次出现重复的结点，即环的入口结点</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(pHead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// set中加入未重复的结点</span></span><br><span class="line">            set.add(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用快慢指针</span></span><br><span class="line"><span class="comment">// 在环上的时候快指针与慢指针之间差N步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差(N+1-2)-&gt; N-1步。</span></span><br><span class="line"><span class="comment">// 所以快指针必然与慢指针相遇。又因为快指针速度是慢指针的两倍，所以相遇时必然只绕了一圈。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 快指针是满指针的两倍速度</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 记录快慢指针第一次相遇的结点</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若是快指针指向null，则不存在环</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新指向链表头部</span></span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ22-链表中倒数最后-k-个结点"><a href="#JZ22-链表中倒数最后-k-个结点" class="headerlink" title="JZ22 链表中倒数最后 k 个结点"></a>JZ22 链表中倒数最后 k 个结点</h4><p>时间限制: 1 秒<br>空间限制: 256M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第 k 个节点。<br>如果该链表长度小于 k，请返回一个长度为 0 的链表。</p>
<p>数据范围：0≤n≤10<sup>5</sup>，0≤a<sub>i</sub>≤10<sup>9</sup>，0≤k≤10<sup>9</sup></p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5&#125;,2</code><br>返回值: <code>&#123;4,5&#125;</code><br>说明：返回倒数第 2 个节点 4，系统会打印后面所有的节点来比较。<br><strong>示例 2</strong><br>输入: <code>&#123;2&#125;,8</code><br>返回值: <code>&#123;&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor1</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor2</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor1 = cursor1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cursor1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cursor1 = cursor1.next;</span><br><span class="line">            cursor2 = cursor2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 直接遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> ((cursor = cursor.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i - k; j ++) &#123;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3: 用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//链表节点压栈</span></span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断栈的元素是否小于k</span></span><br><span class="line">        <span class="keyword">if</span> (stack.size() &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在出栈串成新的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstNode</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">while</span> (--k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将出栈的元素重新连接成为链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            temp.next = firstNode;</span><br><span class="line">            firstNode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ35-复杂链表的复制"><a href="#JZ35-复杂链表的复制" class="headerlink" title="JZ35 复杂链表的复制"></a>JZ35 复杂链表的复制</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针 random 指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有 5 个结点的复杂链表。图中实线箭头表示 next 指针，虚线箭头表示 random 指针。为简单起见，指向 null 的指针没有画出。<br><img src="https://uploadfiles.nowcoder.com/images/20210616/557336_1623831920130/2CD1CC917CD1875FF9CD391C2924DF09"></p>
<p>示例:<br>输入: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>输出: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>解析:我们将链表分为两段，前半部分 <code>&#123;1,2,3,4,5&#125;</code> 为 ListNode，后半部分 <code>&#123;3,5,#,2,#&#125;</code> 是随机指针域表示。<br>以上示例前半部分可以表示链表为的 ListNode:1-&gt;2-&gt;3-&gt;4-&gt;5<br>后半部分，<code>3，5，#，2，#</code> 分别的表示为 1 的位置指向 3，2 的位置指向 5，3 的位置指向 null，4 的位置指向 2，5 的位置指向 null<br>如下图:<br><img src="https://uploadfiles.nowcoder.com/images/20210616/557336_1623836735191/971325772A17A314D3C44EBCDB6E7209"></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>返回值: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 借助map构建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pHead;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(cur.label));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 链表拼接、拆分</span></span><br><span class="line"><span class="comment">// 考虑构建 原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆基础链表</span></span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RandomListNode</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(cur.label);</span><br><span class="line">            clone.next = cur.next;</span><br><span class="line">            cur.next = clone;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆随机链表</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next.random = cur.random != <span class="literal">null</span> ? cur.random.next : <span class="literal">null</span>;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分链表</span></span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cloneHead</span> <span class="operator">=</span> pHead.next;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">old</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">clone</span> <span class="operator">=</span> cloneHead;</span><br><span class="line">        <span class="keyword">while</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            old.next = clone.next;</span><br><span class="line">            <span class="keyword">if</span> (old.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                clone.next = old.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            old = old.next;</span><br><span class="line">            clone = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ76-删除链表中重复的结点"><a href="#JZ76-删除链表中重复的结点" class="headerlink" title="JZ76 删除链表中重复的结点"></a>JZ76 删除链表中重复的结点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code> 处理后为 <code>1-&gt;2-&gt;5</code></p>
<p>数据范围：链表长度满足 0≤n≤1000 ，链表中的值满足 1≤val≤1000</p>
<p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>例如输入 <code>&#123;1,2,3,3,4,4,5&#125;</code> 时，对应的输出为<code> &#123;1,2,5&#125;</code></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,3,4,4,5&#125;</code><br>返回值: <code>&#123;1,2,5&#125;</code><br><strong>示例 2</strong><br>输入: <code>&#123;1,1,1,8&#125;</code><br>返回值: <code>&#123;8&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 给链表前加上表头，删除所有重复的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplication</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在链表前加一个表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        res.next = pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//遇到相邻两个节点值相同</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == temp)</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时去掉表头</span></span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用HashMap计数</span></span><br></pre></td></tr></table></figure>

<h4 id="JZ18-删除链表的节点"><a href="#JZ18-删除链表的节点" class="headerlink" title="JZ18 删除链表的节点"></a>JZ18 删除链表的节点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<p>1.此题对比原题有改动 2.题目保证链表中节点的值互不相同 3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<p>数据范围:<br>0&lt;&#x3D;链表节点值&lt;&#x3D;10000<br>0&lt;&#x3D;链表长度&lt;&#x3D;10000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;2,5,1,9&#125;,5</code><br>返回值: <code>&#123;2,1,9&#125;</code><br>说明: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 1 -&gt; 9<br><strong>示例 2</strong><br>输入: <code>&#123;2,5,1,9&#125;,1</code><br>返回值: <code>&#123;2,5,9&#125;</code><br>说明: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 5 -&gt; 9</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法: 添加头结点，找到对应节点后退出循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span> <span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 添加头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        res.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="JZ55-二叉树的深度"><a href="#JZ55-二叉树的深度" class="headerlink" title="JZ55 二叉树的深度"></a>JZ55 二叉树的深度</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。</p>
<p>数据范围：节点的数量满足 0≤n≤100 ，节点上的值满足 0≤val≤100<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5,#,6,#,#,7&#125;</code><br>返回值: 4<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;</code><br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(TreeDepth(root.left), TreeDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ77-按之字形顺序打印二叉树"><a href="#JZ77-按之字形顺序打印二叉树" class="headerlink" title="JZ77 按之字形顺序打印二叉树"></a>JZ77 按之字形顺序打印二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈 树 队列</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p>
<p>数据范围：0≤n≤1500,树上每个节点的 val 满足 ∣val∣&lt;&#x3D;1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)<br>例如：<br>给定的二叉树是<code>&#123;1,2,3,#,#,4,5&#125;</code><br>该二叉树之字形层序遍历的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1],</span><br><span class="line">[3,2],</span><br><span class="line">[4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,#,#,4,5&#125;</code><br>返回值: <code>[[1],[3,2],[4,5]]</code><br><strong>示例 2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>[[8],[10,6],[5,7,9,11]]</code><br><strong>示例 3</strong><br>输入: <code>&#123;1,2,3,4,5&#125;</code><br>返回值: <code>[[1],[3,2],[4,5]]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 用链表，一个链表记录当前层，一个链表记录下一层，也可用栈</span></span><br><span class="line"><span class="comment">// 注意: 每次都从后往前遍历，即可翻转，但是第一层节点右节点先入下一层，第二层左节点先，如此反复</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        layer.add(pRoot);</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;() &#123;&#123;add(pRoot.val);&#125;&#125;);</span><br><span class="line">        <span class="keyword">while</span> (layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;TreeNode&gt; nextLayer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; nextLayerValue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (result.size() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> layer.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> layer.get(i);</span><br><span class="line">                    addTreeNode(treeNode.right, nextLayer, nextLayerValue);</span><br><span class="line">                    addTreeNode(treeNode.left, nextLayer, nextLayerValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> layer.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> layer.get(i);</span><br><span class="line">                    addTreeNode(treeNode.left, nextLayer, nextLayerValue);</span><br><span class="line">                    addTreeNode(treeNode.right, nextLayer, nextLayerValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            layer = nextLayer;</span><br><span class="line">            <span class="keyword">if</span> (nextLayerValue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(nextLayerValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTreeNode</span><span class="params">(TreeNode treeNode, ArrayList&lt;TreeNode&gt; nextLayer, ArrayList&lt;Integer&gt; nextLayerValue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextLayer.add(treeNode);</span><br><span class="line">            nextLayerValue.add(treeNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ54-二叉搜索树的第-k-个节点"><a href="#JZ54-二叉搜索树的第-k-个节点" class="headerlink" title="JZ54 二叉搜索树的第 k 个节点"></a>JZ54 二叉搜索树的第 k 个节点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 dfs 递归</p>
<p><strong>描述</strong></p>
<p>给定一棵结点数为 n 二叉搜索树，请找出其中的第 k 小的 TreeNode 结点值。 1.返回第 k 小的节点值即可 2.不能查找的情况，如二叉树为空，则返回-1，或者 k 大于 n 等等，也返回-1 3.保证 n 个节点的值不一样</p>
<p>数据范围：0≤n≤1000，0≤k≤1000，树上每个结点的值满足 0≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>如输入<code>&#123;5,3,7,2,4,6,8&#125;,3</code>时。该二叉树所有节点按结点值升序排列后可得<code>[2,3,4,5,6,7,8]</code>，所以第 3 个结点的结点值为 4，故返回对应结点值为 4 的结点即可。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;5,3,7,2,4,6,8&#125;,3</code><br>返回值: 4<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;,1</code><br>返回值: -1<br>说明: 当树是空</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 递归 用链表存储数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proot TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KthNode</span><span class="params">(TreeNode proot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (proot == <span class="literal">null</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        addNode(list, proot);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; list.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(List&lt;Integer&gt; list, TreeNode curNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(list, curNode.left);</span><br><span class="line">        list.add(curNode.val);</span><br><span class="line">        addNode(list, curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 递归 计数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proot TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KthNode</span><span class="params">(TreeNode proot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 记录返回的节点</span></span><br><span class="line">        TreeNode[] res = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[] &#123;<span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="comment">// 记录中序遍历了多少个</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        midOrder(res, count, proot, k);</span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">0</span>].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midOrder</span><span class="params">(TreeNode[] res, <span class="type">int</span>[] count, TreeNode curNode, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//当遍历到节点为空或者超过k时，返回</span></span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="literal">null</span> || count[<span class="number">0</span>] &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        midOrder(res, count, curNode.left, k);</span><br><span class="line">        count[<span class="number">0</span>] ++;</span><br><span class="line">        <span class="comment">// 只记录第k个</span></span><br><span class="line">        <span class="keyword">if</span> (count[<span class="number">0</span>] == k) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        midOrder(res, count, curNode.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ7-重建二叉树"><a href="#JZ7-重建二叉树" class="headerlink" title="JZ7 重建二叉树"></a>JZ7 重建二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 dfs 数组</p>
<p><strong>描述</strong></p>
<p>给定节点数为 n 二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。<br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628"></p>
<p>提示:<br>1.vin.length &#x3D;&#x3D; pre.length<br>2.pre 和 vin 均无重复元素<br>3.vin 出现的元素均出现在 pre 里 4.只需要返回根结点，系统会自动输出整颗树做答案对比</p>
<p>数据范围：n≤2000，节点的值 −10000≤val≤10000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]</code><br>返回值: <code>&#123;1,2,3,4,#,5,6,#,7,#,#,8&#125;</code><br>说明：返回根节点，系统会输出整颗二叉树对比结果，重建结果如题面图示<br><strong>示例 2</strong><br>输入: <code>[1],[1]</code><br>返回值: <code>&#123;1&#125;</code><br><strong>示例 3</strong><br>输入: <code>[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</code><br>返回值: <code>&#123;1,2,5,3,4,6,7&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 算法思想：</span></span><br><span class="line"><span class="comment"> 1. 先序遍历第一个位置肯定是根节点node</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 2. 中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 3. 先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 4. 把四个数组找出来，分左右递归调用即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 每次直接拷贝出对应的四个数组，然后递归调用</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span> || in.length == <span class="number">0</span> || pre.length != in.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[<span class="number">0</span>] == in[i]) &#123;</span><br><span class="line">                node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i+<span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+<span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 传递原数组、以及数组中对应的开始位置和长度，然后递归调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] in)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reConstructBinaryTree(pre, in, <span class="number">0</span>, <span class="number">0</span>, pre.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次都传递原数组的引用，不需要进行数组拷贝，但是要注意：</span></span><br><span class="line"><span class="comment">     *   先序和中序开始的位置是不一样的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre 原先序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 原中序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preBeginIndex 先序数组中开始的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inBeginIndex 中序数组中开始的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 本次要重建的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> preBeginIndex, <span class="type">int</span> inBeginIndex, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否越界，以及本次长度是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (preBeginIndex &lt; <span class="number">0</span> || preBeginIndex + length &gt; pre.length</span><br><span class="line">                || inBeginIndex &lt; <span class="number">0</span> || inBeginIndex + length &gt; pre.length || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先序遍历第一个位置肯定是根节点node</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preBeginIndex]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> preBeginIndex;</span><br><span class="line">        <span class="comment">// 左子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inBeginIndex; i &lt; inBeginIndex + length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[preBeginIndex] == in[i]) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                leftLength = i - inBeginIndex;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> length - leftLength - <span class="number">1</span>;</span><br><span class="line">        root.left = reConstructBinaryTree(pre, in, preBeginIndex + <span class="number">1</span>, inBeginIndex, leftLength);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, in, preBeginIndex + leftLength + <span class="number">1</span>, rootIndex + <span class="number">1</span>, rightLength);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ26-树的子结构"><a href="#JZ26-树的子结构" class="headerlink" title="JZ26 树的子结构"></a>JZ26 树的子结构</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 二叉树 树</p>
<p><strong>描述</strong></p>
<p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构。（我们约定空树不是任意一个树的子结构）<br>假如给定 A 为{8,8,7,9,2,#,#,#,#,4,7}，B 为{8,9,2}，2 个树的结构如下，可以看出 B 是 A 的子结构</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211027/557336_1635320187489/B1C70B05B2BA3AAA854EE032F2A8D826"></p>
<p>数据范围:<br>0 &lt;&#x3D; A 的节点个数 &lt;&#x3D; 10000<br>0 &lt;&#x3D; B 的节点个数 &lt;&#x3D; 10000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;8,8,7,9,2,#,#,#,#,4,7&#125;,&#123;8,9,2&#125;</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>&#123;1,2,3,4,5&#125;,&#123;2,4&#125;</code><br>返回值: true<br><strong>示例 3</strong><br>输入: <code>&#123;1,2,3&#125;,&#123;3,1&#125;</code><br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 双遍历 先遍历A，在每个节点都去去对比B是否是子树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历A</span></span><br><span class="line">        <span class="keyword">return</span> traverse(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(TreeNode root1,TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// A的该节点是空</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 和B对比</span></span><br><span class="line">        <span class="keyword">if</span> (compare(root1, root2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历A的左右子树</span></span><br><span class="line">            <span class="keyword">return</span> traverse(root1.left, root2) || traverse(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1.val != root2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> compare(root1.left, root2.left) &amp;&amp; compare(root1.right, root2.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ27-二叉树的镜像"><a href="#JZ27-二叉树的镜像" class="headerlink" title="JZ27 二叉树的镜像"></a>JZ27 二叉树的镜像</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>数据范围：二叉树的节点数 0≤n≤1000 ， 二叉树每个节点的值 0≤val≤1000<br>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1) 的解法，时间复杂度 O(n)</p>
<p>比如：<br>源二叉树<br><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888"><br>镜像二叉树<br><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A"></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>&#123;8,10,6,11,9,7,5&#125;</code><br>说明: 如题面所示<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;</code><br>返回值: <code>&#123;&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 先交换左右子节点，然后遍历子节点交换子节点的左右子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = tmp;</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 见下图</span></span><br><span class="line"><span class="comment">// 算法流程：一层一层进栈并交换左右节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 构建辅助栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 根节点入栈</span></span><br><span class="line">        stack.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 节点出栈</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="comment">// 根节点的左右子树入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">            <span class="comment">// 左右子树交换</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法 2<br><img src="https://uploadfiles.nowcoder.com/images/20210625/889362376_1624613381635/984D3CF58361D4880F35C93DBDB46F37"></p>
<h4 id="JZ32-从上往下打印二叉树"><a href="#JZ32-从上往下打印二叉树" class="headerlink" title="JZ32 从上往下打印二叉树"></a>JZ32 从上往下打印二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 队列 树</p>
<p><strong>描述</strong></p>
<p>不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如输入{8,6,10,#,#,2,1}，如以下图中的示例二叉树，则依次打印 8,6,10,2,1(空节点不打印，跳过)，请你将打印的结果存放到一个数组里面，返回。<br><img src="https://uploadfiles.nowcoder.com/images/20211029/557336_1635477973725/6C502E0240CAC668843969AFF396B5E4"></p>
<p>数据范围:<br>0&lt;&#x3D;节点总数&lt;&#x3D;1000<br>-1000&lt;&#x3D;节点值&lt;&#x3D;1000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;8,6,10,#,#,2,1&#125;</code><br>返回值: [8,6,10,2,1]<br><strong>示例 2</strong><br>输入: <code>&#123;5,4,#,3,#,2,#,1&#125;</code><br>返回值: [5,4,3,2,1]</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 层次遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回列表</span></span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 暂存当前层节点</span></span><br><span class="line">        List&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        layer.add(root);</span><br><span class="line">        <span class="keyword">while</span> (layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建当前层缓存</span></span><br><span class="line">            List&lt;TreeNode&gt; tmp = layer;</span><br><span class="line">            <span class="comment">// 新建下一层</span></span><br><span class="line">            layer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                    result.add(node.val);</span><br><span class="line">                    layer.add(node.left);</span><br><span class="line">                    layer.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ33-二叉搜索树的后序遍历序列"><a href="#JZ33-二叉搜索树的后序遍历序列" class="headerlink" title="JZ33 二叉搜索树的后序遍历序列"></a>JZ33 二叉搜索树的后序遍历序列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈 树</p>
<p><strong>描述</strong></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同。</p>
<p>数据范围： 节点数量 0≤n≤1000 ，节点上的值满足 1≤val≤10<sup>5</sup>，保证节点上的值各不相同<br>要求：空间复杂度 O(n) ，时间时间复杂度 O(n^2)</p>
<p>提示： 1.二叉搜索树是指父亲节点大于左子树中的全部节点，但是小于右子树中的全部节点的树。 2.该题我们约定空树不是二叉搜索树 3.后序遍历是指按照 “左子树-右子树-根节点” 的顺序遍历 4.参考下面的二叉搜索树，示例 1</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211031/557336_1635645087543/44496AC711FE9478BABD9207180C3423"></p>
<p><strong>示例 1</strong><br>输入: <code>[1,3,2]</code><br>返回值: true<br>说明: 是上图的后序遍历 ，返回 true<br><strong>示例 2</strong><br>输入: <code>[3,1,2]</code><br>返回值: false<br>说明: 不属于上图的后序遍历，从另外的二叉搜索树也不能后序遍历出该序列 ，因为最后的 2 一定是根节点，前面一定是孩子节点，可能是左孩子，右孩子，根节点，也可能是全左孩子，根节点，也可能是全右孩子，根节点，但是 <code>[3,1,2]</code> 的组合都不能满足这些情况，故返回 false<br><strong>示例 3</strong><br>输入: <code>[5,7,6,9,11,10,8]</code><br>返回值: true</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 将一个序列划分为3段, 左子树+右子树+根，然后遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">VerifySquenceOfBST</span><span class="params">(<span class="type">int</span> [] sequence)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> sequence.length;</span><br><span class="line">        <span class="keyword">if</span> (sequence.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(<span class="type">int</span>[] sequence, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">// 子树只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子树根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> sequence[r];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 划分右子树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; sequence[j] &gt; root) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左子树是否存在大于根节点的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= j; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &gt; root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> verify(sequence, l, j) &amp;&amp; verify(sequence, j + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ82-二叉树中和为某一值的路径-一"><a href="#JZ82-二叉树中和为某一值的路径-一" class="headerlink" title="JZ82 二叉树中和为某一值的路径(一)"></a>JZ82 二叉树中和为某一值的路径(一)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 dfs</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树 root 和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为 n</p>
<p>例如：<br>给出如下的二叉树，sum&#x3D;22，<br><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159"></p>
<p>返回 true，因为存在一条路径 5→4→11→2 的节点值之和为 22</p>
<p>数据范围： 1.树上的节点数满足 0≤n≤10000 2.每 个节点的值都满足 ∣val∣≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>进阶：空间复杂度 O(树的高度)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;5,4,8,1,11,#,9,#,#,2,7&#125;,22</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>&#123;1,2&#125;,0</code><br>返回值: false<br><strong>示例 3</strong><br>输入: <code>&#123;1,2&#125;,3</code><br>返回值: true<br><strong>示例 4</strong><br>输入: <code>&#123;&#125;,0</code><br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 递归 加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root, sum, root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum, <span class="type">int</span> res)</span> &#123;</span><br><span class="line">        <span class="comment">// 左右子节点都为空才是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == sum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                left = hasPathSum(root.left, sum, res + root.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                right = hasPathSum(root.right, sum, res + root.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left || right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 递归 减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ34-二叉树中和为某一值的路径-二"><a href="#JZ34-二叉树中和为某一值的路径-二" class="headerlink" title="JZ34 二叉树中和为某一值的路径(二)"></a>JZ34 二叉树中和为某一值的路径(二)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>输入一颗二叉树的根节点 root 和一个整数 expectNumber，找出二叉树中结点值的和为 expectNumber 的所有路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为 n</p>
<p>如二叉树 root 为 <code>&#123;10,5,12,4,7&#125;</code>, expectNumber 为 22<br><img src="https://uploadfiles.nowcoder.com/images/20210929/557336_1632915294911/0A4B8F161306A7054899D42C0C6937FD"><br>则合法路径有 <code>[[10,5,7],[10,12]]</code></p>
<p>数据范围:<br>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; 节点值 &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; expectNumber &lt;&#x3D; 1000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;10,5,12,4,7&#125;,22</code><br>返回值: <code>[[10,5,7],[10,12]]</code><br>说明: 返回 <code>[[10,12],[10,5,7]]</code> 也是对的<br><strong>示例 2</strong><br>输入: <code>&#123;10,5,12,4,7&#125;,15</code><br>返回值: <code>[]</code><br><strong>示例 3</strong><br>输入: <code>&#123;2,3&#125;,0</code><br>返回值: <code>[]</code><br><strong>示例 4</strong><br>输入: <code>&#123;1,3,4&#125;,7</code><br>返回值: <code>[]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 深度优先搜索 加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> expectNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        findPath(root, expectNumber, root.val, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findPath</span><span class="params">(TreeNode root, <span class="type">int</span> expectNumber, <span class="type">int</span> sum,</span></span><br><span class="line"><span class="params">                          ArrayList&lt;Integer&gt; path,</span></span><br><span class="line"><span class="params">                          ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum == expectNumber) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.add(root.left.val);</span><br><span class="line">            findPath(root.left, expectNumber, sum + root.left.val, path, result);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.add(root.right.val);</span><br><span class="line">            findPath(root.right, expectNumber, sum + root.right.val, path, result);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 深度优先搜索 减法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> expectNumber)</span> &#123;</span><br><span class="line">        dfs(root, expectNumber);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理树为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 路径更新</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">// number更新</span></span><br><span class="line">        number -= root.val;</span><br><span class="line">        <span class="comment">// 如果递归当前节点为叶子节点且该条路径的值已经达到了expectNumber，则更新ret</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; number == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树递归</span></span><br><span class="line">        dfs(root.left, number);</span><br><span class="line">        dfs(root.right, number);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ36-二叉搜索树与双向链表"><a href="#JZ36-二叉搜索树与双向链表" class="headerlink" title="JZ36 二叉搜索树与双向链表"></a>JZ36 二叉搜索树与双向链表</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 分治</p>
<p><strong>描述</strong></p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2"></p>
<p>数据范围：输入二叉树的节点数 0≤n≤1000，二叉树中每个节点的值 0≤val≤1000<br>要求：空间复杂度 O(1)（即在原树上操作），时间复杂度 O(n)</p>
<p>注意: 1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 2.返回链表中的第一个节点的指针 3.函数返回的 TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p>
<p>输入描述：<br>二叉树的根节点</p>
<p>返回值描述：<br>双向链表的其中一个头节点。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;10,6,14,4,8,12,16&#125;</code><br>返回值: From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;<br>说明: 输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。<br><strong>示例 2</strong><br>输入: <code>&#123;5,4,#,3,#,2,#,1&#125;</code><br>返回值: From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;<br>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        5</span><br><span class="line">       /</span><br><span class="line">      4</span><br><span class="line">     /</span><br><span class="line">    3</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>树的形状如上图</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 方法1: 递归中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//返回的第一个指针，即为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//中序遍历当前值的上一位，初值为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//中序递归，叶子为空则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先递归到最左最小值</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="comment">//找到最小值，初始化head与pre</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2: 非递归中序遍历 （栈）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//设置栈用于遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//确认第一个遍历到最左，即为首位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFirst</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (pRootOfTree != <span class="literal">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//直到没有左节点</span></span><br><span class="line">            <span class="keyword">while</span> (pRootOfTree != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree.left;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = s.pop();</span><br><span class="line">            <span class="comment">//最左元素即表头</span></span><br><span class="line">            <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">                head = pRootOfTree;</span><br><span class="line">                pre = head;</span><br><span class="line">                isFirst = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right = pRootOfTree;</span><br><span class="line">                pRootOfTree.left = pre;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = pRootOfTree.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ79-判断是不是平衡二叉树"><a href="#JZ79-判断是不是平衡二叉树" class="headerlink" title="JZ79 判断是不是平衡二叉树"></a>JZ79 判断是不是平衡二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 dfs</p>
<p><strong>描述</strong></p>
<p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。<br>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树<br>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。<br>样例解释：<br><img src="https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6"></p>
<p>样例二叉树如图，为一颗平衡二叉树<br>注：我们约定空树是平衡二叉树。</p>
<p>数据范围：n≤100,树上节点的 val 值满足 0≤n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入一棵二叉树的根节点</p>
<p>返回值描述：<br>输出一个布尔类型的值</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5,6,7&#125;</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;</code><br>返回值: true</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1: 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.abs(treeDepth(root.left) - treeDepth(root.right)) &lt;= <span class="number">1</span></span><br><span class="line">            &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> treeDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> treeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ8-二叉树的下一个结点"><a href="#JZ8-二叉树的下一个结点" class="headerlink" title="JZ8 二叉树的下一个结点"></a>JZ8 二叉树的下一个结点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的 next 指针。</p>
<p>示例:<br>输入: <code>&#123;8,6,10,5,7,9,11&#125;,8</code><br>返回: 9<br>解析: 这个组装传入的子树根节点，其实就是整颗树，中序遍历 <code>&#123;5,6,7,8,9,10,11&#125;</code>，根节点 8 的下一个节点就是 9，应该返回 <code>&#123;9,10,11&#125;</code>，后台只打印子树的下一个节点，所以只会打印 9，如下图，其实都有指向左右孩子的指针，还有指向父节点的指针，下图没有画出来</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210616/557336_1623845692021/E647707AEF2A4AE2C40F0FCCB549B6A5"></p>
<p>数据范围：节点数满足 1≤n≤50 ，节点上的值满足 1≤val≤100</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;,8</code><br>返回值: 9<br><strong>示例 2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;,6</code><br>返回值: 7<br><strong>示例 3</strong><br>输入: <code>&#123;1,2,#,#,3,#,4&#125;,4</code><br>返回值: 1<br><strong>示例 4</strong><br>输入: <code>&#123;5&#125;,5</code><br>返回值: “null”<br>说明: 不存在，后台打印”null”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 递归中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;TreeLinkNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取根节点</span></span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">root</span> <span class="operator">=</span> pNode;</span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="literal">null</span>) root = root.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序遍历打造nodes</span></span><br><span class="line">        InOrder(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行匹配</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nodes.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">TreeLinkNode</span> <span class="variable">cur</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">            <span class="keyword">if</span>(pNode == cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> nodes.get(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">InOrder</span><span class="params">(TreeLinkNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            InOrder(root.left);</span><br><span class="line">            nodes.add(root);</span><br><span class="line">            InOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ28-对称的二叉树"><a href="#JZ28-对称的二叉树" class="headerlink" title="JZ28 对称的二叉树"></a>JZ28 对称的二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：<br>下面这棵二叉树是对称的<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F"><br>下面这棵二叉树不对称<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372"></p>
<p>数据范围：节点数满足 0≤n≤1000，节点上的值满足 ∣val∣≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>备注：<br>你可以用递归和迭代两种方法解决这个问题</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,2,3,4,4,3&#125;</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>&#123;8,6,9,5,7,7,5&#125;</code><br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursion(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recursion</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 可以两个都为空</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个为空或者节点值不同，必定不对称</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>  || root2 == <span class="literal">null</span> || root1.val != root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每层对应的节点进入递归比较</span></span><br><span class="line">        <span class="keyword">return</span> recursion(root1.left, root2.right) &amp;&amp; recursion(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ78-把二叉树打印成多行"><a href="#JZ78-把二叉树打印成多行" class="headerlink" title="JZ78 把二叉树打印成多行"></a>JZ78 把二叉树打印成多行</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 广度优先搜索(BFS)</p>
<p><strong>描述</strong></p>
<p>给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。<br>例如：<br>给定的二叉树是 <code>&#123;1,2,3,#,#,4,5&#125;</code><br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05"></p>
<p>该二叉树多行打印层序遍历的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1],</span><br><span class="line">[2,3],</span><br><span class="line">[4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>数据范围：二叉树的节点数 0≤n≤1000，0≤val≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>输入描述：<br>给定一个二叉树的根节点</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,#,#,4,5&#125;</code><br>返回值: <code>[[1],[2,3],[4,5]]</code><br><strong>示例 2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>[[8],[6,10],[5,7,9,11]]</code><br><strong>示例 3</strong><br>输入: <code>&#123;1,2,3,4,5&#125;</code><br>返回值: <code>[[1],[2,3],[4,5]]</code><br><strong>示例 4</strong><br>输入: <code>&#123;&#125;</code><br>返回值: <code>[]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法: 用ArrayList做缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        layer.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : layer) &#123;</span><br><span class="line">                values.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    tmp.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    tmp.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(values);</span><br><span class="line">            layer = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ37-序列化二叉树"><a href="#JZ37-序列化二叉树" class="headerlink" title="JZ37 序列化二叉树"></a>JZ37 序列化二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 队列 树</p>
<p><strong>描述</strong></p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p>
<p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p>
<p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果 str，重构二叉树。</p>
<p>例如，可以根据层序遍历的方案序列化，如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E"></p>
<p>层序序列化(即用函数 Serialize 转化) 如上的二叉树转为 <code>&quot;&#123;1,2,3,#,#,6,7&#125;&quot;</code>，再能够调用反序列化(Deserialize) 将 <code>&quot;&#123;1,2,3,#,#,6,7&#125;&quot;</code> 构造成如上的二叉树。</p>
<p>当然你也可以根据满二叉树结点位置的标号规律来序列化，还可以根据先序遍历和中序遍历的结果来序列化。不对序列化之后的字符串进行约束，所以欢迎各种奇思妙想。</p>
<p>数据范围：节点数 n≤100，树上每个节点的值满足 0≤val≤150<br>要求：序列化和反序列化都是空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,#,#,6,7&#125;</code><br>返回值: <code>&#123;1,2,3,#,#,6,7&#125;</code><br>说明: 如题面图<br><strong>示例 2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>&#123;8,6,10,5,7,9,11&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: 前序遍历</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//序列的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//处理序列化的功能函数（递归）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">SerializeFunction</span><span class="params">(TreeNode root, StringBuilder str)</span>&#123;</span><br><span class="line">        <span class="comment">//如果节点为空，表示左子节点或右子节点为空，用#表示</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            str.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        str.append(root.val).append(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        SerializeFunction(root.left, str);</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        SerializeFunction(root.right, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//处理空树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        SerializeFunction(root, res);</span><br><span class="line">        <span class="comment">//把str转换成char</span></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理反序列化的功能函数（递归）</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">DeserializeFunction</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//到达叶节点时，构建完毕，返回继续构建父节点</span></span><br><span class="line">        <span class="comment">//空节点</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(index) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数字转换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遇到分隔符或者结尾</span></span><br><span class="line">        <span class="keyword">while</span>(str.charAt(index) != <span class="string">&#x27;!&#x27;</span> &amp;&amp; index != str.length())&#123;</span><br><span class="line">            val = val * <span class="number">10</span> + ((str.charAt(index)) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="comment">//序列到底了，构建完成</span></span><br><span class="line">        <span class="keyword">if</span>(index == str.length())</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index++;</span><br><span class="line">        <span class="comment">//反序列化与序列化一致，都是前序</span></span><br><span class="line">        root.left = DeserializeFunction(str);</span><br><span class="line">        root.right = DeserializeFunction(str);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Deserialize</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//空序列对应空树</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> DeserializeFunction(str);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ84-二叉树中和为某一值的路径-三"><a href="#JZ84-二叉树中和为某一值的路径-三" class="headerlink" title="JZ84 二叉树中和为某一值的路径(三)"></a>JZ84 二叉树中和为某一值的路径(三)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树 root 和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为 n 3.保证最后返回的路径个数在整形范围内(即路径个数小于 2<sup>31</sup>-1)</p>
<p>数据范围:<br>0&lt;&#x3D;n&lt;&#x3D;1000<br>-10^9&lt;&#x3D;节点值&lt;&#x3D;10^9</p>
<p>假如二叉树 root 为 <code>&#123;1,2,3,4,5,4,3,#,#,-1&#125;</code>，sum&#x3D;6，那么总共如下所示，有 3 条路径符合要求</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211103/301499_1635923010369/C47185D4980F108BC73F790D8D2F6709"></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5,4,3,#,#,-1&#125;,6</code><br>返回值: 3<br>说明: 如图所示，有 3 条路径符合<br><strong>示例 2</strong><br>输入: <code>&#123;0,1&#125;,1</code><br>返回值: 2<br><strong>示例 3</strong><br>输入: <code>&#123;1,#,2,#,3&#125;,3</code><br>返回值: 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: dfs算法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以每个节点作为根查询路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FindPath</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 为空则返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询以某节点为根的路径数</span></span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="comment">// 以其子节点为新根</span></span><br><span class="line">        FindPath(root.left, sum);</span><br><span class="line">        FindPath(root.right, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs查询以某节点为根的路径数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 符合目标值</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点值可以为负数，所以进入子节点继续寻找</span></span><br><span class="line">        dfs(root.left, sum - root.val);</span><br><span class="line">        dfs(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ86-在二叉树中找到两个节点的最近公共祖先"><a href="#JZ86-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="JZ86 在二叉树中找到两个节点的最近公共祖先"></a>JZ86 在二叉树中找到两个节点的最近公共祖先</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的 val 值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。</p>
<p>数据范围：树上节点数满足 1≤n≤10^5, 节点值 val 满足区间 [0,n)<br>要求：时间复杂度 O(n)</p>
<p>注：本题保证二叉树中每个节点的 val 值均不相同。</p>
<p>如当输入 <code>&#123;3,5,1,6,2,0,8,#,#,7,4&#125;,5,1</code> 时，二叉树 <code>&#123;3,5,1,6,2,0,8,#,#,7,4&#125;</code> 如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22"></p>
<p>所以节点值为 5 和节点值为 1 的节点的最近公共祖先节点的节点值为 3，所以对应的输出为 3。<br>节点本身可以视为自己的祖先</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;3,5,1,6,2,0,8,#,#,7,4&#125;,5,1</code><br>返回值: 3<br><strong>示例 2</strong><br>输入: <code>&#123;3,5,1,6,2,0,8,#,#,7,4&#125;,2,7</code><br>返回值: 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法: dfs遍历回溯找到两个目标值的路径，再进行路径对比</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录是否找到o的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;Integer&gt; path1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 求根节点到o1的路径</span></span><br><span class="line">        dfs(root, path1, o1);</span><br><span class="line">        <span class="comment">// 重置flag</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 求根节点到o2的路径</span></span><br><span class="line">        dfs(root, path2, o2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 比较路径，找到最后一个相同点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path1.size() &amp;&amp; i &lt; path2.size(); i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path1.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> path2.get(i);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                res = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; path, <span class="type">int</span> o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag || root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">// 节点的值都不同，可以直接用值比较</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == o) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs遍历查找</span></span><br><span class="line">        dfs(root.left, path, o);</span><br><span class="line">        dfs(root.right, path, o);</span><br><span class="line">        <span class="comment">// 找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ68-二叉搜索树的最近公共祖先"><a href="#JZ68-二叉搜索树的最近公共祖先" class="headerlink" title="JZ68 二叉搜索树的最近公共祖先"></a>JZ68 二叉搜索树的最近公共祖先</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 递归</p>
<p><strong>描述</strong></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<ol>
<li>对于该题的最近的公共祖先定义:对于有根树 T 的两个节点 p、q，最近公共祖先 LCA(T,p,q)表示一个节点 x，满足 x 是 p 和 q 的祖先且 x 的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</li>
<li>二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</li>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ol>
<p>数据范围:<br>3&lt;&#x3D;节点总数&lt;&#x3D;10000<br>0&lt;&#x3D;节点值&lt;&#x3D;10000</p>
<p>如果给定以下搜索二叉树: <code>&#123;7,1,12,0,4,11,14,#,#,3,5&#125;</code>，如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A"></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;7,1,12,0,4,11,14,#,#,3,5&#125;,1,12</code><br>返回值: 7<br>说明: 节点 1 和 节点 12 的最近公共祖先是 7<br><strong>示例 2</strong><br>输入: <code>&#123;7,1,12,0,4,11,14,#,#,3,5&#125;,12,11</code><br>返回值: 12<br>说明: 因为一个节点也可以是它自己的祖先.所以输出 12</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 利用二叉搜索树的性质向下查找即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; cur.val &amp;&amp; q &lt; cur.val) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; cur.val &amp;&amp; q &gt; cur.val) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列-栈"><a href="#队列-栈" class="headerlink" title="队列 &amp; 栈"></a>队列 &amp; 栈</h3><h4 id="JZ9-用两个栈实现队列"><a href="#JZ9-用两个栈实现队列" class="headerlink" title="JZ9 用两个栈实现队列"></a>JZ9 用两个栈实现队列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>用两个栈来实现一个队列，使用 n 个元素来完成 n 次在队列尾部插入整数(push)和 n 次在队列头部删除整数(pop)的功能。 队列中的元素为 int 类型。保证操作合法，即保证 pop 操作时队列内已有元素。</p>
<p>数据范围： n≤1000<br>要求：存储 n 个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)</p>
<p><strong>示例 1</strong></p>
<p>输入: <code>[&quot;PSH1&quot;,&quot;PSH2&quot;,&quot;POP&quot;,&quot;POP&quot;]</code><br>返回值: 1,2<br>说明:<br>“PSH1”:代表将 1 插入队列尾部<br>“PSH2”:代表将 2 插入队列尾部<br>“POP”:代表删除一个元素，先进先出&#x3D;&gt;返回 1<br>“POP”:代表删除一个元素，先进先出&#x3D;&gt;返回 2</p>
<p><strong>示例 2</strong><br>输入: <code>[&quot;PSH2&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;POP&quot;]</code><br>返回值: 2,1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ30-包含-min-函数的栈"><a href="#JZ30-包含-min-函数的栈" class="headerlink" title="JZ30 包含 min 函数的栈"></a>JZ30 包含 min 函数的栈</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p>
<p>此栈包含的方法有：<br>push(value):将 value 压入栈中<br>pop():弹出栈顶元素<br>top():获取栈顶元素<br>min():获取栈中最小元素</p>
<p>数据范围：操作数量满足 0≤n≤300，输入的元素满足 ∣val∣≤10000<br>进阶：栈的各个操作的时间复杂度是 O(1)，空间复杂度是 O(n)</p>
<p>示例:<br>输入: <code>[&quot;PSH-1&quot;,&quot;PSH2&quot;,&quot;MIN&quot;,&quot;TOP&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;TOP&quot;,&quot;MIN&quot;]</code><br>输出: -1,2,1,-1<br>解析:<br>“PSH-1”表示将-1 压入栈中，栈中元素为-1<br>“PSH2”表示将 2 压入栈中，栈中元素为 2，-1<br>“MIN”表示获取此时栈中最小元素&#x3D;&#x3D;&gt;返回-1<br>“TOP”表示获取栈顶元素&#x3D;&#x3D;&gt;返回 2<br>“POP”表示弹出栈顶元素，弹出 2，栈中元素为-1<br>“PSH1”表示将 1 压入栈中，栈中元素为 1，-1<br>“TOP”表示获取栈顶元素&#x3D;&#x3D;&gt;返回 1<br>“MIN”表示获取此时栈中最小元素&#x3D;&#x3D;&gt;返回-1</p>
<p><strong>示例 1</strong><br>输入: <code>[&quot;PSH-1&quot;,&quot;PSH2&quot;,&quot;MIN&quot;,&quot;TOP&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;TOP&quot;,&quot;MIN&quot;]</code><br>返回值: -1,2,1,-1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">// 解法: 维护一个非严格对应的降序最小栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用于栈的push 与 pop</span></span><br><span class="line">    Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 用于存储最小min</span></span><br><span class="line">    Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        s1.push(node);</span><br><span class="line">        <span class="comment">// 空或者新元素小于等于最小值，则入栈</span></span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty() || node &lt;= s2.peek()) &#123;</span><br><span class="line">            s2.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> s1.pop();</span><br><span class="line">        <span class="keyword">if</span> (s2.peek() == v) &#123;</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ31-栈的压入、弹出序列"><a href="#JZ31-栈的压入、弹出序列" class="headerlink" title="JZ31 栈的压入、弹出序列"></a>JZ31 栈的压入、弹出序列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p>
<ol>
<li>0 &lt;&#x3D; pushV.length &#x3D;&#x3D; popV.length &lt;&#x3D;1000</li>
<li>-1000 &lt;&#x3D; pushV[i] &lt;&#x3D; 1000</li>
<li>pushV 的所有数字均不相同</li>
</ol>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,4,5],[4,5,3,2,1]</code><br>返回值: true<br>说明: 可以通过<br>push(1)&#x3D;&gt;push(2)&#x3D;&gt;push(3)&#x3D;&gt;push(4)&#x3D;&gt;pop()&#x3D;&gt;push(5)&#x3D;&gt;pop()&#x3D;&gt;pop()&#x3D;&gt;pop()&#x3D;&gt;pop()<br>这样的顺序得到 <code>[4,5,3,2,1]</code> 这个序列，返回 true<br><strong>示例 2</strong><br>输入: <code>[1,2,3,4,5],[4,3,5,1,2]</code><br>返回值: false<br>说明: 由于是 <code>[1,2,3,4,5]</code> 的压入顺序，<code>[4,3,5,1,2]</code> 的弹出顺序，要求 4，3，5 必须在 1，2 前弹出，且 1，2 不能弹出，但是这样压入的顺序，1 又不能在 2 之前弹出，所以无法形成的，返回 false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 辅助栈模拟出入栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsPopOrder</span><span class="params">(<span class="type">int</span> [] pushA,<span class="type">int</span> [] popA)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pushA.length;</span><br><span class="line">        <span class="comment">// 辅助栈</span></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历入栈的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历出栈的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="comment">// 入栈：栈为空或者栈顶不等于出栈数组</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; (s.isEmpty() || s.peek() != popA[i])) &#123;</span><br><span class="line">                s.push(pushA[j]);</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈顶等于出栈数组</span></span><br><span class="line">            <span class="keyword">if</span> (s.peek() == popA[i]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ73-翻转单词序列"><a href="#JZ73-翻转单词序列" class="headerlink" title="JZ73 翻转单词序列"></a>JZ73 翻转单词序列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串 双指针</p>
<p><strong>描述</strong></p>
<p>牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>数据范围：1≤n≤100<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)，保证没有只包含空格的字符串</p>
<p><strong>示例 1</strong><br>输入: “nowcoder. a am I”<br>返回值: “I am a nowcoder.”<br><strong>示例 2</strong><br>输入: “”<br>返回值: “”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ReverseSentence</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span>[] cs = str.toCharArray();</span><br><span class="line">        <span class="comment">// 翻转句子</span></span><br><span class="line">        reverse(cs, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 以空格为界找到一个单词</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; cs[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; cs[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将单词翻转</span></span><br><span class="line">            reverse(cs, i, j - <span class="number">1</span>);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            swap(cs, l ++, r --);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> cs[l];</span><br><span class="line">        cs[l] = cs[r];</span><br><span class="line">        cs[r] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ59-滑动窗口的最大值"><a href="#JZ59-滑动窗口的最大值" class="headerlink" title="JZ59 滑动窗口的最大值"></a>JZ59 滑动窗口的最大值</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 堆 双指针 队列</p>
<p><strong>描述</strong></p>
<p>给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组 <code>&#123;2,3,4,2,6,2,5,1&#125;</code> 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 <code>&#123;4,4,6,6,6,5&#125;</code>；针对数组 <code>&#123;2,3,4,2,6,2,5,1&#125;</code> 的滑动窗口有以下 6 个：<code>&#123;[2,3,4],2,6,2,5,1&#125;</code>, <code>&#123;2,[3,4,2],6,2,5,1&#125;</code>, <code>&#123;2,3,[4,2,6],2,5,1&#125;</code>, <code>&#123;2,3,4,[2,6,2],5,1&#125;</code>, <code>&#123;2,3,4,2,[6,2,5],1&#125;</code>, <code>&#123;2,3,4,2,6,[2,5,1]&#125;</code>。</p>
<p>数据范围：1≤size≤n≤10000，数组中每个元素的值满足 ∣val∣≤10000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>[2,3,4,2,6,2,5,1],3</code><br>返回值: <code>[4,4,6,6,6,5]</code><br><strong>示例 2</strong><br>输入: <code>[9,10,9,-7,-3,8,2,-6],5</code><br>返回值: <code>[10,10,9,8]</code><br><strong>示例 3</strong><br>输入: <code>[1,2,3,4],3</code><br>返回值: <code>[3,4]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 依次移动窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= num.length - size; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxIndex) &#123;</span><br><span class="line">                maxIndex = findMax(num, i, r);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[r] &gt;= num[maxIndex]) &#123;</span><br><span class="line">                maxIndex = r;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(num[maxIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt;= r; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt;= num[minIndex]) &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用双向队列记递减序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里本不需要这个判断，但是提供的用例和题目中的条件不符</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || size &gt; num.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双向队列</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 遍历第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            addMaxDeque(num, dq, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历后续元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= num.length - size; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; i &gt; dq.peekFirst()) &#123;</span><br><span class="line">                dq.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            addMaxDeque(num, dq, r);</span><br><span class="line">            res.add(num[dq.peekFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addMaxDeque</span><span class="params">(<span class="type">int</span>[] num, ArrayDeque&lt;Integer&gt; dq, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; num[dq.peekLast()] &lt;= num[i]) &#123;</span><br><span class="line">            dq.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><h4 id="JZ53-数字在升序数组中出现的次数"><a href="#JZ53-数字在升序数组中出现的次数" class="headerlink" title="JZ53 数字在升序数组中出现的次数"></a>JZ53 数字在升序数组中出现的次数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组 二分</p>
<p><strong>描述</strong></p>
<p>给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数</p>
<p>数据范围：0≤n≤1000,0≤k≤100，数组中每个元素的值满足 0≤val≤100<br>要求：空间复杂度 O(1)，时间复杂度 O(logn)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,3,3,3,4,5],3</code><br>返回值: 4<br><strong>示例 2</strong><br>输入: <code>[1,3,4,5],6</code><br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1: 二分法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetNumberOfK</span><span class="params">(<span class="type">int</span> [] array , <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(array, k, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt; array.length &amp;&amp; array[i] == array[index]; i ++) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; array[i] == array[index]; i --) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIndex(array, k, l, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIndex(array, k, mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 二分法查找目标值加减0.5的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bisearch</span><span class="params">(<span class="type">int</span>[] data, <span class="type">double</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> data.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分左右界</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &lt; k)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &gt; k)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetNumberOfK</span><span class="params">(<span class="type">int</span> [] array , <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//分别查找k+0.5和k-0.5应该出现的位置，中间的部分就全是k</span></span><br><span class="line">        <span class="keyword">return</span> bisearch(array, k + <span class="number">0.5</span>) - bisearch(array, k - <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ4-二维数组中的查找"><a href="#JZ4-二维数组中的查找" class="headerlink" title="JZ4 二维数组中的查找"></a>JZ4 二维数组中的查找</h4><p>时间限制: 1 秒 空间限制: 64M<br>本题知识点: 数组<br>题目描述<br>在一个二维数组 array 中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1,2,8,9],</span><br><span class="line">[2,4,9,12],</span><br><span class="line">[4,7,10,13],</span><br><span class="line">[6,8,11,15]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target &#x3D; 7，返回 true。<br>给定 target &#x3D; 3，返回 false。</p>
<p>数据范围：矩阵的长宽满足 0≤n,m≤500 ， 矩阵中的值满足 0≤val≤10<sup>9</sup><br>进阶：空间复杂度 O(1)，时间复杂度 O(n+m)</p>
<p><strong>示例 1</strong><br>输入: <code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code><br>返回值: true<br>说明：存在 7，返回 true<br><strong>示例 2</strong><br>输入: <code>1,[[2]]</code><br>返回值: false<br><strong>示例 3</strong><br>输入：<code>3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code><br>返回值：false<br>说明：不存在 3，返回 false</p>
<p>答案:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> [][] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> rows - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[row][col] &gt; target) &#123;</span><br><span class="line">                row --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[row][col] &lt; target) &#123;</span><br><span class="line">                col ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ11-旋转数组的最小数字"><a href="#JZ11-旋转数组的最小数字" class="headerlink" title="JZ11 旋转数组的最小数字"></a>JZ11 旋转数组的最小数字</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 二分</p>
<p><strong>描述</strong></p>
<p>有一个长度为 n 的非降序数组，比如 <code>[1,2,3,4,5]</code>，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了 <code>[3,4,5,1,2]</code>，或者 <code>[4,5,1,2,3]</code>这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000<br>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p>
<p><strong>示例 1</strong><br>输入: <code>[3,4,5,1,2]</code><br>返回值: 1<br><strong>示例 2</strong><br>输入: <code>[3,100,200,3]</code><br>返回值: 3</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1，arr[mid] &gt; target：4 5 6 1 2 3</span></span><br><span class="line"><span class="comment">// arr[mid] 为 6， target为右端点 3， arr[mid] &gt; target, 说明[first ... mid] 都是 &gt;= target 的，因为原始数组是非递减，所以可以确定答案为 [mid+1...last]区间,所以 first = mid + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2，arr[mid] &lt; target:5 6 1 2 3 4</span></span><br><span class="line"><span class="comment">// arr[mid] 为 1， target为右端点 4， arr[mid] &lt; target, 说明答案肯定不在[mid+1...last]，但是arr[mid] 有可能是答案,所以答案在[first, mid]区间，所以last = mid;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况3，arr[mid] == target:</span></span><br><span class="line"><span class="comment">// 如果是 1 0 1 1 1， arr[mid] = target = 1, 显然答案在左边</span></span><br><span class="line"><span class="comment">// 如果是 1 1 1 0 1, arr[mid] = target = 1, 显然答案在右边</span></span><br><span class="line"><span class="comment">// 所以这种情况，不能确定答案在左边还是右边，那么就让last = last - 1;慢慢缩少区间，同时也不会错过答案。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution2(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(array).min().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">            <span class="comment">// 提前退出</span></span><br><span class="line">            <span class="keyword">if</span> (array[first] &lt; array[last]) &#123;</span><br><span class="line">                <span class="keyword">return</span> array[first];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (last - first) / <span class="number">2</span> + first;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; array[last]) &#123;</span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; array[last]) &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ38-字符串的排列"><a href="#JZ38-字符串的排列" class="headerlink" title="JZ38 字符串的排列"></a>JZ38 字符串的排列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串 递归</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。<br>例如输入字符串 ABC,则输出由字符 A,B,C 所能排列出来的所有字符串 ABC,ACB,BAC,BCA,CBA 和 CAB。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB"></p>
<p>数据范围：n &lt; 10<br>要求：空间复杂度 O(n!)，时间复杂度 O(n!)<br>输入描述：<br>输入一个字符串,长度不超过 10,字符只包括大小写字母。</p>
<p><strong>示例 1</strong><br>输入: “ab”<br>返回值: <code>[&quot;ab&quot;,&quot;ba&quot;]</code><br>说明: 返回 <code>[&quot;ba&quot;,&quot;ab&quot;]</code> 也是正确的<br><strong>示例 2</strong><br>输入: “aab”<br>返回值: <code>[&quot;aab&quot;,&quot;aba&quot;,&quot;baa&quot;]</code><br><strong>示例 3</strong><br>输入: “abc”<br>返回值: <code>[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code><br><strong>示例 4</strong><br>输入: “”<br>返回值: <code>[]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">Permutation</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 转换数组</span></span><br><span class="line">       <span class="type">char</span>[] charStr = str.toCharArray();</span><br><span class="line">       <span class="comment">// 按字典序排序</span></span><br><span class="line">       Arrays.sort(charStr);</span><br><span class="line">       <span class="comment">// 标记每个位置的字符是否被使用过</span></span><br><span class="line">       <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[str.length()];</span><br><span class="line">       Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="comment">// 递归获取</span></span><br><span class="line">       recursion(res, charStr, tmp, vis);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(ArrayList&lt;String&gt; res, <span class="type">char</span>[] str, StringBuilder tmp, <span class="type">boolean</span>[] vis)</span> &#123;</span><br><span class="line">        <span class="comment">// 临时字符串满了加入输出</span></span><br><span class="line">        <span class="keyword">if</span> (tmp.length() == str.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">String</span>(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历所有元素选取一个加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i ++) &#123;</span><br><span class="line">            <span class="comment">// 如果该元素已经被加入了，则不需要再加入了</span></span><br><span class="line">            <span class="comment">// 当前的元素str[i]与同一层的前一个元素str[i-1]相同</span></span><br><span class="line">            <span class="keyword">if</span>  (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; str[i - <span class="number">1</span>] == str[i] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记为使用过</span></span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 加入临时字符串</span></span><br><span class="line">            tmp.append(str[i]);</span><br><span class="line">            recursion(res, str, tmp, vis);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            tmp.deleteCharAt(tmp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ44-数字序列中某一位的数字"><a href="#JZ44-数字序列中某一位的数字" class="headerlink" title="JZ44 数字序列中某一位的数字"></a>JZ44 数字序列中某一位的数字</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 模拟</p>
<p><strong>描述</strong></p>
<p>数字以 0123456789101112131415… 的格式作为一个字符序列，在这个序列中第 2 位（从下标 0 开始计算）是 2 ，第 10 位是 1 ，第 13 位是 1 ，以此类题，请你输出第 n 位对应的数字。</p>
<p>数据范围：0&lt;&#x3D;n&lt;&#x3D;10^9</p>
<p><strong>示例 1</strong><br>输入: 0<br>返回值: 0<br><strong>示例 2</strong><br>输入: 2<br>返回值: 2<br><strong>示例 3</strong><br>输入: 10<br>返回值: 1<br><strong>示例 4</strong><br>输入: 13<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 位数减法</span></span><br><span class="line"><span class="comment">// 找规律:</span></span><br><span class="line"><span class="comment">// 小于10的数字一位数，1～9，共9个数字，9位；</span></span><br><span class="line"><span class="comment">// 小于100的数字两位数，10～99，共90个数字，180位；</span></span><br><span class="line"><span class="comment">// 小于1000的数字三位数，100～999，共900个数字，2700位；</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 记录n是几位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录当前位数区间的起始数字: 1,10,100...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录当前区间之前总共有多少位数字</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="comment">// 将n定位在某个位数的区间中</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; sum) &#123;</span><br><span class="line">            n -= sum;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digit ++;</span><br><span class="line">            sum = <span class="number">9</span> * start * digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位n在哪个数字上</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + (start + (n - <span class="number">1</span>) / digit);</span><br><span class="line">        <span class="comment">// 定位n在数字的哪一位上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) % digit;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(num.charAt(index)) - (<span class="type">int</span>)(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="JZ42-连续子数组的最大和"><a href="#JZ42-连续子数组的最大和" class="headerlink" title="JZ42 连续子数组的最大和"></a>JZ42 连续子数组的最大和</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划 贪心</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 的整型数组 array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为 1。求所有子数组的和的最大值。<br>数据范围:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 2 * 10^5</span><br><span class="line">-100 &lt;= a[i] &lt;= 100</span><br></pre></td></tr></table></figure>

<p>要求:时间复杂度为 O(n)，空间复杂度为 O(n)<br>进阶:时间复杂度为 O(n)，空间复杂度为 O(1)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,-2,3,10,-4,7,2,-5]</code><br>返回值: 18<br>说明: 经分析可知，输入数组的子数组 <code>[3,10,-4,7,2]</code> 可以求得最大和为 18<br><strong>示例 2</strong><br>输入: <code>[2]</code><br>返回值: 2<br><strong>示例 3</strong><br>输入: <code>[-10]</code><br>返回值: -10</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: 动态规划，列出状态转移方程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FindGreatestSumOfSubArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> lastMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">            lastMax = Math.max(lastMax + array[i], array[i]);</span><br><span class="line">            <span class="keyword">if</span> (lastMax &gt; max) &#123;</span><br><span class="line">                max = lastMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ85-连续子数组的最大和-二"><a href="#JZ85-连续子数组的最大和-二" class="headerlink" title="JZ85 连续子数组的最大和(二)"></a>JZ85 连续子数组的最大和(二)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 贪心 动态规划 数组 双指针</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 的整型数组 array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。</p>
<ol>
<li>子数组是连续的，比如 <code>[1,3,5,7,9]</code> 的子数组有 <code>[1,3]，[3,5,7]</code> 等等，但是 <code>[1,3,7]</code> 不是子数组</li>
<li>如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个</li>
<li>该题定义的子数组的最小长度为 1，不存在为空的子数组，即不存在[]是某个数组的子数组</li>
<li>返回的数组不计入空间复杂度计算</li>
</ol>
<p>数据范围:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&lt;=n&lt;=10^5</span><br><span class="line">-100 &lt;= a[i] &lt;= 100</span><br></pre></td></tr></table></figure>

<p>要求:时间复杂度 O(n)，空间复杂度 O(n)<br>进阶:时间复杂度 O(n)，空间复杂度 O(1)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,-2,3,10,-4,7,2,-5]</code><br>返回值: <code>[3,10,-4,7,2]</code><br>说明: 经分析可知，输入数组的子数组 <code>[3,10,-4,7,2]</code> 可以求得最大和为 18，故返回 <code>[3,10,-4,7,2]</code><br><strong>示例 2</strong><br>输入: <code>[1]</code><br>返回值: <code>[1]</code><br><strong>示例 3</strong><br>输入: <code>[1,2,-3,4,-1,1,-3,2]</code><br>返回值: <code>[1,2,-3,4,-1,1]</code><br>说明: 经分析可知，最大子数组的和为 4，有 <code>[4],[4,-1,1],[1,2,-3,4],[1,2,-3,4,-1,1]</code>，故返回其中长度最长的 <code>[1,2,-3,4,-1,1]</code><br><strong>示例 4</strong><br>输入: <code>[-2,-1]</code><br>返回值: <code>[-1]</code><br>说明: 子数组最小长度为 1，故返回 <code>[-1]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划，列出状态转移方程，记录对应状态即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] FindGreatestSumOfSubArray (<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> lastMax;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastStartIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> array[i];</span><br><span class="line">            <span class="comment">// 求最长子串，所以这里是&gt;=</span></span><br><span class="line">            <span class="keyword">if</span> (lastMax + num &gt;= num) &#123;</span><br><span class="line">                lastMax += num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastMax = num;</span><br><span class="line">                lastStartIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求最长子串，所以这里是&gt;=</span></span><br><span class="line">            <span class="keyword">if</span> (lastMax &gt;= max) &#123;</span><br><span class="line">                max = lastMax;</span><br><span class="line">                startIndex = lastStartIndex;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(array, startIndex, maxIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ69-跳台阶"><a href="#JZ69-跳台阶" class="headerlink" title="JZ69 跳台阶"></a>JZ69 跳台阶</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 递归 动态规划 记忆化搜索</p>
<p><strong>描述</strong></p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>数据范围：1≤n≤40<br>要求：时间复杂度：O(n)，空间复杂度：O(1)</p>
<p><strong>示例 1</strong><br>输入: 2<br>返回值: 2<br>说明: 青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为 2<br><strong>示例 2</strong><br>输入: 7<br>返回值: 21</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= target; i ++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ10-斐波那契数列"><a href="#JZ10-斐波那契数列" class="headerlink" title="JZ10 斐波那契数列"></a>JZ10 斐波那契数列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组 动态规划 记忆化搜索 快速幂 递归</p>
<p><strong>描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。<br>要求：空间复杂度 O(1)，时间复杂度 O(n) ，本题也有时间复杂度 O(logn) 的解法</p>
<p><strong>示例 1</strong><br>输入: 4<br>返回值: 3<br><strong>示例 2</strong><br>输入: 1<br>返回值: 1<br><strong>示例 3</strong><br>输入: 2<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution1(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans[i] = ans[i-<span class="number">1</span>] + ans[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solution2(n - <span class="number">2</span>) + solution2(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ19-正则表达式匹配"><a href="#JZ19-正则表达式匹配" class="headerlink" title="JZ19 正则表达式匹配"></a>JZ19 正则表达式匹配</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串 动态规划 递归</p>
<p><strong>描述</strong></p>
<p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。 1.模式中的字符’.’表示任意一个字符 2.模式中的字符’</em>‘表示它前面的字符可以出现任意次（包含 0 次）。<br>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>数据范围:<br>1.str 只包含从 a-z 的小写字母。<br>2.pattern 只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。 3. 0≤str.length≤26 4. 0≤pattern.length≤26</p>
<p><strong>示例 1</strong><br>输入: “aaa”,”a<em>a”<br>返回值: true<br>说明: 中间的</em>可以出现任意次的 a，所以可以出现 1 次 a，能匹配上<br><strong>示例 2</strong><br>输入: “aad”,”c<em>a</em>d”<br>返回值: true<br>说明: 因为这里 c 为 0 个，a 被重复一次， _ 表示零个或多个 a。因此可以匹配字符串 “aad”。<br><strong>示例 3</strong><br>输入: “a”,”.<em>“<br>返回值: true<br>说明: “.</em>“ 表示可匹配零个或多个（’_’）任意字符（’.’）<br><strong>示例 4</strong><br>输入: “aaab”,”a<em>a</em>a*c”<br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="comment">// 解法1: java中的正则匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span> <span class="params">(String str, String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> Pattern.matches(pattern, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解法2: 动态规划</span></span><br><span class="line"><span class="comment">// 具体做法：</span></span><br><span class="line"><span class="comment">// step 1：设dp[i][j]表示str前i个字符和pattern前j个字符是否匹配。（需要注意这里的i，j是长度，比对应的字符串下标要多1）</span></span><br><span class="line"><span class="comment">// step 2： （初始条件） 首先，毋庸置疑，两个空串是直接匹配，因此dp[0][0]=truedp[0][0]=truedp[0][0]=true。然后我们假设str字符串为空，那么pattern要怎么才能匹配空串呢？答案是利用&#x27;*&#x27;字符出现0次的特性。遍历pattern字符串，如果遇到&#x27;*&#x27;意味着它前面的字符可以出现0次，要想匹配空串也只能出现0，那就相当于考虑再前一个字符是否能匹配，因此dp[0][i]=dp[0][i−2]dp[0][i] = dp[0][i - 2]dp[0][i]=dp[0][i−2]。</span></span><br><span class="line"><span class="comment">// step 3： （状态转移） 然后分别遍历str与pattern的每个长度，开始寻找状态转移。首先考虑字符不为&#x27;*&#x27;的简单情况，只要遍历到的两个字符相等，或是pattern串中为&#x27;.&#x27;即可匹配，因此最后一位匹配，即查看二者各自前一位是否能完成匹配，即dp[i][j]=dp[i−1][j−1]dp[i][j] = dp[i - 1][j - 1]dp[i][j]=dp[i−1][j−1]。然后考虑&#x27;*&#x27;出现的情况：</span></span><br><span class="line"><span class="comment">// 1. pattern[j - 2] == &#x27;.&#x27; || pattern[j - 2] == str[i - 1]：即pattern前一位能够多匹配一位，可以用&#x27;*&#x27;让它多出现一次或是不出现，因此有转移方程: dp[i][j] = dp[i - 1][j] || dp[i][j - 2]</span></span><br><span class="line"><span class="comment">// 2. 不满足上述条件，只能不匹配，让前一个字符出现0次，dp[i][j] = dp[i][j - 2].</span></span><br><span class="line"><span class="comment">// 原答案: https://blog.nowcoder.net/n/a3d770a390da4683aa6e6a9020d59945</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span> <span class="params">(String str, String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">        <span class="comment">// dp[i][j]表示str前i个字符和pattern前j个字符是否匹配</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 遍历str每个长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n1; i ++) &#123;</span><br><span class="line">            <span class="comment">// 遍历pattern每个长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n2; j ++) &#123;</span><br><span class="line">                <span class="comment">// 空正则的情况</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = i == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 非空的情况下 星号、点号、字符</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当前字符不为*，用.去匹配或者字符直接相同</span></span><br><span class="line">                    <span class="keyword">if</span> (pattern.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (str.charAt(i - <span class="number">1</span>) == pattern.charAt(j - <span class="number">1</span>) || pattern.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 当前字符是*</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若是前一位为.或者前一位可以与这个数字匹配</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (str.charAt(i - <span class="number">1</span>) == pattern.charAt(j - <span class="number">2</span>) || pattern.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ71-跳台阶扩展问题"><a href="#JZ71-跳台阶扩展问题" class="headerlink" title="JZ71 跳台阶扩展问题"></a>JZ71 跳台阶扩展问题</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划 递归 记忆化搜索</p>
<p><strong>描述</strong></p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶(n 为正整数)总共有多少种跳法。</p>
<p>数据范围：1≤n≤20<br>进阶：空间复杂度 O(1) ， 时间复杂度 O(1)</p>
<p><strong>示例 1</strong><br>输入: 3<br>返回值: 4<br><strong>示例 2</strong><br>输入: 1<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题思路：</span></span><br><span class="line"><span class="comment">// 设f[i] 表示 当前跳道第 i 个台阶的方法数。那么f[n]就是所求答案。</span></span><br><span class="line"><span class="comment">// 假设现在已经跳到了第 n 个台阶，那么前一步可以从哪些台阶到达呢？</span></span><br><span class="line"><span class="comment">// 如果上一步跳 1 步到达第 n 个台阶，说明上一步在第 n-1 个台阶。已知跳到第n-1个台阶的方法数为f[n-1]</span></span><br><span class="line"><span class="comment">// 如果上一步跳 2 步到达第 n 个台阶，说明上一步在第 n-2 个台阶。已知跳到第n-2个台阶的方法数为f[n-2]</span></span><br><span class="line"><span class="comment">// 。。。</span></span><br><span class="line"><span class="comment">// 如果上一步跳 n 步到达第 n 个台阶，说明上一步在第 0 个台阶。已知跳到 第0个台阶的方法数为f[0]</span></span><br><span class="line"><span class="comment">// 那么总的方法数就是所有可能的和。也就是f[n] = f[n-1] + f[n-2] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 显然初始条件f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// 所以我们就可以先求f[2]，然后f[3]...f[n-1]， 最后f[n]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++ j) &#123;</span><br><span class="line">                f[i] += f[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 对于方法一中的：f[n] = f[n-1] + f[n-2] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 那么f[n-1] 为多少呢？</span></span><br><span class="line"><span class="comment">// f[n-1] = f[n-2] + f[n-3] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 所以一合并，f[n] = 2*f[n-1]，初始条件f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// 所以可以采用递归，记忆化递归，动态规划，递推。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            b = a &lt;&lt; <span class="number">1</span>; <span class="comment">//  口诀：左移乘2，右移除2</span></span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 这时候，你会发现一个规律：</span></span><br><span class="line"><span class="comment">// f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// f[2] = 2 = 2&lt;&lt;0 = 1&lt;&lt;1</span></span><br><span class="line"><span class="comment">// f[3] = 4 = 2&lt;&lt;1 = 1&lt;&lt;2</span></span><br><span class="line"><span class="comment">// f[4] = 8 = 2&lt;&lt;2 = 1&lt;&lt;3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ70-矩形覆盖"><a href="#JZ70-矩形覆盖" class="headerlink" title="JZ70 矩形覆盖"></a>JZ70 矩形覆盖</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 递归 动态规划</p>
<p><strong>描述</strong></p>
<p>我们可以用 2<em>1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2</em>1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？</p>
<p>数据范围：0≤n≤38<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>注意：约定 n &#x3D;&#x3D; 0 时，输出 0</p>
<p>比如 n&#x3D;3 时，2*3 的矩形块有 3 种不同的覆盖方法(从同一个方向看):</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995"></p>
<p><strong>示例 1</strong><br>输入: 0<br>返回值: 0<br><strong>示例 2</strong><br>输入: 1<br>返回值: 1<br><strong>示例 3</strong><br>输入: 4<br>返回值: 5</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题思路：</span></span><br><span class="line"><span class="comment">// 因为小矩形长宽是2*1，所以每次新增加的一列，如果竖着放对应的情况与 target 为 n-1 时相同；如果横着放，对应的情况与 target 为 n-2 时相同。所以：f[n] = f[n-1] + f[n-2]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rectCover</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= target; i ++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ63-买卖股票的最好时机-一"><a href="#JZ63-买卖股票的最好时机-一" class="headerlink" title="JZ63 买卖股票的最好时机(一)"></a>JZ63 买卖股票的最好时机(一)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划 贪心</p>
<p><strong>描述</strong></p>
<p>假设你有一个数组 prices，长度为 n，其中 <code>prices[i]</code> 是股票在第 i 天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 2.如果不能获取到任何利润，请返回 0 3.假设买入卖出均无手续费</p>
<p>数据范围： 0≤n≤10^5, 0≤val≤10^4</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>[8,9,2,5,4,7,1]</code><br>返回值: 5<br>说明: 在第 3 天(股票价格 &#x3D; 2)的时候买入，在第 6 天(股票价格 &#x3D; 7)的时候卖出，最大利润 &#x3D; 7-2 &#x3D; 5 ，不能选择在第 2 天买入，第 3 天卖出，这样就亏损 7 了；同时，你也不能在买入前卖出股票。<br><strong>示例 2</strong><br>输入: <code>[2,4,1]</code><br>返回值: 2<br><strong>示例 3</strong><br>输入: <code>[3,2,1]</code><br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span> <span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//dp[i][0]表示某一天不持股到该天为止的最大收益，dp[i][1]表示某天持股，到该天为止的最大收益</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//第一天不持股，总收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一天持股，总收益为减去该天的股价</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历后续每天，状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一天不持股，到该天为止的最大收益</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ47-礼物的最大价值"><a href="#JZ47-礼物的最大价值" class="headerlink" title="JZ47 礼物的最大价值"></a>JZ47 礼物的最大价值</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划 数组</p>
<p><strong>描述</strong></p>
<p>在一个 m * n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<br>如输入这样的一个二维数组，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1,3,1],</span><br><span class="line">[1,5,1],</span><br><span class="line">[4,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为 12</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0&lt;grid.length≤200</span><br><span class="line">0&lt;grid[0].length≤200</span><br></pre></td></tr></table></figure>

<p><strong>示例 1</strong><br>输入: <code>[[1,3,1],[1,5,1],[4,2,1]]</code><br>返回值: 12</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span> <span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j ++) &#123;</span><br><span class="line">                <span class="comment">// 取左边或者上面最大值加上当前格子的值</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ48-最长不含重复字符的子字符串"><a href="#JZ48-最长不含重复字符的子字符串" class="headerlink" title="JZ48 最长不含重复字符的子字符串"></a>JZ48 最长不含重复字符的子字符串</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串 哈希 双指针</p>
<p><strong>描述</strong></p>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br>数据范围:<br>s.length≤40000</p>
<p><strong>示例 1</strong><br>输入: “abcabcbb”<br>返回值: 3<br>说明: 因为无重复字符的最长子串是”abc”，所以其长度为 3。<br><strong>示例 2</strong><br>输入: “bbbbb”<br>返回值: 1<br>说明: 因为无重复字符的最长子串是”b”，所以其长度为 1。<br><strong>示例 3</strong><br>输入: “pwwkew”<br>返回值: 3<br>说明: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 哈希表记录窗口内非重复的字符</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置窗口左右边界</span></span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; right &lt; cs.length; right ++) &#123;</span><br><span class="line">            <span class="comment">// 窗口右移进入哈希表统计出现次数</span></span><br><span class="line">            map.merge(cs[right], <span class="number">1</span>, Integer::sum);</span><br><span class="line">            <span class="comment">// 出现次数大于1，则窗口内有重复</span></span><br><span class="line">            <span class="keyword">while</span> (map.get(cs[right]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 窗口左移，同时减去该字符的出现次数</span></span><br><span class="line">                map.merge(cs[left ++], -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 维护子串长度最大值</span></span><br><span class="line">            res = Math.max(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希表记录窗口内非重复的字符及其下标</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i]表示以下标i结尾的字符串最长不含重复子串的长度</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 哈希表中没有，说明不重复</span></span><br><span class="line">            <span class="keyword">if</span>(!mp.containsKey(s.charAt(i - <span class="number">1</span>)))</span><br><span class="line">                <span class="comment">//前一个加1</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 遇到重复字符</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = Math.min(dp[i - <span class="number">1</span>] + <span class="number">1</span>, i - mp.get(s.charAt(i - <span class="number">1</span>)));</span><br><span class="line">            <span class="comment">// 加入哈希表</span></span><br><span class="line">            mp.put(s.charAt(i - <span class="number">1</span>), i);</span><br><span class="line">            <span class="comment">// 维护最大值</span></span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ46-把数字翻译成字符串"><a href="#JZ46-把数字翻译成字符串" class="headerlink" title="JZ46 把数字翻译成字符串"></a>JZ46 把数字翻译成字符串</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划</p>
<p><strong>描述</strong></p>
<p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p>
<p>现在给一串数字，返回有多少种可能的译码结果</p>
<p>数据范围：字符串长度满足 0&lt;n≤90<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: “12”<br>返回值: 2<br>说明: 2 种可能的译码结果（”ab” 或”l”）<br><strong>示例 2</strong><br>输入: “31717126241541717”<br>返回值: 192<br>说明: 192 种可能的译码结果</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划，需要考虑无法编译的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solve</span> <span class="params">(String nums)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 排除0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 辅助数组初始化为1</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= nums.length(); i ++) &#123;</span><br><span class="line">            <span class="comment">// 当0的前面部署1或2时，无法译码，0种</span></span><br><span class="line">            <span class="keyword">if</span> (nums.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在11-19，21-26之间的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nums.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                || (nums.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) &lt; <span class="string">&#x27;7&#x27;</span>)) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="JZ12-矩阵中的路径"><a href="#JZ12-矩阵中的路径" class="headerlink" title="JZ12 矩阵中的路径"></a>JZ12 矩阵中的路径</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: dfs</p>
<p><strong>描述</strong></p>
<p>请设计一个函数，用来判断在一个 n 乘 m 的矩阵中是否存在一条包含某长度为 len 的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如<br>a b c e<br>​s f c s<br>a d e e<br>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br>数据范围：0≤n,m≤20, 1≤len≤25</p>
<p><strong>示例 1</strong><br>输入: <code>[[a,b,c,e],[s,f,c,s],[a,d,e,e]],&quot;abcced&quot;</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>[[a,b,c,e],[s,f,c,s],[a,d,e,e]],&quot;abcb&quot;</code><br>返回值:false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix char字符型二维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPath</span> <span class="params">(<span class="type">char</span>[][] matrix, String word)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (row &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (col &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j ++) &#123;</span><br><span class="line">                <span class="comment">// 记录回溯路径</span></span><br><span class="line">                <span class="type">boolean</span>[][] path = <span class="keyword">new</span> <span class="title class_">boolean</span>[row][col];</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> findPath(matrix, word, path, <span class="number">0</span>, i, j);</span><br><span class="line">                <span class="keyword">if</span> (find) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findPath</span><span class="params">(<span class="type">char</span>[][] matrix, String word, <span class="type">boolean</span>[][] path, <span class="type">int</span> start, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已满足则返回</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断边界</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= matrix.length || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(start);</span><br><span class="line">        <span class="comment">// 判断边界</span></span><br><span class="line">        <span class="keyword">if</span> (path[i][j] || matrix[i][j] != c) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 试探往前走</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> findPath(matrix, word, path, start + <span class="number">1</span>, i, j - <span class="number">1</span>)</span><br><span class="line">                || findPath(matrix, word, path, start + <span class="number">1</span>, i, j + <span class="number">1</span>)</span><br><span class="line">                || findPath(matrix, word, path, start + <span class="number">1</span>, i - <span class="number">1</span>, j)</span><br><span class="line">                || findPath(matrix, word, path, start + <span class="number">1</span>, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// 不满足的时候回退</span></span><br><span class="line">        <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">            path[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ13-机器人的运动范围"><a href="#JZ13-机器人的运动范围" class="headerlink" title="JZ13 机器人的运动范围"></a>JZ13 机器人的运动范围</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 递归</p>
<p><strong>描述</strong></p>
<p>地上有一个 rows 行和 cols 列的方格。坐标从 <code>[0,0]</code> 到 <code>[rows-1,cols-1]</code> 。一个机器人从坐标 <code>[0,0]</code> 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格 <code>[35,37]</code> ，因为 3+5+3+7 &#x3D; 18。但是，它不能进入方格 <code>[35,38]</code> ，因为 3+5+3+8 &#x3D; 19 。请问该机器人能够达到多少个格子？</p>
<p>数据范围：0≤threshold≤15, 1≤rows,cols≤100</p>
<p>进阶：空间复杂度 O(nm) , 时间复杂度 O(nm)</p>
<p><strong>示例 1</strong><br>输入: 1,2,3<br>返回值: 3<br><strong>示例 2</strong><br>输入: 0,1,3<br>返回值: 1<br><strong>示例 3</strong><br>输入: 10,1,100<br>返回值: 29<br>说明: <code>[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[0,10],[0,11],[0,12],[0,13],[0,14],[0,15],[0,16],[0,17],[0,18],[0,19],[0,20],[0,21],[0,22],[0,23],[0,24],[0,25],[0,26],[0,27],[0,28] 这29种，后面的[0,29],[0,30]以及[0,31]等等是无法到达的</code><br><strong>示例 4</strong><br>输入: 5,10,10<br>返回值: 21</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dxy = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] path = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">        dfs(threshold, rows, cols, path, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> theshold, <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">boolean</span>[][] path, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断边界</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否走过</span></span><br><span class="line">        <span class="keyword">if</span> (path[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否能进入该格子</span></span><br><span class="line">        <span class="keyword">if</span> (!canEnter(theshold, i, j)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 path, 并往下走</span></span><br><span class="line">        path[i][j] = <span class="literal">true</span>;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++) &#123;</span><br><span class="line">            dfs(theshold, rows, cols, path, i + dxy[k][<span class="number">0</span>], j + dxy[k][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canEnter</span><span class="params">(<span class="type">int</span> theshold, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitSum(row) + getBitSum(col) &lt;= theshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBitSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="JZ3-数组中重复的数字"><a href="#JZ3-数组中重复的数字" class="headerlink" title="JZ3 数组中重复的数字"></a>JZ3 数组中重复的数字</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组</p>
<p><strong>描述</strong></p>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组<code>[2,3,1,0,2,5,3]</code>，那么对应的输出是2或者3。存在不合法的输入的话输出-1</p>
<p>数据范围：0≤n≤10000<br>进阶：时间复杂度 O(n) ，空间复杂度 O(n) </p>
<p><strong>示例 1</strong><br>输入: <code>[2,3,1,0,2,5,3]</code><br>返回值: 2<br>说明: 2或3都是对的</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">duplicate</span> <span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> tmp.merge(num, <span class="number">1</span>, Integer::sum);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ51-数组中的逆序对"><a href="#JZ51-数组中的逆序对" class="headerlink" title="JZ51 数组中的逆序对"></a>JZ51 数组中的逆序对</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组</p>
<p><strong>描述</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p>
<p>数据范围：对于 50% 的数据, size≤10^4<br>对于 100% 的数据, size≤10^5<br>数组中所有数字的值满足 0≤val≤10^9</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<p>输入描述：题目保证输入的数组中没有的相同的数字</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,4,5,6,7,0]</code><br>返回值: 7<br><strong>示例 2</strong><br>输入: <code>[1,2,3]</code><br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 长度小于2则无逆序对</span></span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 进入归并</span></span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 找分割点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 左子数组</span></span><br><span class="line">            mergeSort(array, left, mid);</span><br><span class="line">            <span class="comment">// 右子数组</span></span><br><span class="line">            mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">// 并</span></span><br><span class="line">            merge(array, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建临时数组，长度为此时两个子数组加起来的长度</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 临时数组的下标起点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存在原数组的起点下标值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 左子数组的起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 右子数组的起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 当左子数组的当前元素小的时候，跳过，无逆序对</span></span><br><span class="line">            <span class="keyword">if</span> (array[l] &lt;= array[r]) &#123;</span><br><span class="line">                <span class="comment">// 放入临时数组</span></span><br><span class="line">                <span class="comment">// 临时数组下标+1</span></span><br><span class="line">                <span class="comment">// 左子数组指针右移</span></span><br><span class="line">                arr[c++] = array[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，此时存在逆序对</span></span><br><span class="line">                <span class="comment">// 放入临时数组</span></span><br><span class="line">                <span class="comment">// 临时数组+1</span></span><br><span class="line">                <span class="comment">// 右子数组的指针右移</span></span><br><span class="line">                arr[c++] = array[r++];</span><br><span class="line">                <span class="comment">// 逆序对的个数为    左子数组的终点- 当前左子数组的当前指针</span></span><br><span class="line">                count += mid + <span class="number">1</span> - l;</span><br><span class="line">                count %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子数组还有元素时，全部放入临时数组</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid)</span><br><span class="line">            arr[c++] = array[l++];</span><br><span class="line">        <span class="comment">// 右子数组还有元素时，全部放入临时数组</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= right)</span><br><span class="line">            arr[c++] = array[r++];</span><br><span class="line">        <span class="comment">// 将临时数组中的元素放入到原数组的指定位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            array[s++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2 暴力解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs2</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> length - <span class="number">2</span>; start &gt;= <span class="number">0</span>; start --) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>; i &lt; length; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[start] &gt; array[i]) &#123;</span><br><span class="line">                    dp ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += dp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (res % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ40-最小的K个数"><a href="#JZ40-最小的K个数" class="headerlink" title="JZ40 最小的K个数"></a>JZ40 最小的K个数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 堆 排序 分治</p>
<p><strong>描述</strong></p>
<p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。<br>数据范围：0≤k,n≤10000，数组中每个数的大小 0≤val≤1000<br>要求：空间复杂度 O(n) ，时间复杂度 O(nlogk)</p>
<p><strong>示例 1</strong><br>输入: <code>[4,5,1,6,2,7,3,8],4 </code><br>返回值: <code>[1,2,3,4]</code><br>说明: 返回最小的4个数即可，返回 <code>[1,3,2,4]</code> 也可以<br><strong>示例 2</strong><br>输入: <code>[1],0</code><br>返回值: <code>[]</code><br><strong>示例 3</strong><br>输入: <code>[0,1,2,1,2],3</code><br>返回值: <code>[0,1,1]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">GetLeastNumbers_Solution</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1, n2) -&gt; n2 - n1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : input) &#123;</span><br><span class="line">            queue.offer(num);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">GetLeastNumbers_Solution</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1, n2) -&gt; n2 - n1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &lt; k) &#123;</span><br><span class="line">                queue.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; queue.peek()) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ41-数据流中的中位数"><a href="#JZ41-数据流中的中位数" class="headerlink" title="JZ41 数据流中的中位数"></a>JZ41 数据流中的中位数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 排序 堆</p>
<p><strong>描述</strong></p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<p>数据范围：数据流中数个数满足 1≤n≤1000, 大小满足 1≤val≤1000<br>进阶： 空间复杂度 O(n), 时间复杂度 O(nlogn) </p>
<p><strong>示例 1</strong><br>输入: <code>[5,2,3,4,1,6,7,0,8]</code><br>返回值: “5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 “<br>说明: 数据流里面不断吐出的是5,2,3…,则得到的平均数分别为5,(5+2)&#x2F;2,3…<br><strong>示例 2</strong><br>输入: <code>[1,1,1]</code><br>返回值: “1.00 1.00 1.00 “</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="comment">// 插入排序法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; val = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(Integer num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历找到插入点</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; val.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= val.get(i)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入相应位置</span></span><br><span class="line">        val.add(i, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">GetMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> val.size();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数个数字</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) val.get(n / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数个数字</span></span><br><span class="line">            <span class="keyword">return</span> (val.get(n / <span class="number">2</span>) + val.get(n / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2</span></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 小顶堆，元素数值都比大顶堆大</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; max = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 大顶堆，元素数值较小 </span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; min = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o2.compareTo(o1)); </span><br><span class="line">    <span class="comment">// 维护两个堆，取两个堆顶部即与中位数相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(Integer num)</span> &#123;</span><br><span class="line">        <span class="comment">// 先加入较小部分</span></span><br><span class="line">        min.offer(num);</span><br><span class="line">        <span class="comment">// 将较小部分的最大值取出，送入到较大部分</span></span><br><span class="line">        max.offer(min.poll());  </span><br><span class="line">        <span class="comment">// 平衡两个堆的数量</span></span><br><span class="line">        <span class="keyword">if</span> (min.size() &lt; max.size()) &#123;</span><br><span class="line">            min.offer(max.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">GetMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (min.size() &gt; max.size()) &#123;</span><br><span class="line">            <span class="comment">//奇数个</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) min.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//偶数个</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) (min.peek() + max.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="JZ65-不用加减乘除做加法"><a href="#JZ65-不用加减乘除做加法" class="headerlink" title="JZ65 不用加减乘除做加法"></a>JZ65 不用加减乘除做加法</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 +、-、*、&#x2F; 四则运算符号。</p>
<p>数据范围：两个数都满足 −10≤n≤1000<br>进阶：空间复杂度 O(1)，时间复杂度 O(1)</p>
<p><strong>示例 1</strong><br>输入: 1,2<br>返回值: 3<br><strong>示例 2</strong><br>输入: 0,0<br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个解法利用了异或运算（^）和与运算（&amp;）来模拟加法的过程</span></span><br><span class="line"><span class="comment">// 循环执行加法操作，直到进位为0。</span></span><br><span class="line"><span class="comment">// 在每一轮循环中，使用异或运算（^）计算a和b的无进位的和，并赋值给a。</span></span><br><span class="line"><span class="comment">// 使用与运算（&amp;）和左移运算（&lt;&lt;）计算a和b的进位值，并赋值给b。</span></span><br><span class="line"><span class="comment">// 重复上述步骤，直到进位为0，即完成了加法操作。</span></span><br><span class="line"><span class="comment">// 返回最终的结果a。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (num1 &amp; num2) &lt;&lt; <span class="number">1</span>; <span class="comment">// 计算进位值</span></span><br><span class="line">            num1 = num1 ^ num2; <span class="comment">// 计算无进位的和</span></span><br><span class="line">            num2 = carry; <span class="comment">// 将进位值赋给b，继续下一轮计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ15-二进制中-1-的个数"><a href="#JZ15-二进制中-1-的个数" class="headerlink" title="JZ15 二进制中 1 的个数"></a>JZ15 二进制中 1 的个数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>输入一个整数 n ，输出该数 32 位二进制表示中 1 的个数。其中负数用补码表示。</p>
<p>数据范围：−2<sup>31</sup>&lt;&#x3D;n&lt;&#x3D;2<sup>31</sup>−1<br>即范围为: −2147483648&lt;&#x3D;n&lt;&#x3D;2147483647</p>
<p><strong>示例 1</strong><br>输入: 10<br>返回值: 2<br>说明: 十进制中 10 的 32 位二进制表示为 0000 0000 0000 0000 0000 0000 0000 1010，其中有两个 1。<br><strong>示例 2</strong><br>输入: -1<br>返回值: 32<br>说明: 负数使用补码表示，-1 的 32 位二进制表示为 1111 1111 1111 1111 1111 1111 1111 1111，其中 32 个 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution1(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解题思路：</span></span><br><span class="line">    <span class="comment">// 对从右向左的第一位1直接判断，遇到0直接略过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (mark != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; mark) != <span class="number">0</span>) &#123;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">            mark &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ16-数值的整数次方"><a href="#JZ16-数值的整数次方" class="headerlink" title="JZ16 数值的整数次方"></a>JZ16 数值的整数次方</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>实现函数 double Power(double base, int exponent)，求 base 的 exponent 次方。</p>
<p>注意： 1.保证 base 和 exponent 不同时为 0。 2.不得使用库函数，同时不需要考虑大数问题 3.有特殊判题，不用考虑小数点后面 0 的位数。</p>
<p>数据范围：|base|≤100，|exponent|≤100,保证最终结果一定满足 |val|≤10<sup>4</sup><br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: 2.00000,3<br>返回值: 8.00000<br><strong>示例 2</strong><br>输入: 2.10000,3<br>返回值: 9.26100<br><strong>示例 3</strong><br>输入: 2.00000,-2<br>返回值: 0.25000<br>说明: 2 的-2 次方等于 1&#x2F;4&#x3D;0.25</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 预处理: b 的 n 次方，当 n 是负数时转换成 1/b 的 n 次方</span></span><br><span class="line"><span class="comment">// 然后暴力解：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            ret *= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 用递归法（快速幂）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q_power(b, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">q_power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> q_power(b, n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">return</span> ret * ret * b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret * ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 用非递归的快速幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> b; <span class="comment">// 记录x^0, x^1, x^2 ...</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ56"><a href="#JZ56" class="headerlink" title="JZ56"></a>JZ56</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 位运算 哈希</p>
<p><strong>描述</strong></p>
<p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>数据范围：数组长度 <code>2≤n≤1000</code>，数组中每个数的大小 <code>0&lt;val≤1000000</code><br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>提示：输出时按非降序排列。</p>
<p><strong>示例 1</strong><br>输入: <code>[1,4,1,6]</code><br>返回值: <code>[4,6]</code><br>说明: 返回的结果中较小的数排在前面<br><strong>示例 2</strong><br>输入: <code>[1,2,3,3,2,9]</code><br>返回值: <code>[1,9]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] FindNumsAppearOnce (<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 首先对所有数字进行异或运算，得到两个只出现一次的数字的异或结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">xorResult</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : array) &#123;</span><br><span class="line">            xorResult ^= num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到异或结果中第一个为 1 的位，该位表示两个只出现一次的数字在该位上不同</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((bit &amp; xorResult) == <span class="number">0</span>) &#123;</span><br><span class="line">            bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据该位是否为 1，将原数组分成两个子数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按非降序排列</span></span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;a, b&#125; : <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;b, a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ64-求1-2-3-…-n"><a href="#JZ64-求1-2-3-…-n" class="headerlink" title="JZ64 求1+2+3+…+n"></a>JZ64 求1+2+3+…+n</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>数据范围： <code>0&lt;n≤200</code><br>进阶： 空间复杂度 O(1) ，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: 5<br>返回值: 15<br><strong>示例 2</strong><br>输入: 1<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过与运算判断n是否为正数，以结束递归</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (n &gt; <span class="number">1</span>) &amp;&amp; ((n += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="JZ29-顺时针打印矩阵"><a href="#JZ29-顺时针打印矩阵" class="headerlink" title="JZ29 顺时针打印矩阵"></a>JZ29 顺时针打印矩阵</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组</p>
<p><strong>描述</strong></p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,3,4],</span><br><span class="line">[5,6,7,8],</span><br><span class="line">[9,10,11,12],</span><br><span class="line">[13,14,15,16]]</span><br></pre></td></tr></table></figure>
<p>则依次打印出数字<br><code>[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]</code><br>数据范围:<br><code>0 &lt;= matrix.length &lt;= 100</code><br><code>0 &lt;= matrix[i].length &lt;= 100</code></p>
<p><strong>示例 1</strong><br>输入: <code>[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]</code><br>返回值: <code>[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]</code><br><strong>示例 2</strong><br>输入: <code>[[1,2,3,1],[4,5,6,1],[4,5,6,1]]</code><br>返回值: <code>[1,2,3,1,1,1,6,5,4,4,5,6] </code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printMatrix</span><span class="params">(<span class="type">int</span> [][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">// 排除空矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 矩阵总行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="comment">// 矩阵总列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 四个边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, bottom = m - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 打印上边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt;= right; j++) &#123;</span><br><span class="line">                res.add(matrix[top][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否需要打印下边界和左边界</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="comment">// 打印下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">                    res.add(matrix[bottom][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印左边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">                    res.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扩展边界</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ61-扑克牌顺子"><a href="#JZ61-扑克牌顺子" class="headerlink" title="JZ61 扑克牌顺子"></a>JZ61 扑克牌顺子</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 模拟</p>
<p><strong>描述</strong></p>
<p>现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。<br>有如下规则：</p>
<ol>
<li>A为1，J为11，Q为12，K为13，A不能视为14</li>
<li>大、小王为 0，0可以看作任意牌</li>
<li>如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。</li>
<li>数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]</li>
</ol>
<p>要求：空间复杂度 O(1)，时间复杂度 O(nlogn)，本题也有时间复杂度 O(n) 的解法<br>输入描述：<br>输入五张扑克牌的值<br>返回值描述：<br>五张扑克牌能否组成顺子。</p>
<p><strong>示例 1</strong><br>输入: <code>[6,0,2,0,4]</code><br>返回值: true<br>说明: 中间的两个0一个看作3，一个看作5 。即：<code>[6,3,2,5,4]</code> 这样这五张牌在 <code>[2,6]</code> 区间连续，输出true<br><strong>示例 2</strong><br>输入: <code>[0,3,2,6,4]</code><br>返回值: true<br><strong>示例 3</strong><br>输入: <code>[1,0,0,1,0]</code><br>返回值: false<br><strong>示例 4</strong><br>输入: [13,12,11,0,1]<br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsContinuous</span><span class="params">(<span class="type">int</span> [] numbers)</span> &#123;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numbers.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> numbers[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (min == <span class="number">0</span> &amp;&amp; p &lt; n) &#123;</span><br><span class="line">            p ++;</span><br><span class="line">            min = numbers[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zeroNum</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> max - min - (n - p) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> p + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == last) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zeroNum &gt;= gap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ67-把字符串转换成整数-atoi"><a href="#JZ67-把字符串转换成整数-atoi" class="headerlink" title="JZ67 把字符串转换成整数(atoi)"></a>JZ67 把字符串转换成整数(atoi)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串</p>
<p><strong>描述</strong></p>
<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。传入的字符串可能有以下部分组成:</p>
<ol>
<li>若干空格</li>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>数字，字母，符号，空格组成的字符串表达式</li>
<li>若干空格</li>
</ol>
<p>转换算法如下:</p>
<ol>
<li>去掉无用的前导空格</li>
<li>第一个非空字符为+或者-号时，作为该整数的正负号，如果没有符号，默认为正数</li>
<li>判断整数的有效部分：<ol>
<li>确定符号位之后，与之后面尽可能多的连续数字组合起来成为有效整数数字，如果没有有效的整数部分，那么直接返回0</li>
<li>将字符串前面的整数部分取出，后面可能会存在存在多余的字符(字母，符号，空格等)，这些字符可以被忽略，它们对于函数不应该造成影响</li>
<li>整数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231的整数应该被调整为 −231 ，大于 231 − 1 的整数应该被调整为 231 − 1</li>
</ol>
</li>
<li>去掉无用的后导空格</li>
</ol>
<p>数据范围:<br>1.0 &lt;&#x3D;字符串长度&lt;&#x3D; 100<br>2.字符串由英文字母（大写和小写）、数字（0-9）、’ ‘、’+’、’-‘ 和 ‘.’ 组成</p>
<p><strong>示例 1</strong><br>输入: “82”<br>返回值: 82<br><strong>示例 2</strong><br>输入: “   -12  “<br>返回值: -12<br>说明: 去掉前后的空格，为-12<br><strong>示例 3</strong><br>输入: “4396 clearlove”<br>返回值: 4396<br>说明: 6后面的字符不属于有效的整数部分，去除，但是返回前面提取的有效部分<br><strong>示例 4</strong><br>输入: “clearlove 4396”<br>返回值: 0<br><strong>示例 5</strong><br>输入: “-987654321111”<br>返回值: -2147483648</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">StrToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理空字符串的情况</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 符号，默认为正数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过前导空格</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length() &amp;&amp; str.charAt(index) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断符号位</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; str.length() &amp;&amp; (str.charAt(index) == <span class="string">&#x27;+&#x27;</span> || str.charAt(index) == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">            sign = (str.charAt(index) == <span class="string">&#x27;-&#x27;</span>) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逐个字符转换为数字，并计算结果</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(index);</span><br><span class="line">            <span class="comment">// 判断是否为合法数字字符</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 非法字符，跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算当前位的数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断是否溢出</span></span><br><span class="line">            <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE / <span class="number">10</span> || (result == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; digit &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新结果</span></span><br><span class="line">            result = result * <span class="number">10</span> + digit;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ20-表示数值的字符串"><a href="#JZ20-表示数值的字符串" class="headerlink" title="JZ20 表示数值的字符串"></a>JZ20 表示数值的字符串</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串</p>
<p><strong>描述</strong></p>
<p>请实现一个函数用来判断字符串str是否表示数值（包括科学计数法的数字，小数和整数）。</p>
<p>科学计数法的数字(按顺序）可以分成以下几个部分:</p>
<ol>
<li>若干空格</li>
<li>一个整数或者小数</li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个整数(可正可负)</li>
<li>若干空格</li>
</ol>
<p>小数（按顺序）可以分成以下几个部分：</p>
<ol>
<li>若干空格</li>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>可能是以下描述格式之一:<ol>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ol>
</li>
<li>若干空格</li>
</ol>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ol>
<li>若干空格</li>
<li>（可选）一个符号字符（’+’ 或 ‘-‘)</li>
<li>至少一位数字</li>
<li>若干空格</li>
</ol>
<p>例如，字符串 <code>[&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;,&quot;-1E-16&quot;]</code> 都表示数值。<br>但是 <code>[&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;,&quot;12e+4.3&quot;]</code> 都不是数值。</p>
<p>提示:<br>1.1 &lt;&#x3D; str.length &lt;&#x3D; 25<br>2.str 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，空格 ‘ ‘ 或者点 ‘.’ 。<br>3.如果怀疑用例是不是能表示为数值的，可以使用python的print(float(str))去查看<br>进阶：时间复杂度 O(n) ，空间复杂度 O(n) </p>
<p><strong>示例 1</strong><br>输入: “123.45e+6”<br>返回值: true<br><strong>示例 2</strong><br>输入: “1.2.3”<br>返回值: false<br>说明:<br><strong>示例 3</strong><br>输入: “.”<br>返回值: false<br><strong>示例 4</strong><br>输入: “    .2  “<br>返回值: true</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法1: 正则表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumeric</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// ^ 表示开头 $ 表示结尾  java中两个\\ 代表一个\</span></span><br><span class="line">        <span class="comment">// * 零次或多次匹配前面的字符或子表达式</span></span><br><span class="line">        <span class="comment">// ？零次或一次匹配前面的字符或子表达式</span></span><br><span class="line">        <span class="comment">// + 一次或多次匹配前面的字符或子表达式</span></span><br><span class="line">        <span class="comment">// [] 字符集。匹配包含的任一字符</span></span><br><span class="line">        <span class="comment">// (?: )匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;^[+-]?(\\d*\\.\\d+|\\d+(\\.\\d*)?)(?:[eE][+-]?\\d+)?$&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Pattern.matches(p, str.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法2</span></span><br><span class="line"><span class="comment"> * 通过定义状态和状态转移规则，逐个字符地检查字符串是否符合数值的规则。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumeric</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] cs = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cs.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过前导空格</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; cs[index] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断符号位</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; len &amp;&amp; (cs[index] == <span class="string">&#x27;+&#x27;</span> || cs[index] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNum</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理数字部分</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; Character.isDigit(cs[index])) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            isNum = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理小数部分</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; len &amp;&amp; cs[index] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 小数点后面可以没有数字</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; len &amp;&amp; Character.isDigit(cs[index])) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                isNum = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理指数部分</span></span><br><span class="line">        <span class="keyword">if</span> (isNum &amp;&amp; index &lt; len &amp;&amp; (cs[index] == <span class="string">&#x27;e&#x27;</span> || cs[index] == <span class="string">&#x27;E&#x27;</span>)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 指数部分可以有符号位</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; len &amp;&amp; (cs[index] == <span class="string">&#x27;+&#x27;</span> || cs[index] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 指数部分必须有数字</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; len &amp;&amp; Character.isDigit(cs[index])) &#123;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; len &amp;&amp; Character.isDigit(cs[index])) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过尾部空格</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; cs[index] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isNum &amp;&amp; index == len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><h4 id="JZ66-构建乘积数组"><a href="#JZ66-构建乘积数组" class="headerlink" title="JZ66 构建乘积数组"></a>JZ66 构建乘积数组</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组</p>
<p><strong>描述</strong></p>
<p>给定一个数组 <code>A[0,1,...,n-1]</code> ,请构建一个数组 <code>B[0,1,...,n-1]</code> ,其中 B 的元素 <code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>（除 <code>A[i]</code> 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 <code>B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2]</code>）<br>对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。</p>
<p>数据范围： 1≤n≤10 ，数组中元素满足 ∣val∣≤10 </p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,4,5]</code><br>返回值: <code>[120,60,40,30,24]</code><br><strong>示例 2</strong><br>输入: <code>[100,50]</code><br>返回值: <code>[50,100]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] multiply(<span class="type">int</span>[] A) &#123;</span><br><span class="line">        <span class="comment">// 初始化数组 B</span></span><br><span class="line">        <span class="type">int</span>[] B = <span class="keyword">new</span> <span class="title class_">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 先乘左边，从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 每多一位由数组B左边的元素多乘一个前面A的元素</span></span><br><span class="line">            B[i] = B[i - <span class="number">1</span>] * A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// temp为右边的累乘</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 再乘右边，从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B[i] *= temp;</span><br><span class="line">            temp *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ50-第一个只出现一次的字符"><a href="#JZ50-第一个只出现一次的字符" class="headerlink" title="JZ50 第一个只出现一次的字符"></a>JZ50 第一个只出现一次的字符</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串</p>
<p><strong>描述</strong></p>
<p>在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<p>数据范围： 0≤n≤10000，且字符串只有字母组成。<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: “google”<br>返回值: 4<br><strong>示例 2</strong><br>输入: “aa”<br>返回值: -1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FirstNotRepeatingChar</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            mp.put(str.charAt(i), mp.getOrDefault(str.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到第一个只出现一次的字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.get(str.charAt(i)) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ5-替换空格"><a href="#JZ5-替换空格" class="headerlink" title="JZ5 替换空格"></a>JZ5 替换空格</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串</p>
<p><strong>描述</strong></p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。</p>
<p>数据范围: 0≤len(s)≤1000 。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。</p>
<p><strong>示例 1</strong><br>输入: “We Are Happy”<br>返回值: “We%20Are%20Happy”<br><strong>示例 2</strong><br>输入: “ “<br>返回值: “%20”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法:2：</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                stringBuilder.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ21-调整数组顺序使奇数位于偶数前面-一"><a href="#JZ21-调整数组顺序使奇数位于偶数前面-一" class="headerlink" title="JZ21 调整数组顺序使奇数位于偶数前面(一)"></a>JZ21 调整数组顺序使奇数位于偶数前面(一)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>数据范围：0≤n≤5000，数组中每个数的值 0≤val≤10000<br>要求：时间复杂度 O(n)，空间复杂度 O(n)<br>进阶：时间复杂度 O(n<sup>2</sup>)，空间复杂度 O(1)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,4]</code><br>返回值: <code>[1,3,2,4]</code><br><strong>示例 2</strong><br>输入: <code>[2,4,6,5,7]</code><br>返回值: <code>[5,7,2,4,6]</code><br><strong>示例 3</strong><br>输入: <code>[1,3,5,6,7]</code><br>返回值: <code>[1,3,5,7,6]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 用stream特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(array).boxed().sorted(Comparator.comparing(Integer::intValue, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 插入排序思想,时间复杂度 O(n^2)，空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">// 记录已经是奇数的位置下标（视作为有序区域），然后向后遍历，一经发现是奇数则进行“插入排序”，然后有序区下标加1。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//使用插入排序的思想</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 首先是对数值长度进行特判</span></span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录已经是奇数的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i ++)&#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="comment">// 如果该值为偶数</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//该值为奇数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span> (k &gt; j) &#123;</span><br><span class="line">                    <span class="comment">//这区间整体向后移动一位</span></span><br><span class="line">                    array[k] = array[k - <span class="number">1</span>];</span><br><span class="line">                    k --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移位之后将对应的值赋值</span></span><br><span class="line">                array[k] = temp;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果数数组</span></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 双指针, 一个处理基数，一个处理偶数，时间复杂度 O(n)，空间复杂度 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 所给数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="comment">// 辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 双指针：left right并初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 循环终止条件：left &lt; len || right &gt;= 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">numLeft</span> <span class="operator">=</span> left, numRight = right; left &lt; len || right &gt;= <span class="number">0</span>; left ++, right --) &#123;</span><br><span class="line">            <span class="comment">// 处理奇数情况</span></span><br><span class="line">            <span class="keyword">if</span> (array[left] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                num[numLeft] = array[left];</span><br><span class="line">                numLeft++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理偶数情况</span></span><br><span class="line">            <span class="keyword">if</span> (array[right] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                num[numRight] = array[right];</span><br><span class="line">                numRight--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ39-数组中出现次数超过一半的数字"><a href="#JZ39-数组中出现次数超过一半的数字" class="headerlink" title="JZ39 数组中出现次数超过一半的数字"></a>JZ39 数组中出现次数超过一半的数字</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 哈希 数组</p>
<p><strong>描述</strong></p>
<p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如输入一个长度为9的数组 <code>[1,2,3,2,2,2,5,4,2]</code> 。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<p>数据范围： n≤50000，数组中元素的值 0≤val≤10000<br>要求：空间复杂度： O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,2,2,2,5,4,2]</code><br>返回值: 2<br><strong>示例 2</strong><br>输入: <code>[3,3,3,3,2,2,2]</code><br>返回值: 3<br><strong>示例 3</strong><br>输入: <code>[1]</code><br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">MoreThanHalfNum_Solution</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : array) &#123;</span><br><span class="line">            map.merge(num, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.entrySet().stream().max(Comparator.comparingInt(e -&gt; e.getValue())).get().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ43-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#JZ43-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="JZ43 整数中1出现的次数（从1到n整数中1出现的次数）"></a>JZ43 整数中1出现的次数（从1到n整数中1出现的次数）</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数<br>例如， 1~13 中包含 1 的数字有 1 、 10 、 11 、 12 、 13 因此共出现 6 次</p>
<p>注意：11 这种情况算两次</p>
<p>数据范围： 1≤n≤30000<br>进阶：空间复杂度 O(1) ，时间复杂度 O(lognn) </p>
<p><strong>示例 1</strong><br>输入: 13<br>返回值: 6<br><strong>示例 2</strong><br>输入: 0<br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="comment">// https://blog.nowcoder.net/n/70f76c242e4b4c0ab0aa25ed64eb3b79</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, bitNum = <span class="number">1</span>, high = n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// cur遍历n每一数位</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="number">0</span> || high != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// case 1: cur == 0</span></span><br><span class="line">                <span class="comment">// cur=0时，高位需要减去一位用于低位进行计算</span></span><br><span class="line">                <span class="comment">// 相当于 count = (high - 1) * bitNum + (99 + 1)</span></span><br><span class="line">                count += high * bitNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// case 2: cur == 1</span></span><br><span class="line">                <span class="comment">// 相当于高位+低位计算结果，即(high * bitNum) + (low + 1)</span></span><br><span class="line">                count += high * bitNum + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// case3: cur &gt; 1</span></span><br><span class="line">                <span class="comment">// 相对于cur=0的情况，就不需要高位减去一位来计算低位的结果数了</span></span><br><span class="line">                <span class="comment">// 相当于(high * bitNum) + (低位数结果数)</span></span><br><span class="line">                count += (high + <span class="number">1</span>) * bitNum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// low、cur、high都像左偏移一个位</span></span><br><span class="line">            <span class="comment">// bitNum表示cur的数位</span></span><br><span class="line">            low += cur * bitNum;</span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">            high = high / <span class="number">10</span>;</span><br><span class="line">            bitNum = bitNum * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ45-把数组排成最小的数"><a href="#JZ45-把数组排成最小的数" class="headerlink" title="JZ45 把数组排成最小的数"></a>JZ45 把数组排成最小的数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组 贪心 排序</p>
<p><strong>描述</strong></p>
<p>输入一个非负整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>例如输入数组 <code>[3，32，321]</code> ，则打印出这三个数字能排成的最小数字为321323。</p>
<ol>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>
</ol>
<p>数据范围:<br>0&lt;&#x3D;len(numbers)&lt;&#x3D;100</p>
<p><strong>示例 1</strong><br>输入: <code>[11,3]</code><br>返回值: “113”<br><strong>示例 2</strong><br>输入: <code>[]</code><br>返回值: “”<br><strong>示例 3</strong><br>输入: <code>[3,32,321]</code><br>返回值: “321323”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">PrintMinNumber</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="literal">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将数字转换为字符串数组</span></span><br><span class="line">        String[] nums = <span class="keyword">new</span> <span class="title class_">String</span>[numbers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            nums[i] = String.valueOf(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自定义比较规则</span></span><br><span class="line">        Comparator&lt;String&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">order1</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">                <span class="type">String</span> <span class="variable">order2</span> <span class="operator">=</span> s2 + s1;</span><br><span class="line">                <span class="keyword">return</span> order1.compareTo(order2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用自定义比较规则对字符串数组进行排序</span></span><br><span class="line">        Arrays.sort(nums, comparator);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拼接排序结果</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String num : nums) &#123;</span><br><span class="line">            sb.append(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ49-丑数"><a href="#JZ49-丑数" class="headerlink" title="JZ49 丑数"></a>JZ49 丑数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学 二分</p>
<p><strong>描述</strong></p>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。</p>
<p>数据范围： 0≤n≤2000<br>要求：空间复杂度 O(n) ， 时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: 7<br>返回值: 8</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetUglyNumber_Solution</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 1 2 3 4 5 6 8</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三个变量，用于指向arr中存放的最大丑数下标，也是 2 3 5 乘的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="comment">// 第一个丑数为 1</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="comment">// 得到下一个丑数，三者中最小的</span></span><br><span class="line">            res[i] = Math.min(res[i2] * <span class="number">2</span>, Math.min(res[i3] * <span class="number">3</span>, res[i5] * <span class="number">5</span>));</span><br><span class="line">            <span class="comment">// 第一次是 2、3、5比较，得到最小的是2</span></span><br><span class="line">            <span class="comment">// 第二次是 4、3、5比较，为什么是4了呢？因为上次2已经乘了一次了，所以接下去可以放的丑数在4、3、5之间</span></span><br><span class="line">            <span class="comment">// 所以开头的三个指针就是来的</span></span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[i2] * <span class="number">2</span>)</span><br><span class="line">                i2++;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[i3] * <span class="number">3</span>)</span><br><span class="line">                i3++;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[i5] * <span class="number">5</span>)</span><br><span class="line">                i5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ74-和为S的连续正数序列"><a href="#JZ74-和为S的连续正数序列" class="headerlink" title="JZ74 和为S的连续正数序列"></a>JZ74 和为S的连续正数序列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 穷举</p>
<p><strong>描述</strong></p>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?</p>
<p>数据范围： 0&lt;n≤100<br>进阶：时间复杂度 O(n)<br>返回值描述：<br>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<p><strong>示例 1</strong><br>输入: 9<br>返回值: <code>[[2,3,4],[4,5]]</code><br><strong>示例 2</strong><br>输入: 0<br>返回值: <code>[]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="type">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">// 返回结果集</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 回溯窗口</span></span><br><span class="line">        LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= sum / <span class="number">2</span> + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nSum == sum &amp;&amp; track.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// 满足条件</span></span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(track));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nSum &gt; sum) &#123; <span class="comment">// 需要回溯窗口</span></span><br><span class="line">                <span class="keyword">while</span> (nSum &gt;= sum) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> track.removeFirst();</span><br><span class="line">                    nSum -= num;</span><br><span class="line">                    <span class="keyword">if</span> (nSum == sum &amp;&amp; track.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// 回溯之后满足条件</span></span><br><span class="line">                        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(track));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把当前数加到窗口</span></span><br><span class="line">            track.add(i);</span><br><span class="line">            nSum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ57-和为S的两个数字"><a href="#JZ57-和为S的两个数字" class="headerlink" title="JZ57 和为S的两个数字"></a>JZ57 和为S的两个数字</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数学 数组 双指针</p>
<p><strong>描述</strong></p>
<p>输入一个升序数组 array 和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，如果无法找出这样的数字，返回一个空数组即可。</p>
<p>数据范围:  0≤len(array)≤10^5, 1≤array[i]≤10^6</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,4,7,11,15],15</code><br>返回值: <code>[4,11]</code><br>说明: 返回 <code>[4,11]</code> 或者 <code>[11,4]</code> 都是可以的<br><strong>示例 2</strong><br>输入: <code>[1,5,11],10</code><br>返回值: <code>[]</code><br>说明: 不存在，返回空数组<br><strong>示例 3</strong><br>输入: <code>[1,2,3,4],5</code><br>返回值: <code>[1,4]</code><br>说明: 返回 <code>[1,4],[4,1],[2,3],[3,2]</code> 都是可以的<br><strong>示例 4</strong><br>输入: <code>[1,2,2,4],4</code><br>返回值: <code>[2,2]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">FindNumbersWithSum</span><span class="params">(<span class="type">int</span> [] array,<span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span> || sum &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> array[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> array[right];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nSum</span> <span class="operator">=</span> leftNum + rightNum;</span><br><span class="line">            <span class="keyword">if</span> (nSum == sum) &#123;</span><br><span class="line">                res.add(leftNum);</span><br><span class="line">                res.add(rightNum);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nSum &gt; sum) &#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ58-左旋转字符串"><a href="#JZ58-左旋转字符串" class="headerlink" title="JZ58 左旋转字符串"></a>JZ58 左旋转字符串</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串</p>
<p><strong>描述</strong></p>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列  S ，请你把其循环左移 K 位后的序列输出。例如，字符序列 S &#x3D; ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc”</p>
<p>数据范围：输入的字符串长度满足 0≤len≤100, 0≤n≤100<br>进阶：空间复杂度 O(n) ，时间复杂度 O(n) </p>
<p><strong>示例 1</strong><br>输入: “abcXYZdef”,3<br>返回值: “XYZdefabc”<br><strong>示例 2</strong><br>输入: “aab”,10<br>返回值: “aba”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">LeftRotateString</span><span class="params">(String str,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要位移</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要位移的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rotateNum</span> <span class="operator">=</span> n % str.length();</span><br><span class="line">        <span class="comment">// 不需要位移</span></span><br><span class="line">        <span class="keyword">if</span> (rotateNum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(rotateNum) + str.substring(<span class="number">0</span>, rotateNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ62-孩子们的游戏-圆圈中最后剩下的数"><a href="#JZ62-孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="JZ62 孩子们的游戏(圆圈中最后剩下的数)"></a>JZ62 孩子们的游戏(圆圈中最后剩下的数)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0… m-1报数….这样下去….直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211008/557336_1633683919444/969B0F1641FC5D27A2F517347991EB78"></p>
<p>数据范围： 1≤m≤10000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: 5,3<br>返回值: 3<br><strong>示例 2</strong><br>输入: 2,3<br>返回值: 1<br>说明: 有2个小朋友编号为0，1，第一次报数报到3的是0号小朋友，0号小朋友出圈，1号小朋友得到礼物<br><strong>示例 3</strong><br>输入: 10,17<br>返回值: 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRemaining</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        lastRemaining = (lastRemaining + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lastRemaining;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ75-字符流中第一个不重复的字符"><a href="#JZ75-字符流中第一个不重复的字符" class="headerlink" title="JZ75 字符流中第一个不重复的字符"></a>JZ75 字符流中第一个不重复的字符</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串</p>
<p><strong>描述</strong></p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g” 。当从该字符流中读出前六个字符 “google” 时，第一个只出现一次的字符是”l”。</p>
<p>数据范围：字符串长度满足 1≤n≤1000 ，字符串中出现的字符一定在 ASCII 码内。<br>进阶：空间复杂度 O(n) ，时间复杂度 O(n) </p>
<p>后台会用以下方式调用 Insert 和 FirstAppearingOnce 函数</p>
<p>string caseout &#x3D; “”;<br>1.读入测试用例字符串casein<br>2.如果对应语言有Init()函数的话，执行Init() 函数<br>3.循环遍历字符串里的每一个字符ch {<br>    Insert(ch);<br>    caseout +&#x3D; FirstAppearingOnce()<br>  }<br>4.输出caseout，进行比较。</p>
<p>返回值描述：<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<p><strong>示例 1</strong><br>输入: “google”<br>返回值: “ggg#ll”<br><strong>示例 2</strong><br>输入: “abcdee”<br>返回值: “aaaaaa”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法： 哈希表+队列</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; chCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Character&gt; singleList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> chCountMap.merge(ch, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            singleList.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">FirstAppearingOnce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (singleList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> singleList.getFirst();</span><br><span class="line">            <span class="keyword">if</span> (chCountMap.get(ch) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">            singleList.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ14-剪绳子"><a href="#JZ14-剪绳子" class="headerlink" title="JZ14 剪绳子"></a>JZ14 剪绳子</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;&#x3D; n ），每段绳子的长度记为 <code>k[1],...,k[m]</code> 。请问 <code>k[1]*k[2]*...*k[m]</code> 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</p>
<p>数据范围： 2≤n≤60<br>进阶：空间复杂度 O(1) ，时间复杂度 O(n)<br>输入描述：<br>输入一个数n，意义见题面。<br>返回值描述：<br>输出答案。</p>
<p><strong>示例 1</strong><br>输入: 8<br>返回值: 18<br>说明: 8 &#x3D; 2 +3 +3 , 2<em>3</em>3&#x3D;18<br><strong>示例 2</strong><br>输入: 2<br>返回值: 1<br>说明: m&gt;1，所以切成两段长度是1的绳子</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cutRope</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组用于存储子问题的最优解</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算子问题的最优解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="comment">// 将绳子剪成 j 和 i-j 两段</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算剪成两段后的长度乘积 (要注意长度为 1-3 的时候不分的乘积更大)</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> Math.max(j, dp[j]) * Math.max(i - j, dp[i - j]);</span><br><span class="line">                <span class="comment">// 更新最优解</span></span><br><span class="line">                dp[i] = Math.max(dp[i], product);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ81-调整数组顺序使奇数位于偶数前面-二"><a href="#JZ81-调整数组顺序使奇数位于偶数前面-二" class="headerlink" title="JZ81 调整数组顺序使奇数位于偶数前面(二)"></a>JZ81 调整数组顺序使奇数位于偶数前面(二)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组 排序</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，但是时间复杂度和空间复杂度必须如下要求。</p>
<p>数据范围： 0≤n≤50000，数组中每个数的值 0≤val≤10000<br>要求：时间复杂度 O(n)，空间复杂度 O(1)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,4]</code><br>返回值: <code>[1,3,2,4]</code><br>说明: <code>[3,1,2,4]</code> 或者 <code>[3,1,4,2]</code> 也是正确答案<br><strong>示例 2</strong><br>输入: <code>[1,3,5,6,7]</code><br>返回值: <code>[1,3,5,7,6]</code><br>说明: <code>[3,1,5,7,6]</code> 等也是正确答案<br><strong>示例 3</strong><br>输入: <code>[1,4,4,3]</code><br>返回值: <code>[1,3,4,4]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArrayTwo (<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; isOddNum(array[left])) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !isOddNum(array[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> array[left];</span><br><span class="line">                array[left] = array[right];</span><br><span class="line">                array[right] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOddNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ83-剪绳子（进阶版）"><a href="#JZ83-剪绳子（进阶版）" class="headerlink" title="JZ83 剪绳子（进阶版）"></a>JZ83 剪绳子（进阶版）</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学 快速幂</p>
<p><strong>描述</strong></p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;&#x3D; n ），每段绳子的长度记为 <code>k[1],...,k[m]</code> 。请问 <code>k[1]*k[2]*...*k[m]</code> 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</p>
<p>由于答案过大，请对 998244353 取模。</p>
<p>数据范围： 2≤n≤10^14</p>
<p>进阶：空间复杂度 O(1) ， 时间复杂度 O(logn)</p>
<p><strong>示例 1</strong><br>输入: 4<br>返回值: 4<br>说明: 拆分成 2 个长度为 2 的绳子，2 * 2 &#x3D; 4<br><strong>示例 2</strong><br>输入: 5<br>返回值: 6<br>说明: 剪成一个长度为 2 的绳子和一个长度为 3 的绳子，答案为2*3&#x3D;6<br><strong>示例 3</strong><br>输入: 874520<br>返回值: 908070737</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">998244353</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">cutRope</span> <span class="params">(<span class="type">long</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">// 不超过3直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> number - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 能整除3</span></span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, number / <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 最后剩余1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 4*3^&#123;n-1&#125;</span></span><br><span class="line">            <span class="keyword">return</span> fast(pow(<span class="number">3</span>, number / <span class="number">3</span> - <span class="number">1</span>), <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 最后剩余2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 2*3^n</span></span><br><span class="line">            <span class="keyword">return</span> fast(pow(<span class="number">3</span>, number / <span class="number">3</span>), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速幂</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可以再往上乘一个</span></span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1L</span>) != <span class="number">0</span>)</span><br><span class="line">                res = fast(res, x);</span><br><span class="line">            <span class="comment">// 叠加</span></span><br><span class="line">            x = fast(x, x);</span><br><span class="line">            <span class="comment">// 减少乘次数</span></span><br><span class="line">            y = y &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速乘法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">fast</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        x %= mod;</span><br><span class="line">        y %= mod;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1L</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 加法代替乘法，防止越界</span></span><br><span class="line">                res += x;</span><br><span class="line">                <span class="keyword">if</span> (res &gt;= mod)</span><br><span class="line">                    res -= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            y = y &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            x = x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= mod)</span><br><span class="line">                x -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ17-打印从1到最大的n位数"><a href="#JZ17-打印从1到最大的n位数" class="headerlink" title="JZ17 打印从1到最大的n位数"></a>JZ17 打印从1到最大的n位数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组</p>
<p><strong>描述</strong></p>
<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<ol>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数，0 &lt; n &lt;&#x3D; 5</li>
</ol>
<p><strong>示例 1</strong><br>输入: 1<br>返回值: <code>[1,2,3,4,5,6,7,8,9]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers (<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            end *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[end - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">            res[i - <span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="华为机试"><a href="#华为机试" class="headerlink" title="华为机试"></a>华为机试</h2><h3 id="较难"><a href="#较难" class="headerlink" title="较难"></a>较难</h3><h4 id="HJ3-明明的随机数"><a href="#HJ3-明明的随机数" class="headerlink" title="HJ3 明明的随机数"></a>HJ3 明明的随机数</h4><p>时间限制: 1 秒<br>空间限制: 32M<br>知识点: 数组</p>
<p><strong>描述</strong><br>明明生成了 N 个 1 到 500 之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。</p>
<p>数据范围： 1≤n≤1000，输入的数字大小满足 1≤val≤500</p>
<p><strong>输入描述：</strong><br>第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的”示例”。</p>
<p><strong>输出描述：</strong><br>输出多行，表示输入数据处理后的结果</p>
<p><strong>示例 1</strong><br>输入:<br>3<br>2<br>2<br>1<br>返回值:<br>1<br>2<br>说明:<br>输入解释：<br>第一个数字是 3，也即这个小样例的 N&#x3D;3，说明用计算机生成了 3 个 1 到 500 之间的随机整数，接下来每行一个随机数字，共 3 行，也即这 3 个随机数字为：<br>2<br>2<br>1<br>所以样例的输出为：<br>1<br>2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            numSet.add(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; numList = numSet.stream().sorted().collect(Collectors.toList());</span><br><span class="line">        numList.forEach(num -&gt; &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//获取个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//创建TreeSet进行去重排序</span></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i &lt; num ;i++)&#123;</span><br><span class="line">            set.add(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><h4 id="HJ28-素数伴侣"><a href="#HJ28-素数伴侣" class="headerlink" title="HJ28 素数伴侣"></a>HJ28 素数伴侣</h4><p>时间限制: 1 秒<br>空间限制: 32M<br>知识点: 查找 排序</p>
<p><strong>描述</strong></p>
<p>题目描述<br>若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如 2 和 5、6 和 13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的 N （ N 为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有 4 个正整数：2，5，6，13，如果将 5 和 6 分为一组中只能得到一组“素数伴侣”，而将 2 和 5、6 和 13 编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。</p>
<p>输入:<br>有一个正偶数 n ，表示待挑选的自然数的个数。后面给出 n 个具体的数字。</p>
<p>输出:<br>输出一个整数 K ，表示你求得的“最佳方案”组成“素数伴侣”的对数。</p>
<p>数据范围：1≤n≤100，输入的数据大小满足 2≤val≤30000</p>
<p><strong>输入描述：</strong><br>输入说明<br>1 输入一个正偶数 n<br>2 输入 n 个整数</p>
<p><strong>输出描述：</strong><br>求得的“最佳方案”组成“素数伴侣”的对数。</p>
<p><strong>示例 1</strong><br>输入: 4<br>2 5 6 13<br>返回值: 2<br><strong>示例 2</strong><br>输入: 2<br>3 6<br>返回值: 0<br><strong>示例 3</strong><br>输入: 2<br>3 6<br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小技巧！！！素数不是偶数，那么和是素数的话就是奇数+偶数</span></span><br><span class="line">    <span class="comment">// 那么可以分成两堆,一堆偶数，一堆奇数</span></span><br><span class="line">    <span class="comment">// 匈牙利算法，先到先得，能让就让</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">            <span class="comment">// 标准输入</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="comment">// 用于记录输入的n个整数</span></span><br><span class="line">            <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="comment">// 用于存储所有的奇数</span></span><br><span class="line">            ArrayList&lt;Integer&gt; odds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 用于存储所有的偶数</span></span><br><span class="line">            ArrayList&lt;Integer&gt; evens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    odds.add(num);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    evens.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下标对应偶数的下标，值对应这个偶数的伴侣</span></span><br><span class="line">            <span class="type">int</span>[] evenMatch = <span class="keyword">new</span> <span class="title class_">int</span>[evens.size()];</span><br><span class="line">            <span class="comment">// 记录伴侣的对数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; odds.size(); i ++) &#123;</span><br><span class="line">                <span class="comment">// 用于标记对应的偶数是否查找过</span></span><br><span class="line">                <span class="type">boolean</span>[] evenUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[evens.size()];</span><br><span class="line">                <span class="comment">// 如果匹配上，则计数加1</span></span><br><span class="line">                <span class="keyword">if</span> (find(odds.get(i), evens, evenMatch, evenUsed)) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断奇数x能否找到伴侣</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> odd, ArrayList&lt;Integer&gt; evens, <span class="type">int</span>[] evenMatch, <span class="type">boolean</span>[] evenUsed)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; evens.size(); i ++) &#123;</span><br><span class="line">            <span class="comment">// 该位置偶数能与x组成素数伴侣，并且没被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (isPrime(odd + evens.get(i)) &amp;&amp; !evenUsed[i]) &#123;</span><br><span class="line">                evenUsed[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 如果第i个偶数没有伴侣，或者第i个偶数原来有伴侣，并且该伴侣能够重新找到伴侣的话(这里有递归调用)</span></span><br><span class="line">                <span class="comment">// 则奇数x可以设置为第i个偶数的伴侣</span></span><br><span class="line">                <span class="comment">// 这里采用了匈牙利算法，能让则让</span></span><br><span class="line">                <span class="keyword">if</span> (evenMatch[i] == <span class="number">0</span> || find(evenMatch[i], evens, evenMatch, evenUsed)) &#123;</span><br><span class="line">                    evenMatch[i] = odd;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完偶数都没有可以与传入奇数做伴侣的，该奇数只能孤独终老了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= num; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HJ44-Sudoku"><a href="#HJ44-Sudoku" class="headerlink" title="HJ44 Sudoku"></a>HJ44 Sudoku</h4><p>时间限制: 1 秒<br>空间限制: 32M<br>知识点: 思维 基础数学 搜索</p>
<p><strong>描述</strong><br>问题描述：数独（Sudoku）是一款大众喜爱的数字逻辑游戏。玩家需要根据 9X9 盘面上的已知数字，推算出所有剩余空格的数字，并且满足每一行、每一列、每一个 3X3 粗线宫内的数字均含 1-9，并且不重复。</p>
<p>数据范围：输入一个 9*9 的矩阵</p>
<p><strong>输入描述：</strong><br>包含已知数字的 9X9 盘面数组 [空缺位以数字 0 表示]</p>
<p><strong>输出描述：</strong><br>完整的 9X9 盘面数组</p>
<p><strong>示例 1</strong><br>输入:<br>0 9 2 4 8 1 7 6 3<br>4 1 3 7 6 2 9 8 5<br>8 6 7 3 5 9 4 1 2<br>6 2 4 1 9 5 3 7 8<br>7 5 9 8 4 3 1 2 6<br>1 3 8 6 2 7 5 9 4<br>2 7 1 5 3 8 6 4 9<br>3 8 6 9 1 4 2 5 7<br>0 4 5 2 7 6 8 3 1<br>返回值:<br>5 9 2 4 8 1 7 6 3<br>4 1 3 7 6 2 9 8 5<br>8 6 7 3 5 9 4 1 2<br>6 2 4 1 9 5 3 7 8<br>7 5 9 8 4 3 1 2 6<br>1 3 8 6 2 7 5 9 4<br>2 7 1 5 3 8 6 4 9<br>3 8 6 9 1 4 2 5 7<br>9 4 5 2 7 6 8 3 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从左上角开始去遍历这个数独。</span></span><br><span class="line"><span class="comment">// 对于没有填入的格子（即格子数值为0），我们去枚举1～9每个数字填入，然后根据数独的性质（同行、同列、同一个九宫格不能有相同数字）去判断填入。</span></span><br><span class="line"><span class="comment">// 如果可以成功填完所有格子那么就是找到了答案。找到答案后可以用一个bool变量，然后注意在回溯的地方根据这个变量及时的return，防止已经找到答案后又回溯为0。</span></span><br><span class="line"><span class="comment">// 对于初始化就有值的格子，我们往右走（列数值加一），那么因为一行只有9个，所以当列走到头的时候，列的值变成0，行的值加1（其实就是换到了下一行的开头）。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">            <span class="comment">// 初始化数独</span></span><br><span class="line">            <span class="type">int</span>[][] sd = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++) &#123;</span><br><span class="line">                    sd[i][j] = sc.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 填充数独</span></span><br><span class="line">            dfs(sd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印数独</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++) &#123;</span><br><span class="line">                    System.out.print(sd[i][j]);</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] sd, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">9</span>; k ++) &#123;</span><br><span class="line">                <span class="comment">// check后满足</span></span><br><span class="line">                <span class="keyword">if</span> (check(sd, i, j, k)) &#123;</span><br><span class="line">                    sd[i][j] = k;</span><br><span class="line">                    <span class="comment">// 已经找到答案了，直接return</span></span><br><span class="line">                    <span class="keyword">if</span> (dfs(sd, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没找到答案，回溯</span></span><br><span class="line">                    sd[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(sd, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[][] sd, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 同行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sd[i][k] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sd[k][j] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同九宫格</span></span><br><span class="line">        <span class="comment">// 九宫格行的起点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">limitRow</span> <span class="operator">=</span> i / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 九宫格列的起点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">limitCol</span> <span class="operator">=</span> j / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> limitRow; k &lt; limitRow + <span class="number">3</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> limitCol; l &lt; limitCol + <span class="number">3</span>; l ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sd[k][l] == val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/coding-interviews">https://www.nowcoder.com/ta/coding-interviews</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problemset/top-100-liked-questions/">https://leetcode.com/problemset/top-100-liked-questions/</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/2018/11/26/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/" rel="prev" title="前端笔记">
                  <i class="fa fa-angle-left"></i> 前端笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/2019/04/17/tool-filetime-modify/" rel="next" title="修改文件、文件夹的 —— 创建、修改、访问时间">
                  修改文件、文件夹的 —— 创建、修改、访问时间 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Apomelo</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.19.1/algoliasearch-lite.umd.js" integrity="sha256-qzlNbRtZWHoUV5I2mI2t9QR7oYXlS9oNctX+0pECXI0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.8/instantsearch.production.min.js" integrity="sha256-xUys6KCuRGBxFaRaYZlWulRUjY48XFv6/Q2s0mb1dmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"N5VN0ybf5xGuqDFhjzC5RlRL-MdYXbMMI","app_key":"ru1RlOeEotFp87wLFIHucgVu","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
