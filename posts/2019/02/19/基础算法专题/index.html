<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"apomelo.cc","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"A3LWYBODE0","apiKey":"c40595ca0a82310430032a8bc32214a2","indexName":"apomelo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="正文最近发现自己基础算法方面还有些欠缺。虽然之前也看过数据结构、算法导论、计算机网络等等一些基础书籍，也都理解基础算法和数据结构，但因为没有每道都手写过，所以当真正去实现时还需要去查阅参考资料。由此，下定决心弥补这些不足。基础算法在工作中对业务理解、代码编写并没有非常显著的提升，但是个人觉得这些影响是潜在的，它会潜在的影响你的思考和解决方案。总之，基础夯实终归是没错的。 目前较为推荐的有牛客的剑指">
<meta property="og:type" content="article">
<meta property="og:title" content="基础算法专题">
<meta property="og:url" content="https://apomelo.cc/posts/2019/02/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/index.html">
<meta property="og:site_name" content="Apomelo - 追逐">
<meta property="og:description" content="正文最近发现自己基础算法方面还有些欠缺。虽然之前也看过数据结构、算法导论、计算机网络等等一些基础书籍，也都理解基础算法和数据结构，但因为没有每道都手写过，所以当真正去实现时还需要去查阅参考资料。由此，下定决心弥补这些不足。基础算法在工作中对业务理解、代码编写并没有非常显著的提升，但是个人觉得这些影响是潜在的，它会潜在的影响你的思考和解决方案。总之，基础夯实终归是没错的。 目前较为推荐的有牛客的剑指">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210616/557336_1623831920130/2CD1CC917CD1875FF9CD391C2924DF09">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210616/557336_1623836735191/971325772A17A314D3C44EBCDB6E7209">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211027/557336_1635320187489/B1C70B05B2BA3AAA854EE032F2A8D826">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210625/889362376_1624613381635/984D3CF58361D4880F35C93DBDB46F37">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211029/557336_1635477973725/6C502E0240CAC668843969AFF396B5E4">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211031/557336_1635645087543/44496AC711FE9478BABD9207180C3423">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210929/557336_1632915294911/0A4B8F161306A7054899D42C0C6937FD">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210616/557336_1623845692021/E647707AEF2A4AE2C40F0FCCB549B6A5">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211103/301499_1635923010369/C47185D4980F108BC73F790D8D2F6709">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995">
<meta property="article:published_time" content="2019-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2019-04-22T16:00:00.000Z">
<meta property="article:author" content="Apomelo">
<meta property="article:tag" content="java">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="专题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uploadfiles.nowcoder.com/images/20210616/557336_1623831920130/2CD1CC917CD1875FF9CD391C2924DF09">


<link rel="canonical" href="https://apomelo.cc/posts/2019/02/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://apomelo.cc/posts/2019/02/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/","path":"posts/2019/02/19/基础算法专题/","title":"基础算法专题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>基础算法专题 | Apomelo - 追逐</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2KQDESYMZF"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2KQDESYMZF","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?6c01cfc90b27c8f2cf8c97e38b2f117c"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Apomelo - 追逐</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">1.</span> <span class="nav-text">正文</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%9B%E5%AE%A2"><span class="nav-number">2.</span> <span class="nav-text">牛客</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer"><span class="nav-number">2.1.</span> <span class="nav-text">剑指 offer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">JZ6 从尾到头打印链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">JZ24 反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">JZ25 合并两个排序的链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">JZ52 两个链表的第一个公共结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">JZ23 链表中环的入口结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8E-k-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">JZ22 链表中倒数最后 k 个结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">JZ35 复杂链表的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ76-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">JZ76 删除链表中重复的结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">JZ18 删除链表的节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">2.1.2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ55-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">JZ55 二叉树的深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ77-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">JZ77 按之字形顺序打印二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">JZ54 二叉搜索树的第 k 个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">JZ7 重建二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">JZ26 树的子结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">2.1.2.6.</span> <span class="nav-text">JZ27 二叉树的镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ32-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.7.</span> <span class="nav-text">JZ32 从上往下打印二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-number">2.1.2.8.</span> <span class="nav-text">JZ33 二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ82-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%80"><span class="nav-number">2.1.2.9.</span> <span class="nav-text">JZ82 二叉树中和为某一值的路径(一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%BA%8C"><span class="nav-number">2.1.2.10.</span> <span class="nav-text">JZ34 二叉树中和为某一值的路径(二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.11.</span> <span class="nav-text">JZ36 二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ79-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.12.</span> <span class="nav-text">JZ79 判断是不是平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.2.13.</span> <span class="nav-text">JZ8 二叉树的下一个结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.14.</span> <span class="nav-text">JZ28 对称的二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ78-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C"><span class="nav-number">2.1.2.15.</span> <span class="nav-text">JZ78 把二叉树打印成多行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.16.</span> <span class="nav-text">JZ37 序列化二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ84-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%89"><span class="nav-number">2.1.2.17.</span> <span class="nav-text">JZ84 二叉树中和为某一值的路径(三)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ86-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.1.2.18.</span> <span class="nav-text">JZ86 在二叉树中找到两个节点的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ68-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.1.2.19.</span> <span class="nav-text">JZ68 二叉搜索树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97-amp-%E6%A0%88"><span class="nav-number">2.1.3.</span> <span class="nav-text">队列 &amp; 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">JZ9 用两个栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ30-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">JZ30 包含 min 函数的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">JZ31 栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ73-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">JZ73 翻转单词序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">JZ59 滑动窗口的最大值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.4.</span> <span class="nav-text">搜索算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ53-%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">JZ53 数字在升序数组中出现的次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">JZ4 二维数组中的查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">JZ11 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">JZ38 字符串的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">2.1.4.5.</span> <span class="nav-text">JZ44 数字序列中某一位的数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.1.5.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">JZ42 连续子数组的最大和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ85-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-%E4%BA%8C"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">JZ85 连续子数组的最大和(二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ69-%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">JZ69 跳台阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">JZ10 斐波那契数列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">2.1.5.5.</span> <span class="nav-text">JZ19 正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ71-%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.5.6.</span> <span class="nav-text">JZ71 跳台阶扩展问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ70-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="nav-number">2.1.5.7.</span> <span class="nav-text">JZ70 矩形覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ63-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA-%E4%B8%80"><span class="nav-number">2.1.5.8.</span> <span class="nav-text">JZ63 买卖股票的最好时机(一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">2.1.5.9.</span> <span class="nav-text">JZ47 礼物的最大价值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.5.10.</span> <span class="nav-text">JZ48 最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.5.11.</span> <span class="nav-text">JZ46 把数字翻译成字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">2.1.6.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ12"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">JZ12</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ13"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">JZ13</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.7.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ3"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">JZ3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ51"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">JZ51</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ40"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">JZ40</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ41"><span class="nav-number">2.1.7.4.</span> <span class="nav-text">JZ41</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">2.1.8.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ65"><span class="nav-number">2.1.8.1.</span> <span class="nav-text">JZ65</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">2.1.8.2.</span> <span class="nav-text">JZ15 二进制中 1 的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">2.1.8.3.</span> <span class="nav-text">JZ16 数值的整数次方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ56"><span class="nav-number">2.1.8.4.</span> <span class="nav-text">JZ56</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ64"><span class="nav-number">2.1.8.5.</span> <span class="nav-text">JZ64</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F"><span class="nav-number">2.1.9.</span> <span class="nav-text">模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ29"><span class="nav-number">2.1.9.1.</span> <span class="nav-text">JZ29</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ61"><span class="nav-number">2.1.9.2.</span> <span class="nav-text">JZ61</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ67"><span class="nav-number">2.1.9.3.</span> <span class="nav-text">JZ67</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ20"><span class="nav-number">2.1.9.4.</span> <span class="nav-text">JZ20</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.10.</span> <span class="nav-text">其他算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">JZ5 替换空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2-%E4%B8%80"><span class="nav-number">2.1.10.2.</span> <span class="nav-text">JZ21 调整数组顺序使奇数位于偶数前面(一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JZ"><span class="nav-number">2.1.10.3.</span> <span class="nav-text">JZ</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95"><span class="nav-number">2.2.</span> <span class="nav-text">华为机试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%83%E9%9A%BE"><span class="nav-number">2.2.1.</span> <span class="nav-text">较难</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HJ3-%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">HJ3 明明的随机数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%B0%E9%9A%BE"><span class="nav-number">2.2.2.</span> <span class="nav-text">困难</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HJ28-%E7%B4%A0%E6%95%B0%E4%BC%B4%E4%BE%A3"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">HJ28 素数伴侣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HJ44-Sudoku"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">HJ44 Sudoku</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Apomelo</p>
  <div class="site-description" itemprop="description">我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/apomelo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;apomelo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:apomeloc@gmail.com" title="E-Mail → mailto:apomeloc@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/02/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="基础算法专题 | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基础算法专题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-19T00:00:00+08:00">2019-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-04-23 00:00:00" itemprop="dateModified" datetime="2019-04-23T00:00:00+08:00">2019-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/02/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="post-meta-item leancloud_visitors" data-flag-title="基础算法专题" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>最近发现自己基础算法方面还有些欠缺。虽然之前也看过数据结构、算法导论、计算机网络等等一些基础书籍，也都理解基础算法和数据结构，但因为没有每道都手写过，所以当真正去实现时还需要去查阅参考资料。由此，下定决心弥补这些不足。基础算法在工作中对业务理解、代码编写并没有非常显著的提升，但是个人觉得这些影响是潜在的，它会潜在的影响你的思考和解决方案。总之，基础夯实终归是没错的。</p>
<p>目前较为推荐的有牛客的剑指 offer、LeetCode 的 Top 100 Liked Questions。个人更推荐 LeetCode，但是牛客有手机 App，如果想在上下班路上刷一刷，可以选择牛客。我也是因此选择先刷牛客，下面是相关的题目和个人通过编译的答案，不定期更新，如答案中有错误之处烦请指出。</p>
<h1 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h1><h2 id="剑指-offer"><a href="#剑指-offer" class="headerlink" title="剑指 offer"></a>剑指 offer</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="JZ6-从尾到头打印链表"><a href="#JZ6-从尾到头打印链表" class="headerlink" title="JZ6 从尾到头打印链表"></a>JZ6 从尾到头打印链表</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p>
<p>如输入 <code>&#123;1,2,3&#125;</code> 的链表，返回一个数组为 <code>[3,2,1]</code></p>
<p>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3&#125;</code><br>返回值: <code>[3,2,1]</code><br><strong>示例 2</strong><br>输入: {67,0,24,58}<br>返回值: [58,24,0,67]</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1:</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (listNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(listNode);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            result.add(stack.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ24-反转链表"><a href="#JZ24-反转链表" class="headerlink" title="JZ24 反转链表"></a>JZ24 反转链表</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>给定一个单链表的头结点 pHead，长度为 n，反转该链表后，返回新链表的表头。</p>
<p>数据范围: n≤1000<br>要求: 空间复杂度 O(1)，时间复杂度 O(n)。</p>
<p>如当输入链表 <code>&#123;1,2,3&#125;</code> 时，<br>经反转后，原链表变为 <code>&#123;3,2,1&#125;</code>，所以对应的输出为 <code>&#123;3,2,1&#125;</code>。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3&#125;</code><br>返回值: <code>&#123;3,2,1&#125;</code><br><strong>示例 2</strong><br>输入: <code>&#123;&#125;</code><br>返回值: <code>&#123;&#125;</code><br>说明: 空链表则输出空</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ25-合并两个排序的链表"><a href="#JZ25-合并两个排序的链表" class="headerlink" title="JZ25 合并两个排序的链表"></a>JZ25 合并两个排序的链表</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入两个递增的链表，单个链表的长度为 n，合并这两个链表并使新链表中的节点仍然是递增排序的。<br>数据范围: 0≤n≤1000，−1000≤ 节点值 ≤1000<br>要求: 空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>如输入 <code>&#123;1,3,5&#125;,&#123;2,4,6&#125;</code> 时，合并后的链表为 <code>&#123;1,2,3,4,5,6&#125;</code>，所以对应的输出为 <code>&#123;1,2,3,4,5,6&#125;</code><br>输入 <code>&#123;-1,2,4&#125;,&#123;1,3,4&#125;</code>时，合并后的链表为 <code>&#123;-1,1,2,3,4,4&#125;</code>，所以对应的输出为 <code>&#123;-1,1,2,3,4,4&#125;</code></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,3,5&#125;,&#123;2,4,6&#125;</code><br>返回值: <code>&#123;1,2,3,4,5,6&#125;</code><br><strong>示例 2</strong><br>输入: <code>&#123;&#125;,&#123;&#125;</code><br>返回值: <code>&#123;&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="literal">null</span>) cur.next = list1;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="literal">null</span>) cur.next = list2;</span><br><span class="line">        <span class="keyword">return</span> h.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ52-两个链表的第一个公共结点"><a href="#JZ52-两个链表的第一个公共结点" class="headerlink" title="JZ52 两个链表的第一个公共结点"></a>JZ52 两个链表的第一个公共结点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p>数据范围：n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入分为是 3 段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这 3 个参数组装为两个链表，并将这两个链表对应的头节点传入到函数 FindFirstCommonNode 里面，用户得到的输入只有 pHead1 和 pHead2。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7&#125;</code><br>返回值: <code>&#123;6,7&#125;</code><br>说明: 第一个参数 <code>&#123;1,2,3&#125;</code> 代表是第一个链表非公共部分，第二个参数 <code>&#123;4,5&#125;</code> 代表是第二个链表非公共部分，最后的 <code>&#123;6,7&#125;</code> 表示的是 2 个链表的公共部分。这 3 个参数最后在后台会组装成为 2 个两个无环的单链表，且是有公共节点的。<br><strong>示例 2</strong><br>输入: <code>&#123;1&#125;,&#123;2,3&#125;,&#123;&#125;</code><br>返回值: <code>&#123;&#125;</code><br>说明: 2 个链表没有公共节点 ,返回 null，后台打印 <code>&#123;&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法：使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。</span></span><br><span class="line"><span class="comment">// 让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。</span></span><br><span class="line"><span class="comment">// 因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> pHead1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> pHead2;</span><br><span class="line">        <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">            l1 = (l1 == <span class="literal">null</span>) ? pHead2 : l1.next;</span><br><span class="line">            l2 = (l2 == <span class="literal">null</span>) ? pHead1 : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ23-链表中环的入口结点"><a href="#JZ23-链表中环的入口结点" class="headerlink" title="JZ23 链表中环的入口结点"></a>JZ23 链表中环的入口结点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表 哈希 双指针</p>
<p><strong>描述</strong></p>
<p>给一个长度为 n 链表，若其中包含环，请找出该链表的环的入口结点，否则，返回 null。</p>
<p>数据范围： n≤10000，1&lt;&#x3D;结点值&lt;&#x3D;10000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入分为 2 段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p>
<p>返回值描述：<br>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2&#125;,&#123;3,4,5&#125;</code><br>返回值: “null”<br>说明: 没有环，返回对应编程语言的空结点，后台程序会打印 “null”<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;,&#123;2&#125;</code><br>返回值: 2<br>说明: 环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 用HashMap (不推荐)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用set来记录出现的结点</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当set中包含结点，说明第一次出现重复的结点，即环的入口结点</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(pHead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// set中加入未重复的结点</span></span><br><span class="line">            set.add(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用快慢指针</span></span><br><span class="line"><span class="comment">// 在环上的时候快指针与慢指针之间差N步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差(N+1-2)-&gt; N-1步。</span></span><br><span class="line"><span class="comment">// 所以快指针必然与慢指针相遇。又因为快指针速度是慢指针的两倍，所以相遇时必然只绕了一圈。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 快指针是满指针的两倍速度</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 记录快慢指针第一次相遇的结点</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若是快指针指向null，则不存在环</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新指向链表头部</span></span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ22-链表中倒数最后-k-个结点"><a href="#JZ22-链表中倒数最后-k-个结点" class="headerlink" title="JZ22 链表中倒数最后 k 个结点"></a>JZ22 链表中倒数最后 k 个结点</h4><p>时间限制: 1 秒<br>空间限制: 256M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第 k 个节点。<br>如果该链表长度小于 k，请返回一个长度为 0 的链表。</p>
<p>数据范围：0≤n≤10<sup>5</sup>，0≤a<sub>i</sub>≤10<sup>9</sup>，0≤k≤10<sup>9</sup></p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5&#125;,2</code><br>返回值: <code>&#123;4,5&#125;</code><br>说明：返回倒数第 2 个节点 4，系统会打印后面所有的节点来比较。<br><strong>示例 2</strong><br>输入: <code>&#123;2&#125;,8</code><br>返回值: <code>&#123;&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor1</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor2</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor1 = cursor1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cursor1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cursor1 = cursor1.next;</span><br><span class="line">            cursor2 = cursor2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 直接遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> ((cursor = cursor.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i - k; j ++) &#123;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3: 用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//链表节点压栈</span></span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断栈的元素是否小于k</span></span><br><span class="line">        <span class="keyword">if</span> (stack.size() &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在出栈串成新的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstNode</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">while</span> (--k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将出栈的元素重新连接成为链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            temp.next = firstNode;</span><br><span class="line">            firstNode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ35-复杂链表的复制"><a href="#JZ35-复杂链表的复制" class="headerlink" title="JZ35 复杂链表的复制"></a>JZ35 复杂链表的复制</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针 random 指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有 5 个结点的复杂链表。图中实线箭头表示 next 指针，虚线箭头表示 random 指针。为简单起见，指向 null 的指针没有画出。<br><img src="https://uploadfiles.nowcoder.com/images/20210616/557336_1623831920130/2CD1CC917CD1875FF9CD391C2924DF09"></p>
<p>示例:<br>输入: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>输出: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>解析:我们将链表分为两段，前半部分 <code>&#123;1,2,3,4,5&#125;</code> 为 ListNode，后半部分 <code>&#123;3,5,#,2,#&#125;</code> 是随机指针域表示。<br>以上示例前半部分可以表示链表为的 ListNode:1-&gt;2-&gt;3-&gt;4-&gt;5<br>后半部分，<code>3，5，#，2，#</code> 分别的表示为 1 的位置指向 3，2 的位置指向 5，3 的位置指向 null，4 的位置指向 2，5 的位置指向 null<br>如下图:<br><img src="https://uploadfiles.nowcoder.com/images/20210616/557336_1623836735191/971325772A17A314D3C44EBCDB6E7209"></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code><br>返回值: <code>&#123;1,2,3,4,5,3,5,#,2,#&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1: 借助map构建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pHead;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(cur.label));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 链表拼接、拆分</span></span><br><span class="line"><span class="comment">// 考虑构建 原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆基础链表</span></span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RandomListNode</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(cur.label);</span><br><span class="line">            clone.next = cur.next;</span><br><span class="line">            cur.next = clone;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆随机链表</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next.random = cur.random != <span class="literal">null</span> ? cur.random.next : <span class="literal">null</span>;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分链表</span></span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">cloneHead</span> <span class="operator">=</span> pHead.next;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">old</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">clone</span> <span class="operator">=</span> cloneHead;</span><br><span class="line">        <span class="keyword">while</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            old.next = clone.next;</span><br><span class="line">            <span class="keyword">if</span> (old.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                clone.next = old.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            old = old.next;</span><br><span class="line">            clone = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ76-删除链表中重复的结点"><a href="#JZ76-删除链表中重复的结点" class="headerlink" title="JZ76 删除链表中重复的结点"></a>JZ76 删除链表中重复的结点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code> 处理后为 <code>1-&gt;2-&gt;5</code></p>
<p>数据范围：链表长度满足 0≤n≤1000 ，链表中的值满足 1≤val≤1000</p>
<p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>例如输入 <code>&#123;1,2,3,3,4,4,5&#125;</code> 时，对应的输出为<code> &#123;1,2,5&#125;</code></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,3,4,4,5&#125;</code><br>返回值: <code>&#123;1,2,5&#125;</code><br><strong>示例 2</strong><br>输入: <code>&#123;1,1,1,8&#125;</code><br>返回值: <code>&#123;8&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 给链表前加上表头，删除所有重复的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplication</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在链表前加一个表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        res.next = pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//遇到相邻两个节点值相同</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == temp)</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时去掉表头</span></span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用HashMap计数</span></span><br></pre></td></tr></table></figure>

<h4 id="JZ18-删除链表的节点"><a href="#JZ18-删除链表的节点" class="headerlink" title="JZ18 删除链表的节点"></a>JZ18 删除链表的节点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 链表</p>
<p><strong>描述</strong></p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<p>1.此题对比原题有改动 2.题目保证链表中节点的值互不相同 3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<p>数据范围:<br>0&lt;&#x3D;链表节点值&lt;&#x3D;10000<br>0&lt;&#x3D;链表长度&lt;&#x3D;10000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;2,5,1,9&#125;,5</code><br>返回值: <code>&#123;2,1,9&#125;</code><br>说明: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 1 -&gt; 9<br><strong>示例 2</strong><br>输入: <code>&#123;2,5,1,9&#125;,1</code><br>返回值: <code>&#123;2,5,9&#125;</code><br>说明: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 5 -&gt; 9</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法: 添加头结点，找到对应节点后退出循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span> <span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 添加头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        res.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="JZ55-二叉树的深度"><a href="#JZ55-二叉树的深度" class="headerlink" title="JZ55 二叉树的深度"></a>JZ55 二叉树的深度</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。</p>
<p>数据范围：节点的数量满足 0≤n≤100 ，节点上的值满足 0≤val≤100<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5,#,6,#,#,7&#125;</code><br>返回值: 4<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;</code><br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(TreeDepth(root.left), TreeDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ77-按之字形顺序打印二叉树"><a href="#JZ77-按之字形顺序打印二叉树" class="headerlink" title="JZ77 按之字形顺序打印二叉树"></a>JZ77 按之字形顺序打印二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈 树 队列</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p>
<p>数据范围：0≤n≤1500,树上每个节点的 val 满足 ∣val∣&lt;&#x3D;1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)<br>例如：<br>给定的二叉树是<code>&#123;1,2,3,#,#,4,5&#125;</code><br>该二叉树之字形层序遍历的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1],</span><br><span class="line">[3,2],</span><br><span class="line">[4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,#,#,4,5&#125;</code><br>返回值: <code>[[1],[3,2],[4,5]]</code><br><strong>示例 2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>[[8],[10,6],[5,7,9,11]]</code><br><strong>示例 3</strong><br>输入: <code>&#123;1,2,3,4,5&#125;</code><br>返回值: <code>[[1],[3,2],[4,5]]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 用链表，一个链表记录当前层，一个链表记录下一层，也可用栈</span></span><br><span class="line"><span class="comment">// 注意: 每次都从后往前遍历，即可翻转，但是第一层节点右节点先入下一层，第二层左节点先，如此反复</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        layer.add(pRoot);</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;() &#123;&#123;add(pRoot.val);&#125;&#125;);</span><br><span class="line">        <span class="keyword">while</span> (layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;TreeNode&gt; nextLayer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; nextLayerValue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (result.size() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> layer.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> layer.get(i);</span><br><span class="line">                    addTreeNode(treeNode.right, nextLayer, nextLayerValue);</span><br><span class="line">                    addTreeNode(treeNode.left, nextLayer, nextLayerValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> layer.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> layer.get(i);</span><br><span class="line">                    addTreeNode(treeNode.left, nextLayer, nextLayerValue);</span><br><span class="line">                    addTreeNode(treeNode.right, nextLayer, nextLayerValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            layer = nextLayer;</span><br><span class="line">            <span class="keyword">if</span> (nextLayerValue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(nextLayerValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTreeNode</span><span class="params">(TreeNode treeNode, ArrayList&lt;TreeNode&gt; nextLayer, ArrayList&lt;Integer&gt; nextLayerValue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextLayer.add(treeNode);</span><br><span class="line">            nextLayerValue.add(treeNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ54-二叉搜索树的第-k-个节点"><a href="#JZ54-二叉搜索树的第-k-个节点" class="headerlink" title="JZ54 二叉搜索树的第 k 个节点"></a>JZ54 二叉搜索树的第 k 个节点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 dfs 递归</p>
<p><strong>描述</strong></p>
<p>给定一棵结点数为 n 二叉搜索树，请找出其中的第 k 小的 TreeNode 结点值。 1.返回第 k 小的节点值即可 2.不能查找的情况，如二叉树为空，则返回-1，或者 k 大于 n 等等，也返回-1 3.保证 n 个节点的值不一样</p>
<p>数据范围：0≤n≤1000，0≤k≤1000，树上每个结点的值满足 0≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>如输入<code>&#123;5,3,7,2,4,6,8&#125;,3</code>时。该二叉树所有节点按结点值升序排列后可得<code>[2,3,4,5,6,7,8]</code>，所以第 3 个结点的结点值为 4，故返回对应结点值为 4 的结点即可。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;5,3,7,2,4,6,8&#125;,3</code><br>返回值: 4<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;,1</code><br>返回值: -1<br>说明: 当树是空</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 递归 用链表存储数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proot TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KthNode</span><span class="params">(TreeNode proot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (proot == <span class="literal">null</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        addNode(list, proot);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; list.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(List&lt;Integer&gt; list, TreeNode curNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(list, curNode.left);</span><br><span class="line">        list.add(curNode.val);</span><br><span class="line">        addNode(list, curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 递归 计数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proot TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KthNode</span><span class="params">(TreeNode proot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 记录返回的节点</span></span><br><span class="line">        TreeNode[] res = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[] &#123;<span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="comment">// 记录中序遍历了多少个</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        midOrder(res, count, proot, k);</span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">0</span>].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midOrder</span><span class="params">(TreeNode[] res, <span class="type">int</span>[] count, TreeNode curNode, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//当遍历到节点为空或者超过k时，返回</span></span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="literal">null</span> || count[<span class="number">0</span>] &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        midOrder(res, count, curNode.left, k);</span><br><span class="line">        count[<span class="number">0</span>] ++;</span><br><span class="line">        <span class="comment">// 只记录第k个</span></span><br><span class="line">        <span class="keyword">if</span> (count[<span class="number">0</span>] == k) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        midOrder(res, count, curNode.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ7-重建二叉树"><a href="#JZ7-重建二叉树" class="headerlink" title="JZ7 重建二叉树"></a>JZ7 重建二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 dfs 数组</p>
<p><strong>描述</strong></p>
<p>给定节点数为 n 二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。<br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628"></p>
<p>提示:<br>1.vin.length &#x3D;&#x3D; pre.length<br>2.pre 和 vin 均无重复元素<br>3.vin 出现的元素均出现在 pre 里 4.只需要返回根结点，系统会自动输出整颗树做答案对比</p>
<p>数据范围：n≤2000，节点的值 −10000≤val≤10000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]</code><br>返回值: <code>&#123;1,2,3,4,#,5,6,#,7,#,#,8&#125;</code><br>说明：返回根节点，系统会输出整颗二叉树对比结果，重建结果如题面图示<br><strong>示例 2</strong><br>输入: <code>[1],[1]</code><br>返回值: <code>&#123;1&#125;</code><br><strong>示例 3</strong><br>输入: <code>[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</code><br>返回值: <code>&#123;1,2,5,3,4,6,7&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 算法思想：</span></span><br><span class="line"><span class="comment"> 1. 先序遍历第一个位置肯定是根节点node</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 2. 中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 3. 先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 4. 把四个数组找出来，分左右递归调用即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 每次直接拷贝出对应的四个数组，然后递归调用</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span> || in.length == <span class="number">0</span> || pre.length != in.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[<span class="number">0</span>] == in[i]) &#123;</span><br><span class="line">                node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i+<span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+<span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 传递原数组、以及数组中对应的开始位置和长度，然后递归调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] in)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reConstructBinaryTree(pre, in, <span class="number">0</span>, <span class="number">0</span>, pre.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次都传递原数组的引用，不需要进行数组拷贝，但是要注意：</span></span><br><span class="line"><span class="comment">     *   先序和中序开始的位置是不一样的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre 原先序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 原中序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preBeginIndex 先序数组中开始的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inBeginIndex 中序数组中开始的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 本次要重建的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> preBeginIndex, <span class="type">int</span> inBeginIndex, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否越界，以及本次长度是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (preBeginIndex &lt; <span class="number">0</span> || preBeginIndex + length &gt; pre.length</span><br><span class="line">                || inBeginIndex &lt; <span class="number">0</span> || inBeginIndex + length &gt; pre.length || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先序遍历第一个位置肯定是根节点node</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preBeginIndex]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> preBeginIndex;</span><br><span class="line">        <span class="comment">// 左子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inBeginIndex; i &lt; inBeginIndex + length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[preBeginIndex] == in[i]) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                leftLength = i - inBeginIndex;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> length - leftLength - <span class="number">1</span>;</span><br><span class="line">        root.left = reConstructBinaryTree(pre, in, preBeginIndex + <span class="number">1</span>, inBeginIndex, leftLength);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, in, preBeginIndex + leftLength + <span class="number">1</span>, rootIndex + <span class="number">1</span>, rightLength);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ26-树的子结构"><a href="#JZ26-树的子结构" class="headerlink" title="JZ26 树的子结构"></a>JZ26 树的子结构</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 二叉树 树</p>
<p><strong>描述</strong></p>
<p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构。（我们约定空树不是任意一个树的子结构）<br>假如给定 A 为{8,8,7,9,2,#,#,#,#,4,7}，B 为{8,9,2}，2 个树的结构如下，可以看出 B 是 A 的子结构</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211027/557336_1635320187489/B1C70B05B2BA3AAA854EE032F2A8D826"></p>
<p>数据范围:<br>0 &lt;&#x3D; A 的节点个数 &lt;&#x3D; 10000<br>0 &lt;&#x3D; B 的节点个数 &lt;&#x3D; 10000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;8,8,7,9,2,#,#,#,#,4,7&#125;,&#123;8,9,2&#125;</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>&#123;1,2,3,4,5&#125;,&#123;2,4&#125;</code><br>返回值: true<br><strong>示例 3</strong><br>输入: <code>&#123;1,2,3&#125;,&#123;3,1&#125;</code><br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 双遍历 先遍历A，在每个节点都去去对比B是否是子树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历A</span></span><br><span class="line">        <span class="keyword">return</span> traverse(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(TreeNode root1,TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// A的该节点是空</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 和B对比</span></span><br><span class="line">        <span class="keyword">if</span> (compare(root1, root2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历A的左右子树</span></span><br><span class="line">            <span class="keyword">return</span> traverse(root1.left, root2) || traverse(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1.val != root2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> compare(root1.left, root2.left) &amp;&amp; compare(root1.right, root2.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ27-二叉树的镜像"><a href="#JZ27-二叉树的镜像" class="headerlink" title="JZ27 二叉树的镜像"></a>JZ27 二叉树的镜像</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>数据范围：二叉树的节点数 0≤n≤1000 ， 二叉树每个节点的值 0≤val≤1000<br>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1) 的解法，时间复杂度 O(n)</p>
<p>比如：<br>源二叉树<br><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888"><br>镜像二叉树<br><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A"></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>&#123;8,10,6,11,9,7,5&#125;</code><br>说明: 如题面所示<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;</code><br>返回值: <code>&#123;&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 先交换左右子节点，然后遍历子节点交换子节点的左右子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = tmp;</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 见下图</span></span><br><span class="line"><span class="comment">// 算法流程：一层一层进栈并交换左右节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 构建辅助栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 根节点入栈</span></span><br><span class="line">        stack.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 节点出栈</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="comment">// 根节点的左右子树入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">            <span class="comment">// 左右子树交换</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法 2<br><img src="https://uploadfiles.nowcoder.com/images/20210625/889362376_1624613381635/984D3CF58361D4880F35C93DBDB46F37"></p>
<h4 id="JZ32-从上往下打印二叉树"><a href="#JZ32-从上往下打印二叉树" class="headerlink" title="JZ32 从上往下打印二叉树"></a>JZ32 从上往下打印二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 队列 树</p>
<p><strong>描述</strong></p>
<p>不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如输入{8,6,10,#,#,2,1}，如以下图中的示例二叉树，则依次打印 8,6,10,2,1(空节点不打印，跳过)，请你将打印的结果存放到一个数组里面，返回。<br><img src="https://uploadfiles.nowcoder.com/images/20211029/557336_1635477973725/6C502E0240CAC668843969AFF396B5E4"></p>
<p>数据范围:<br>0&lt;&#x3D;节点总数&lt;&#x3D;1000<br>-1000&lt;&#x3D;节点值&lt;&#x3D;1000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;8,6,10,#,#,2,1&#125;</code><br>返回值: [8,6,10,2,1]<br><strong>示例 2</strong><br>输入: <code>&#123;5,4,#,3,#,2,#,1&#125;</code><br>返回值: [5,4,3,2,1]</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 层次遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回列表</span></span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 暂存当前层节点</span></span><br><span class="line">        List&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        layer.add(root);</span><br><span class="line">        <span class="keyword">while</span> (layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建当前层缓存</span></span><br><span class="line">            List&lt;TreeNode&gt; tmp = layer;</span><br><span class="line">            <span class="comment">// 新建下一层</span></span><br><span class="line">            layer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                    result.add(node.val);</span><br><span class="line">                    layer.add(node.left);</span><br><span class="line">                    layer.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ33-二叉搜索树的后序遍历序列"><a href="#JZ33-二叉搜索树的后序遍历序列" class="headerlink" title="JZ33 二叉搜索树的后序遍历序列"></a>JZ33 二叉搜索树的后序遍历序列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈 树</p>
<p><strong>描述</strong></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同。</p>
<p>数据范围： 节点数量 0≤n≤1000 ，节点上的值满足 1≤val≤10<sup>5</sup>，保证节点上的值各不相同<br>要求：空间复杂度 O(n) ，时间时间复杂度 O(n^2)</p>
<p>提示： 1.二叉搜索树是指父亲节点大于左子树中的全部节点，但是小于右子树中的全部节点的树。 2.该题我们约定空树不是二叉搜索树 3.后序遍历是指按照 “左子树-右子树-根节点” 的顺序遍历 4.参考下面的二叉搜索树，示例 1</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211031/557336_1635645087543/44496AC711FE9478BABD9207180C3423"></p>
<p><strong>示例 1</strong><br>输入: <code>[1,3,2]</code><br>返回值: true<br>说明: 是上图的后序遍历 ，返回 true<br><strong>示例 2</strong><br>输入: <code>[3,1,2]</code><br>返回值: false<br>说明: 不属于上图的后序遍历，从另外的二叉搜索树也不能后序遍历出该序列 ，因为最后的 2 一定是根节点，前面一定是孩子节点，可能是左孩子，右孩子，根节点，也可能是全左孩子，根节点，也可能是全右孩子，根节点，但是 <code>[3,1,2]</code> 的组合都不能满足这些情况，故返回 false<br><strong>示例 3</strong><br>输入: <code>[5,7,6,9,11,10,8]</code><br>返回值: true</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 将一个序列划分为3段, 左子树+右子树+根，然后遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">VerifySquenceOfBST</span><span class="params">(<span class="type">int</span> [] sequence)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> sequence.length;</span><br><span class="line">        <span class="keyword">if</span> (sequence.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(<span class="type">int</span>[] sequence, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">// 子树只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子树根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> sequence[r];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 划分右子树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; sequence[j] &gt; root) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左子树是否存在大于根节点的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= j; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &gt; root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> verify(sequence, l, j) &amp;&amp; verify(sequence, j + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ82-二叉树中和为某一值的路径-一"><a href="#JZ82-二叉树中和为某一值的路径-一" class="headerlink" title="JZ82 二叉树中和为某一值的路径(一)"></a>JZ82 二叉树中和为某一值的路径(一)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 dfs</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树 root 和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为 n</p>
<p>例如：<br>给出如下的二叉树，sum&#x3D;22，<br><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159"></p>
<p>返回 true，因为存在一条路径 5→4→11→2 的节点值之和为 22</p>
<p>数据范围： 1.树上的节点数满足 0≤n≤10000 2.每 个节点的值都满足 ∣val∣≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>进阶：空间复杂度 O(树的高度)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;5,4,8,1,11,#,9,#,#,2,7&#125;,22</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>&#123;1,2&#125;,0</code><br>返回值: false<br><strong>示例 3</strong><br>输入: <code>&#123;1,2&#125;,3</code><br>返回值: true<br><strong>示例 4</strong><br>输入: <code>&#123;&#125;,0</code><br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法1: 递归 加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root, sum, root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum, <span class="type">int</span> res)</span> &#123;</span><br><span class="line">        <span class="comment">// 左右子节点都为空才是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == sum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                left = hasPathSum(root.left, sum, res + root.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                right = hasPathSum(root.right, sum, res + root.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left || right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 递归 减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ34-二叉树中和为某一值的路径-二"><a href="#JZ34-二叉树中和为某一值的路径-二" class="headerlink" title="JZ34 二叉树中和为某一值的路径(二)"></a>JZ34 二叉树中和为某一值的路径(二)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>输入一颗二叉树的根节点 root 和一个整数 expectNumber，找出二叉树中结点值的和为 expectNumber 的所有路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为 n</p>
<p>如二叉树 root 为 <code>&#123;10,5,12,4,7&#125;</code>, expectNumber 为 22<br><img src="https://uploadfiles.nowcoder.com/images/20210929/557336_1632915294911/0A4B8F161306A7054899D42C0C6937FD"><br>则合法路径有 <code>[[10,5,7],[10,12]]</code></p>
<p>数据范围:<br>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; 节点值 &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; expectNumber &lt;&#x3D; 1000</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;10,5,12,4,7&#125;,22</code><br>返回值: <code>[[10,5,7],[10,12]]</code><br>说明: 返回 <code>[[10,12],[10,5,7]]</code> 也是对的<br><strong>示例 2</strong><br>输入: <code>&#123;10,5,12,4,7&#125;,15</code><br>返回值: <code>[]</code><br><strong>示例 3</strong><br>输入: <code>&#123;2,3&#125;,0</code><br>返回值: <code>[]</code><br><strong>示例 4</strong><br>输入: <code>&#123;1,3,4&#125;,7</code><br>返回值: <code>[]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 深度优先搜索 加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> expectNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        findPath(root, expectNumber, root.val, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findPath</span><span class="params">(TreeNode root, <span class="type">int</span> expectNumber, <span class="type">int</span> sum,</span></span><br><span class="line"><span class="params">                          ArrayList&lt;Integer&gt; path,</span></span><br><span class="line"><span class="params">                          ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum == expectNumber) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.add(root.left.val);</span><br><span class="line">            findPath(root.left, expectNumber, sum + root.left.val, path, result);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.add(root.right.val);</span><br><span class="line">            findPath(root.right, expectNumber, sum + root.right.val, path, result);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 深度优先搜索 减法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> expectNumber)</span> &#123;</span><br><span class="line">        dfs(root, expectNumber);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理树为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 路径更新</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">// number更新</span></span><br><span class="line">        number -= root.val;</span><br><span class="line">        <span class="comment">// 如果递归当前节点为叶子节点且该条路径的值已经达到了expectNumber，则更新ret</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; number == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树递归</span></span><br><span class="line">        dfs(root.left, number);</span><br><span class="line">        dfs(root.right, number);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ36-二叉搜索树与双向链表"><a href="#JZ36-二叉搜索树与双向链表" class="headerlink" title="JZ36 二叉搜索树与双向链表"></a>JZ36 二叉搜索树与双向链表</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 分治</p>
<p><strong>描述</strong></p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2"></p>
<p>数据范围：输入二叉树的节点数 0≤n≤1000，二叉树中每个节点的值 0≤val≤1000<br>要求：空间复杂度 O(1)（即在原树上操作），时间复杂度 O(n)</p>
<p>注意: 1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 2.返回链表中的第一个节点的指针 3.函数返回的 TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p>
<p>输入描述：<br>二叉树的根节点</p>
<p>返回值描述：<br>双向链表的其中一个头节点。</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;10,6,14,4,8,12,16&#125;</code><br>返回值: From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;<br>说明: 输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。<br><strong>示例 2</strong><br>输入: <code>&#123;5,4,#,3,#,2,#,1&#125;</code><br>返回值: From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;<br>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        5</span><br><span class="line">       /</span><br><span class="line">      4</span><br><span class="line">     /</span><br><span class="line">    3</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>树的形状如上图</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 方法1: 递归中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//返回的第一个指针，即为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//中序遍历当前值的上一位，初值为最小值，先定为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//中序递归，叶子为空则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先递归到最左最小值</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="comment">//找到最小值，初始化head与pre</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2: 非递归中序遍历 （栈）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//设置栈用于遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//确认第一个遍历到最左，即为首位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFirst</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (pRootOfTree != <span class="literal">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//直到没有左节点</span></span><br><span class="line">            <span class="keyword">while</span> (pRootOfTree != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree.left;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = s.pop();</span><br><span class="line">            <span class="comment">//最左元素即表头</span></span><br><span class="line">            <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">                head = pRootOfTree;</span><br><span class="line">                pre = head;</span><br><span class="line">                isFirst = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right = pRootOfTree;</span><br><span class="line">                pRootOfTree.left = pre;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = pRootOfTree.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ79-判断是不是平衡二叉树"><a href="#JZ79-判断是不是平衡二叉树" class="headerlink" title="JZ79 判断是不是平衡二叉树"></a>JZ79 判断是不是平衡二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 dfs</p>
<p><strong>描述</strong></p>
<p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。<br>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树<br>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。<br>样例解释：<br><img src="https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6"></p>
<p>样例二叉树如图，为一颗平衡二叉树<br>注：我们约定空树是平衡二叉树。</p>
<p>数据范围：n≤100,树上节点的 val 值满足 0≤n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入描述：<br>输入一棵二叉树的根节点</p>
<p>返回值描述：<br>输出一个布尔类型的值</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5,6,7&#125;</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>&#123;&#125;</code><br>返回值: true</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1: 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.abs(treeDepth(root.left) - treeDepth(root.right)) &lt;= <span class="number">1</span></span><br><span class="line">            &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> treeDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> treeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ8-二叉树的下一个结点"><a href="#JZ8-二叉树的下一个结点" class="headerlink" title="JZ8 二叉树的下一个结点"></a>JZ8 二叉树的下一个结点</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的 next 指针。</p>
<p>示例:<br>输入: <code>&#123;8,6,10,5,7,9,11&#125;,8</code><br>返回: 9<br>解析: 这个组装传入的子树根节点，其实就是整颗树，中序遍历 <code>&#123;5,6,7,8,9,10,11&#125;</code>，根节点 8 的下一个节点就是 9，应该返回 <code>&#123;9,10,11&#125;</code>，后台只打印子树的下一个节点，所以只会打印 9，如下图，其实都有指向左右孩子的指针，还有指向父节点的指针，下图没有画出来</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210616/557336_1623845692021/E647707AEF2A4AE2C40F0FCCB549B6A5"></p>
<p>数据范围：节点数满足 1≤n≤50 ，节点上的值满足 1≤val≤100</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;,8</code><br>返回值: 9<br><strong>示例 2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;,6</code><br>返回值: 7<br><strong>示例 3</strong><br>输入: <code>&#123;1,2,#,#,3,#,4&#125;,4</code><br>返回值: 1<br><strong>示例 4</strong><br>输入: <code>&#123;5&#125;,5</code><br>返回值: “null”<br>说明: 不存在，后台打印”null”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法1: 递归中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;TreeLinkNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取根节点</span></span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">root</span> <span class="operator">=</span> pNode;</span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="literal">null</span>) root = root.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序遍历打造nodes</span></span><br><span class="line">        InOrder(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行匹配</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nodes.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">TreeLinkNode</span> <span class="variable">cur</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">            <span class="keyword">if</span>(pNode == cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> nodes.get(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">InOrder</span><span class="params">(TreeLinkNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            InOrder(root.left);</span><br><span class="line">            nodes.add(root);</span><br><span class="line">            InOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ28-对称的二叉树"><a href="#JZ28-对称的二叉树" class="headerlink" title="JZ28 对称的二叉树"></a>JZ28 对称的二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：<br>下面这棵二叉树是对称的<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F"><br>下面这棵二叉树不对称<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372"></p>
<p>数据范围：节点数满足 0≤n≤1000，节点上的值满足 ∣val∣≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>备注：<br>你可以用递归和迭代两种方法解决这个问题</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,2,3,4,4,3&#125;</code><br>返回值: true<br><strong>示例 2</strong><br>输入: <code>&#123;8,6,9,5,7,7,5&#125;</code><br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursion(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recursion</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 可以两个都为空</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个为空或者节点值不同，必定不对称</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>  || root2 == <span class="literal">null</span> || root1.val != root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每层对应的节点进入递归比较</span></span><br><span class="line">        <span class="keyword">return</span> recursion(root1.left, root2.right) &amp;&amp; recursion(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ78-把二叉树打印成多行"><a href="#JZ78-把二叉树打印成多行" class="headerlink" title="JZ78 把二叉树打印成多行"></a>JZ78 把二叉树打印成多行</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 广度优先搜索(BFS)</p>
<p><strong>描述</strong></p>
<p>给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。<br>例如：<br>给定的二叉树是 <code>&#123;1,2,3,#,#,4,5&#125;</code><br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05"></p>
<p>该二叉树多行打印层序遍历的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1],</span><br><span class="line">[2,3],</span><br><span class="line">[4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>数据范围：二叉树的节点数 0≤n≤1000，0≤val≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>输入描述：<br>给定一个二叉树的根节点</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,#,#,4,5&#125;</code><br>返回值: <code>[[1],[2,3],[4,5]]</code><br><strong>示例 2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>[[8],[6,10],[5,7,9,11]]</code><br><strong>示例 3</strong><br>输入: <code>&#123;1,2,3,4,5&#125;</code><br>返回值: <code>[[1],[2,3],[4,5]]</code><br><strong>示例 4</strong><br>输入: <code>&#123;&#125;</code><br>返回值: <code>[]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法: 用ArrayList做缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;TreeNode&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        layer.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(layer.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : layer) &#123;</span><br><span class="line">                values.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    tmp.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    tmp.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(values);</span><br><span class="line">            layer = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ37-序列化二叉树"><a href="#JZ37-序列化二叉树" class="headerlink" title="JZ37 序列化二叉树"></a>JZ37 序列化二叉树</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 队列 树</p>
<p><strong>描述</strong></p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p>
<p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p>
<p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果 str，重构二叉树。</p>
<p>例如，可以根据层序遍历的方案序列化，如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E"></p>
<p>层序序列化(即用函数 Serialize 转化) 如上的二叉树转为 <code>&quot;&#123;1,2,3,#,#,6,7&#125;&quot;</code>，再能够调用反序列化(Deserialize) 将 <code>&quot;&#123;1,2,3,#,#,6,7&#125;&quot;</code> 构造成如上的二叉树。</p>
<p>当然你也可以根据满二叉树结点位置的标号规律来序列化，还可以根据先序遍历和中序遍历的结果来序列化。不对序列化之后的字符串进行约束，所以欢迎各种奇思妙想。</p>
<p>数据范围：节点数 n≤100，树上每个节点的值满足 0≤val≤150<br>要求：序列化和反序列化都是空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,#,#,6,7&#125;</code><br>返回值: <code>&#123;1,2,3,#,#,6,7&#125;</code><br>说明: 如题面图<br><strong>示例 2</strong><br>输入: <code>&#123;8,6,10,5,7,9,11&#125;</code><br>返回值: <code>&#123;8,6,10,5,7,9,11&#125;</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: 前序遍历</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//序列的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//处理序列化的功能函数（递归）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">SerializeFunction</span><span class="params">(TreeNode root, StringBuilder str)</span>&#123;</span><br><span class="line">        <span class="comment">//如果节点为空，表示左子节点或右子节点为空，用#表示</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            str.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        str.append(root.val).append(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        SerializeFunction(root.left, str);</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        SerializeFunction(root.right, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//处理空树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        SerializeFunction(root, res);</span><br><span class="line">        <span class="comment">//把str转换成char</span></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理反序列化的功能函数（递归）</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">DeserializeFunction</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//到达叶节点时，构建完毕，返回继续构建父节点</span></span><br><span class="line">        <span class="comment">//空节点</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(index) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数字转换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遇到分隔符或者结尾</span></span><br><span class="line">        <span class="keyword">while</span>(str.charAt(index) != <span class="string">&#x27;!&#x27;</span> &amp;&amp; index != str.length())&#123;</span><br><span class="line">            val = val * <span class="number">10</span> + ((str.charAt(index)) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="comment">//序列到底了，构建完成</span></span><br><span class="line">        <span class="keyword">if</span>(index == str.length())</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index++;</span><br><span class="line">        <span class="comment">//反序列化与序列化一致，都是前序</span></span><br><span class="line">        root.left = DeserializeFunction(str);</span><br><span class="line">        root.right = DeserializeFunction(str);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Deserialize</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//空序列对应空树</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> DeserializeFunction(str);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ84-二叉树中和为某一值的路径-三"><a href="#JZ84-二叉树中和为某一值的路径-三" class="headerlink" title="JZ84 二叉树中和为某一值的路径(三)"></a>JZ84 二叉树中和为某一值的路径(三)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一个二叉树 root 和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为 n 3.保证最后返回的路径个数在整形范围内(即路径个数小于 2<sup>31</sup>-1)</p>
<p>数据范围:<br>0&lt;&#x3D;n&lt;&#x3D;1000<br>-10^9&lt;&#x3D;节点值&lt;&#x3D;10^9</p>
<p>假如二叉树 root 为 <code>&#123;1,2,3,4,5,4,3,#,#,-1&#125;</code>，sum&#x3D;6，那么总共如下所示，有 3 条路径符合要求</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211103/301499_1635923010369/C47185D4980F108BC73F790D8D2F6709"></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;1,2,3,4,5,4,3,#,#,-1&#125;,6</code><br>返回值: 3<br>说明: 如图所示，有 3 条路径符合<br><strong>示例 2</strong><br>输入: <code>&#123;0,1&#125;,1</code><br>返回值: 2<br><strong>示例 3</strong><br>输入: <code>&#123;1,#,2,#,3&#125;,3</code><br>返回值: 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: dfs算法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以每个节点作为根查询路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FindPath</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 为空则返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询以某节点为根的路径数</span></span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="comment">// 以其子节点为新根</span></span><br><span class="line">        FindPath(root.left, sum);</span><br><span class="line">        FindPath(root.right, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs查询以某节点为根的路径数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 符合目标值</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点值可以为负数，所以进入子节点继续寻找</span></span><br><span class="line">        dfs(root.left, sum - root.val);</span><br><span class="line">        dfs(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ86-在二叉树中找到两个节点的最近公共祖先"><a href="#JZ86-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="JZ86 在二叉树中找到两个节点的最近公共祖先"></a>JZ86 在二叉树中找到两个节点的最近公共祖先</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树</p>
<p><strong>描述</strong></p>
<p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的 val 值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。</p>
<p>数据范围：树上节点数满足 1≤n≤10^5, 节点值 val 满足区间 [0,n)<br>要求：时间复杂度 O(n)</p>
<p>注：本题保证二叉树中每个节点的 val 值均不相同。</p>
<p>如当输入 <code>&#123;3,5,1,6,2,0,8,#,#,7,4&#125;,5,1</code> 时，二叉树 <code>&#123;3,5,1,6,2,0,8,#,#,7,4&#125;</code> 如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22"></p>
<p>所以节点值为 5 和节点值为 1 的节点的最近公共祖先节点的节点值为 3，所以对应的输出为 3。<br>节点本身可以视为自己的祖先</p>
<p><strong>示例 1</strong><br>输入: <code>&#123;3,5,1,6,2,0,8,#,#,7,4&#125;,5,1</code><br>返回值: 3<br><strong>示例 2</strong><br>输入: <code>&#123;3,5,1,6,2,0,8,#,#,7,4&#125;,2,7</code><br>返回值: 2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 解法: dfs遍历回溯找到两个目标值的路径，再进行路径对比</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录是否找到o的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;Integer&gt; path1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 求根节点到o1的路径</span></span><br><span class="line">        dfs(root, path1, o1);</span><br><span class="line">        <span class="comment">// 重置flag</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 求根节点到o2的路径</span></span><br><span class="line">        dfs(root, path2, o2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 比较路径，找到最后一个相同点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path1.size() &amp;&amp; i &lt; path2.size(); i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path1.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> path2.get(i);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                res = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; path, <span class="type">int</span> o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag || root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">// 节点的值都不同，可以直接用值比较</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == o) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs遍历查找</span></span><br><span class="line">        dfs(root.left, path, o);</span><br><span class="line">        dfs(root.right, path, o);</span><br><span class="line">        <span class="comment">// 找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ68-二叉搜索树的最近公共祖先"><a href="#JZ68-二叉搜索树的最近公共祖先" class="headerlink" title="JZ68 二叉搜索树的最近公共祖先"></a>JZ68 二叉搜索树的最近公共祖先</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 树 递归</p>
<p><strong>描述</strong></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<ol>
<li>对于该题的最近的公共祖先定义:对于有根树 T 的两个节点 p、q，最近公共祖先 LCA(T,p,q)表示一个节点 x，满足 x 是 p 和 q 的祖先且 x 的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</li>
<li>二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</li>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ol>
<p>数据范围:<br>3&lt;&#x3D;节点总数&lt;&#x3D;10000<br>0&lt;&#x3D;节点值&lt;&#x3D;10000</p>
<p>如果给定以下搜索二叉树: <code>&#123;7,1,12,0,4,11,14,#,#,3,5&#125;</code>，如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A"></p>
<p><strong>示例 1</strong><br>输入: <code>&#123;7,1,12,0,4,11,14,#,#,3,5&#125;,1,12</code><br>返回值: 7<br>说明: 节点 1 和 节点 12 的最近公共祖先是 7<br><strong>示例 2</strong><br>输入: <code>&#123;7,1,12,0,4,11,14,#,#,3,5&#125;,12,11</code><br>返回值: 12<br>说明: 因为一个节点也可以是它自己的祖先.所以输出 12</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 利用二叉搜索树的性质向下查找即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; cur.val &amp;&amp; q &lt; cur.val) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; cur.val &amp;&amp; q &gt; cur.val) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列-amp-栈"><a href="#队列-amp-栈" class="headerlink" title="队列 &amp; 栈"></a>队列 &amp; 栈</h3><h4 id="JZ9-用两个栈实现队列"><a href="#JZ9-用两个栈实现队列" class="headerlink" title="JZ9 用两个栈实现队列"></a>JZ9 用两个栈实现队列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>用两个栈来实现一个队列，使用 n 个元素来完成 n 次在队列尾部插入整数(push)和 n 次在队列头部删除整数(pop)的功能。 队列中的元素为 int 类型。保证操作合法，即保证 pop 操作时队列内已有元素。</p>
<p>数据范围： n≤1000<br>要求：存储 n 个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)</p>
<p><strong>示例 1</strong></p>
<p>输入: <code>[&quot;PSH1&quot;,&quot;PSH2&quot;,&quot;POP&quot;,&quot;POP&quot;]</code><br>返回值: 1,2<br>说明:<br>“PSH1”:代表将 1 插入队列尾部<br>“PSH2”:代表将 2 插入队列尾部<br>“POP”:代表删除一个元素，先进先出&#x3D;&gt;返回 1<br>“POP”:代表删除一个元素，先进先出&#x3D;&gt;返回 2</p>
<p><strong>示例 2</strong><br>输入: <code>[&quot;PSH2&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;POP&quot;]</code><br>返回值: 2,1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ30-包含-min-函数的栈"><a href="#JZ30-包含-min-函数的栈" class="headerlink" title="JZ30 包含 min 函数的栈"></a>JZ30 包含 min 函数的栈</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p>
<p>此栈包含的方法有：<br>push(value):将 value 压入栈中<br>pop():弹出栈顶元素<br>top():获取栈顶元素<br>min():获取栈中最小元素</p>
<p>数据范围：操作数量满足 0≤n≤300，输入的元素满足 ∣val∣≤10000<br>进阶：栈的各个操作的时间复杂度是 O(1)，空间复杂度是 O(n)</p>
<p>示例:<br>输入: <code>[&quot;PSH-1&quot;,&quot;PSH2&quot;,&quot;MIN&quot;,&quot;TOP&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;TOP&quot;,&quot;MIN&quot;]</code><br>输出: -1,2,1,-1<br>解析:<br>“PSH-1”表示将-1 压入栈中，栈中元素为-1<br>“PSH2”表示将 2 压入栈中，栈中元素为 2，-1<br>“MIN”表示获取此时栈中最小元素&#x3D;&#x3D;&gt;返回-1<br>“TOP”表示获取栈顶元素&#x3D;&#x3D;&gt;返回 2<br>“POP”表示弹出栈顶元素，弹出 2，栈中元素为-1<br>“PSH1”表示将 1 压入栈中，栈中元素为 1，-1<br>“TOP”表示获取栈顶元素&#x3D;&#x3D;&gt;返回 1<br>“MIN”表示获取此时栈中最小元素&#x3D;&#x3D;&gt;返回-1</p>
<p><strong>示例 1</strong><br>输入: <code>[&quot;PSH-1&quot;,&quot;PSH2&quot;,&quot;MIN&quot;,&quot;TOP&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;TOP&quot;,&quot;MIN&quot;]</code><br>返回值: -1,2,1,-1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">// 解法: 维护一个非严格对应的降序最小栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用于栈的push 与 pop</span></span><br><span class="line">    Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 用于存储最小min</span></span><br><span class="line">    Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        s1.push(node);</span><br><span class="line">        <span class="comment">// 空或者新元素小于等于最小值，则入栈</span></span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty() || node &lt;= s2.peek()) &#123;</span><br><span class="line">            s2.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> s1.pop();</span><br><span class="line">        <span class="keyword">if</span> (s2.peek() == v) &#123;</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ31-栈的压入、弹出序列"><a href="#JZ31-栈的压入、弹出序列" class="headerlink" title="JZ31 栈的压入、弹出序列"></a>JZ31 栈的压入、弹出序列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 栈</p>
<p><strong>描述</strong></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p>
<ol>
<li>0 &lt;&#x3D; pushV.length &#x3D;&#x3D; popV.length &lt;&#x3D;1000</li>
<li>-1000 &lt;&#x3D; pushV[i] &lt;&#x3D; 1000</li>
<li>pushV 的所有数字均不相同</li>
</ol>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,4,5],[4,5,3,2,1]</code><br>返回值: true<br>说明: 可以通过<br>push(1)&#x3D;&gt;push(2)&#x3D;&gt;push(3)&#x3D;&gt;push(4)&#x3D;&gt;pop()&#x3D;&gt;push(5)&#x3D;&gt;pop()&#x3D;&gt;pop()&#x3D;&gt;pop()&#x3D;&gt;pop()<br>这样的顺序得到 <code>[4,5,3,2,1]</code> 这个序列，返回 true<br><strong>示例 2</strong><br>输入: <code>[1,2,3,4,5],[4,3,5,1,2]</code><br>返回值: false<br>说明: 由于是 <code>[1,2,3,4,5]</code> 的压入顺序，<code>[4,3,5,1,2]</code> 的弹出顺序，要求 4，3，5 必须在 1，2 前弹出，且 1，2 不能弹出，但是这样压入的顺序，1 又不能在 2 之前弹出，所以无法形成的，返回 false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 辅助栈模拟出入栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsPopOrder</span><span class="params">(<span class="type">int</span> [] pushA,<span class="type">int</span> [] popA)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pushA.length;</span><br><span class="line">        <span class="comment">// 辅助栈</span></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历入栈的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历出栈的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="comment">// 入栈：栈为空或者栈顶不等于出栈数组</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; (s.isEmpty() || s.peek() != popA[i])) &#123;</span><br><span class="line">                s.push(pushA[j]);</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈顶等于出栈数组</span></span><br><span class="line">            <span class="keyword">if</span> (s.peek() == popA[i]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ73-翻转单词序列"><a href="#JZ73-翻转单词序列" class="headerlink" title="JZ73 翻转单词序列"></a>JZ73 翻转单词序列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串 双指针</p>
<p><strong>描述</strong></p>
<p>牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>数据范围：1≤n≤100<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)，保证没有只包含空格的字符串</p>
<p><strong>示例 1</strong><br>输入: “nowcoder. a am I”<br>返回值: “I am a nowcoder.”<br><strong>示例 2</strong><br>输入: “”<br>返回值: “”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ReverseSentence</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span>[] cs = str.toCharArray();</span><br><span class="line">        <span class="comment">// 翻转句子</span></span><br><span class="line">        reverse(cs, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 以空格为界找到一个单词</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; cs[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; cs[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将单词翻转</span></span><br><span class="line">            reverse(cs, i, j - <span class="number">1</span>);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            swap(cs, l ++, r --);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> cs[l];</span><br><span class="line">        cs[l] = cs[r];</span><br><span class="line">        cs[r] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ59-滑动窗口的最大值"><a href="#JZ59-滑动窗口的最大值" class="headerlink" title="JZ59 滑动窗口的最大值"></a>JZ59 滑动窗口的最大值</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 堆 双指针 队列</p>
<p><strong>描述</strong></p>
<p>给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组 <code>&#123;2,3,4,2,6,2,5,1&#125;</code> 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 <code>&#123;4,4,6,6,6,5&#125;</code>；针对数组 <code>&#123;2,3,4,2,6,2,5,1&#125;</code> 的滑动窗口有以下 6 个：<code>&#123;[2,3,4],2,6,2,5,1&#125;</code>, <code>&#123;2,[3,4,2],6,2,5,1&#125;</code>, <code>&#123;2,3,[4,2,6],2,5,1&#125;</code>, <code>&#123;2,3,4,[2,6,2],5,1&#125;</code>, <code>&#123;2,3,4,2,[6,2,5],1&#125;</code>, <code>&#123;2,3,4,2,6,[2,5,1]&#125;</code>。</p>
<p>数据范围：1≤size≤n≤10000，数组中每个元素的值满足 ∣val∣≤10000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>[2,3,4,2,6,2,5,1],3</code><br>返回值: <code>[4,4,6,6,6,5]</code><br><strong>示例 2</strong><br>输入: <code>[9,10,9,-7,-3,8,2,-6],5</code><br>返回值: <code>[10,10,9,8]</code><br><strong>示例 3</strong><br>输入: <code>[1,2,3,4],3</code><br>返回值: <code>[3,4]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 依次移动窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= num.length - size; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxIndex) &#123;</span><br><span class="line">                maxIndex = findMax(num, i, r);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[r] &gt;= num[maxIndex]) &#123;</span><br><span class="line">                maxIndex = r;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(num[maxIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt;= r; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt;= num[minIndex]) &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 用双向队列记递减序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里本不需要这个判断，但是提供的用例和题目中的条件不符</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || size &gt; num.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双向队列</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 遍历第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            addMaxDeque(num, dq, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历后续元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= num.length - size; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; i &gt; dq.peekFirst()) &#123;</span><br><span class="line">                dq.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            addMaxDeque(num, dq, r);</span><br><span class="line">            res.add(num[dq.peekFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addMaxDeque</span><span class="params">(<span class="type">int</span>[] num, ArrayDeque&lt;Integer&gt; dq, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; num[dq.peekLast()] &lt;= num[i]) &#123;</span><br><span class="line">            dq.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><h4 id="JZ53-数字在升序数组中出现的次数"><a href="#JZ53-数字在升序数组中出现的次数" class="headerlink" title="JZ53 数字在升序数组中出现的次数"></a>JZ53 数字在升序数组中出现的次数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组 二分</p>
<p><strong>描述</strong></p>
<p>给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数</p>
<p>数据范围：0≤n≤1000,0≤k≤100，数组中每个元素的值满足 0≤val≤100<br>要求：空间复杂度 O(1)，时间复杂度 O(logn)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,3,3,3,4,5],3</code><br>返回值: 4<br><strong>示例 2</strong><br>输入: <code>[1,3,4,5],6</code><br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1: 二分法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetNumberOfK</span><span class="params">(<span class="type">int</span> [] array , <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(array, k, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt; array.length &amp;&amp; array[i] == array[index]; i ++) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; array[i] == array[index]; i --) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIndex(array, k, l, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIndex(array, k, mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 二分法查找目标值加减0.5的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bisearch</span><span class="params">(<span class="type">int</span>[] data, <span class="type">double</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> data.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分左右界</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &lt; k)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &gt; k)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetNumberOfK</span><span class="params">(<span class="type">int</span> [] array , <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//分别查找k+0.5和k-0.5应该出现的位置，中间的部分就全是k</span></span><br><span class="line">        <span class="keyword">return</span> bisearch(array, k + <span class="number">0.5</span>) - bisearch(array, k - <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ4-二维数组中的查找"><a href="#JZ4-二维数组中的查找" class="headerlink" title="JZ4 二维数组中的查找"></a>JZ4 二维数组中的查找</h4><p>时间限制: 1 秒 空间限制: 64M<br>本题知识点: 数组<br>题目描述<br>在一个二维数组 array 中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1,2,8,9],</span><br><span class="line">[2,4,9,12],</span><br><span class="line">[4,7,10,13],</span><br><span class="line">[6,8,11,15]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target &#x3D; 7，返回 true。<br>给定 target &#x3D; 3，返回 false。</p>
<p>数据范围：矩阵的长宽满足 0≤n,m≤500 ， 矩阵中的值满足 0≤val≤10<sup>9</sup><br>进阶：空间复杂度 O(1)，时间复杂度 O(n+m)</p>
<p><strong>示例 1</strong><br>输入: <code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code><br>返回值: true<br>说明：存在 7，返回 true<br><strong>示例 2</strong><br>输入: <code>1,[[2]]</code><br>返回值: false<br><strong>示例 3</strong><br>输入：<code>3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code><br>返回值：false<br>说明：不存在 3，返回 false</p>
<p>答案:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> [][] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> rows - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[row][col] &gt; target) &#123;</span><br><span class="line">                row --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[row][col] &lt; target) &#123;</span><br><span class="line">                col ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ11-旋转数组的最小数字"><a href="#JZ11-旋转数组的最小数字" class="headerlink" title="JZ11 旋转数组的最小数字"></a>JZ11 旋转数组的最小数字</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 二分</p>
<p><strong>描述</strong></p>
<p>有一个长度为 n 的非降序数组，比如 <code>[1,2,3,4,5]</code>，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了 <code>[3,4,5,1,2]</code>，或者 <code>[4,5,1,2,3]</code>这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000<br>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p>
<p><strong>示例 1</strong><br>输入: <code>[3,4,5,1,2]</code><br>返回值: 1<br><strong>示例 2</strong><br>输入: <code>[3,100,200,3]</code><br>返回值: 3</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1，arr[mid] &gt; target：4 5 6 1 2 3</span></span><br><span class="line"><span class="comment">// arr[mid] 为 6， target为右端点 3， arr[mid] &gt; target, 说明[first ... mid] 都是 &gt;= target 的，因为原始数组是非递减，所以可以确定答案为 [mid+1...last]区间,所以 first = mid + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2，arr[mid] &lt; target:5 6 1 2 3 4</span></span><br><span class="line"><span class="comment">// arr[mid] 为 1， target为右端点 4， arr[mid] &lt; target, 说明答案肯定不在[mid+1...last]，但是arr[mid] 有可能是答案,所以答案在[first, mid]区间，所以last = mid;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况3，arr[mid] == target:</span></span><br><span class="line"><span class="comment">// 如果是 1 0 1 1 1， arr[mid] = target = 1, 显然答案在左边</span></span><br><span class="line"><span class="comment">// 如果是 1 1 1 0 1, arr[mid] = target = 1, 显然答案在右边</span></span><br><span class="line"><span class="comment">// 所以这种情况，不能确定答案在左边还是右边，那么就让last = last - 1;慢慢缩少区间，同时也不会错过答案。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution2(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(array).min().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">            <span class="comment">// 提前退出</span></span><br><span class="line">            <span class="keyword">if</span> (array[first] &lt; array[last]) &#123;</span><br><span class="line">                <span class="keyword">return</span> array[first];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (last - first) / <span class="number">2</span> + first;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; array[last]) &#123;</span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; array[last]) &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ38-字符串的排列"><a href="#JZ38-字符串的排列" class="headerlink" title="JZ38 字符串的排列"></a>JZ38 字符串的排列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串 递归</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。<br>例如输入字符串 ABC,则输出由字符 A,B,C 所能排列出来的所有字符串 ABC,ACB,BAC,BCA,CBA 和 CAB。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB"></p>
<p>数据范围：n &lt; 10<br>要求：空间复杂度 O(n!)，时间复杂度 O(n!)<br>输入描述：<br>输入一个字符串,长度不超过 10,字符只包括大小写字母。</p>
<p><strong>示例 1</strong><br>输入: “ab”<br>返回值: <code>[&quot;ab&quot;,&quot;ba&quot;]</code><br>说明: 返回 <code>[&quot;ba&quot;,&quot;ab&quot;]</code> 也是正确的<br><strong>示例 2</strong><br>输入: “aab”<br>返回值: <code>[&quot;aab&quot;,&quot;aba&quot;,&quot;baa&quot;]</code><br><strong>示例 3</strong><br>输入: “abc”<br>返回值: <code>[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code><br><strong>示例 4</strong><br>输入: “”<br>返回值: <code>[]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">Permutation</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 转换数组</span></span><br><span class="line">       <span class="type">char</span>[] charStr = str.toCharArray();</span><br><span class="line">       <span class="comment">// 按字典序排序</span></span><br><span class="line">       Arrays.sort(charStr);</span><br><span class="line">       <span class="comment">// 标记每个位置的字符是否被使用过</span></span><br><span class="line">       <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[str.length()];</span><br><span class="line">       Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="comment">// 递归获取</span></span><br><span class="line">       recursion(res, charStr, tmp, vis);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(ArrayList&lt;String&gt; res, <span class="type">char</span>[] str, StringBuilder tmp, <span class="type">boolean</span>[] vis)</span> &#123;</span><br><span class="line">        <span class="comment">// 临时字符串满了加入输出</span></span><br><span class="line">        <span class="keyword">if</span> (tmp.length() == str.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">String</span>(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历所有元素选取一个加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i ++) &#123;</span><br><span class="line">            <span class="comment">// 如果该元素已经被加入了，则不需要再加入了</span></span><br><span class="line">            <span class="keyword">if</span>  (vis[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了</span></span><br><span class="line">            <span class="keyword">if</span>  (i &gt; <span class="number">0</span> &amp;&amp; str[i - <span class="number">1</span>] == str[i] &amp;&amp; vis[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记为使用过</span></span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 加入临时字符串</span></span><br><span class="line">            tmp.append(str[i]);</span><br><span class="line">            recursion(res, str, tmp, vis);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            tmp.deleteCharAt(tmp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ44-数字序列中某一位的数字"><a href="#JZ44-数字序列中某一位的数字" class="headerlink" title="JZ44 数字序列中某一位的数字"></a>JZ44 数字序列中某一位的数字</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 模拟</p>
<p><strong>描述</strong></p>
<p>数字以 0123456789101112131415… 的格式作为一个字符序列，在这个序列中第 2 位（从下标 0 开始计算）是 2 ，第 10 位是 1 ，第 13 位是 1 ，以此类题，请你输出第 n 位对应的数字。</p>
<p>数据范围：0&lt;&#x3D;n&lt;&#x3D;10^9</p>
<p><strong>示例 1</strong><br>输入: 0<br>返回值: 0<br><strong>示例 2</strong><br>输入: 2<br>返回值: 2<br><strong>示例 3</strong><br>输入: 10<br>返回值: 1<br><strong>示例 4</strong><br>输入: 13<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 位数减法</span></span><br><span class="line"><span class="comment">// 找规律:</span></span><br><span class="line"><span class="comment">// 小于10的数字一位数，1～9，共9个数字，9位；</span></span><br><span class="line"><span class="comment">// 小于100的数字两位数，10～99，共90个数字，180位；</span></span><br><span class="line"><span class="comment">// 小于1000的数字三位数，100～999，共900个数字，2700位；</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 记录n是几位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录当前位数区间的起始数字: 1,10,100...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录当前区间之前总共有多少位数字</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="comment">// 将n定位在某个位数的区间中</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; sum) &#123;</span><br><span class="line">            n -= sum;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digit ++;</span><br><span class="line">            sum = <span class="number">9</span> * start * digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位n在哪个数字上</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + (start + (n - <span class="number">1</span>) / digit);</span><br><span class="line">        <span class="comment">// 定位n在数字的哪一位上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) % digit;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(num.charAt(index)) - (<span class="type">int</span>)(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="JZ42-连续子数组的最大和"><a href="#JZ42-连续子数组的最大和" class="headerlink" title="JZ42 连续子数组的最大和"></a>JZ42 连续子数组的最大和</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划 贪心</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 的整型数组 array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为 1。求所有子数组的和的最大值。<br>数据范围:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 2 * 10^5</span><br><span class="line">-100 &lt;= a[i] &lt;= 100</span><br></pre></td></tr></table></figure>

<p>要求:时间复杂度为 O(n)，空间复杂度为 O(n)<br>进阶:时间复杂度为 O(n)，空间复杂度为 O(1)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,-2,3,10,-4,7,2,-5]</code><br>返回值: 18<br>说明: 经分析可知，输入数组的子数组 <code>[3,10,-4,7,2]</code> 可以求得最大和为 18<br><strong>示例 2</strong><br>输入: <code>[2]</code><br>返回值: 2<br><strong>示例 3</strong><br>输入: <code>[-10]</code><br>返回值: -10</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法: 动态规划，列出状态转移方程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FindGreatestSumOfSubArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> lastMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">            lastMax = Math.max(lastMax + array[i], array[i]);</span><br><span class="line">            <span class="keyword">if</span> (lastMax &gt; max) &#123;</span><br><span class="line">                max = lastMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ85-连续子数组的最大和-二"><a href="#JZ85-连续子数组的最大和-二" class="headerlink" title="JZ85 连续子数组的最大和(二)"></a>JZ85 连续子数组的最大和(二)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 贪心 动态规划 数组 双指针</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 的整型数组 array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。</p>
<ol>
<li>子数组是连续的，比如 <code>[1,3,5,7,9]</code> 的子数组有 <code>[1,3]，[3,5,7]</code> 等等，但是 <code>[1,3,7]</code> 不是子数组</li>
<li>如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个</li>
<li>该题定义的子数组的最小长度为 1，不存在为空的子数组，即不存在[]是某个数组的子数组</li>
<li>返回的数组不计入空间复杂度计算</li>
</ol>
<p>数据范围:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&lt;=n&lt;=10^5</span><br><span class="line">-100 &lt;= a[i] &lt;= 100</span><br></pre></td></tr></table></figure>

<p>要求:时间复杂度 O(n)，空间复杂度 O(n)<br>进阶:时间复杂度 O(n)，空间复杂度 O(1)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,-2,3,10,-4,7,2,-5]</code><br>返回值: <code>[3,10,-4,7,2]</code><br>说明: 经分析可知，输入数组的子数组 <code>[3,10,-4,7,2]</code> 可以求得最大和为 18，故返回 <code>[3,10,-4,7,2]</code><br><strong>示例 2</strong><br>输入: <code>[1]</code><br>返回值: <code>[1]</code><br><strong>示例 3</strong><br>输入: <code>[1,2,-3,4,-1,1,-3,2]</code><br>返回值: <code>[1,2,-3,4,-1,1]</code><br>说明: 经分析可知，最大子数组的和为 4，有 <code>[4],[4,-1,1],[1,2,-3,4],[1,2,-3,4,-1,1]</code>，故返回其中长度最长的 <code>[1,2,-3,4,-1,1]</code><br><strong>示例 4</strong><br>输入: <code>[-2,-1]</code><br>返回值: <code>[-1]</code><br>说明: 子数组最小长度为 1，故返回 <code>[-1]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划，列出状态转移方程，记录对应状态即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] FindGreatestSumOfSubArray (<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> lastMax;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastStartIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> array[i];</span><br><span class="line">            <span class="comment">// 求最长子串，所以这里是&gt;=</span></span><br><span class="line">            <span class="keyword">if</span> (lastMax + num &gt;= num) &#123;</span><br><span class="line">                lastMax += num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastMax = num;</span><br><span class="line">                lastStartIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求最长子串，所以这里是&gt;=</span></span><br><span class="line">            <span class="keyword">if</span> (lastMax &gt;= max) &#123;</span><br><span class="line">                max = lastMax;</span><br><span class="line">                startIndex = lastStartIndex;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(array, startIndex, maxIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ69-跳台阶"><a href="#JZ69-跳台阶" class="headerlink" title="JZ69 跳台阶"></a>JZ69 跳台阶</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 递归 动态规划 记忆化搜索</p>
<p><strong>描述</strong></p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>数据范围：1≤n≤40<br>要求：时间复杂度：O(n)，空间复杂度：O(1)</p>
<p><strong>示例 1</strong><br>输入: 2<br>返回值: 2<br>说明: 青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为 2<br><strong>示例 2</strong><br>输入: 7<br>返回值: 21</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= target; i ++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ10-斐波那契数列"><a href="#JZ10-斐波那契数列" class="headerlink" title="JZ10 斐波那契数列"></a>JZ10 斐波那契数列</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组 动态规划 记忆化搜索 快速幂 递归</p>
<p><strong>描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。<br>要求：空间复杂度 O(1)，时间复杂度 O(n) ，本题也有时间复杂度 O(logn) 的解法</p>
<p><strong>示例 1</strong><br>输入: 4<br>返回值: 3<br><strong>示例 2</strong><br>输入: 1<br>返回值: 1<br><strong>示例 3</strong><br>输入: 2<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution1(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans[i] = ans[i-<span class="number">1</span>] + ans[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solution2(n - <span class="number">2</span>) + solution2(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ19-正则表达式匹配"><a href="#JZ19-正则表达式匹配" class="headerlink" title="JZ19 正则表达式匹配"></a>JZ19 正则表达式匹配</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串 动态规划 递归</p>
<p><strong>描述</strong></p>
<p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。 1.模式中的字符’.’表示任意一个字符 2.模式中的字符’</em>‘表示它前面的字符可以出现任意次（包含 0 次）。<br>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>数据范围:<br>1.str 只包含从 a-z 的小写字母。<br>2.pattern 只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。 3. 0≤str.length≤26 4. 0≤pattern.length≤26</p>
<p><strong>示例 1</strong><br>输入: “aaa”,”a<em>a”<br>返回值: true<br>说明: 中间的</em>可以出现任意次的 a，所以可以出现 1 次 a，能匹配上<br><strong>示例 2</strong><br>输入: “aad”,”c<em>a</em>d”<br>返回值: true<br>说明: 因为这里 c 为 0 个，a 被重复一次， _ 表示零个或多个 a。因此可以匹配字符串 “aad”。<br><strong>示例 3</strong><br>输入: “a”,”.<em>“<br>返回值: true<br>说明: “.</em>“ 表示可匹配零个或多个（’_’）任意字符（’.’）<br><strong>示例 4</strong><br>输入: “aaab”,”a<em>a</em>a*c”<br>返回值: false</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="comment">// 解法1: java中的正则匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span> <span class="params">(String str, String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> Pattern.matches(pattern, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解法2: 动态规划</span></span><br><span class="line"><span class="comment">// 具体做法：</span></span><br><span class="line"><span class="comment">// step 1：设dp[i][j]表示str前i个字符和pattern前j个字符是否匹配。（需要注意这里的i，j是长度，比对应的字符串下标要多1）</span></span><br><span class="line"><span class="comment">// step 2： （初始条件） 首先，毋庸置疑，两个空串是直接匹配，因此dp[0][0]=truedp[0][0]=truedp[0][0]=true。然后我们假设str字符串为空，那么pattern要怎么才能匹配空串呢？答案是利用&#x27;*&#x27;字符出现0次的特性。遍历pattern字符串，如果遇到&#x27;*&#x27;意味着它前面的字符可以出现0次，要想匹配空串也只能出现0，那就相当于考虑再前一个字符是否能匹配，因此dp[0][i]=dp[0][i−2]dp[0][i] = dp[0][i - 2]dp[0][i]=dp[0][i−2]。</span></span><br><span class="line"><span class="comment">// step 3： （状态转移） 然后分别遍历str与pattern的每个长度，开始寻找状态转移。首先考虑字符不为&#x27;*&#x27;的简单情况，只要遍历到的两个字符相等，或是pattern串中为&#x27;.&#x27;即可匹配，因此最后一位匹配，即查看二者各自前一位是否能完成匹配，即dp[i][j]=dp[i−1][j−1]dp[i][j] = dp[i - 1][j - 1]dp[i][j]=dp[i−1][j−1]。然后考虑&#x27;*&#x27;出现的情况：</span></span><br><span class="line"><span class="comment">// 1. pattern[j - 2] == &#x27;.&#x27; || pattern[j - 2] == str[i - 1]：即pattern前一位能够多匹配一位，可以用&#x27;*&#x27;让它多出现一次或是不出现，因此有转移方程: dp[i][j] = dp[i - 1][j] || dp[i][j - 2]</span></span><br><span class="line"><span class="comment">// 2. 不满足上述条件，只能不匹配，让前一个字符出现0次，dp[i][j] = dp[i][j - 2].</span></span><br><span class="line"><span class="comment">// 原答案: https://blog.nowcoder.net/n/a3d770a390da4683aa6e6a9020d59945</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span> <span class="params">(String str, String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">        <span class="comment">// dp[i][j]表示str前i个字符和pattern前j个字符是否匹配</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 遍历str每个长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n1; i ++) &#123;</span><br><span class="line">            <span class="comment">// 遍历pattern每个长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n2; j ++) &#123;</span><br><span class="line">                <span class="comment">// 空正则的情况</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = i == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 非空的情况下 星号、点号、字符</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当前字符不为*，用.去匹配或者字符直接相同</span></span><br><span class="line">                    <span class="keyword">if</span> (pattern.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (str.charAt(i - <span class="number">1</span>) == pattern.charAt(j - <span class="number">1</span>) || pattern.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 当前字符是*</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若是前一位为.或者前一位可以与这个数字匹配</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (str.charAt(i - <span class="number">1</span>) == pattern.charAt(j - <span class="number">2</span>) || pattern.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ71-跳台阶扩展问题"><a href="#JZ71-跳台阶扩展问题" class="headerlink" title="JZ71 跳台阶扩展问题"></a>JZ71 跳台阶扩展问题</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划 递归 记忆化搜索</p>
<p><strong>描述</strong></p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶(n 为正整数)总共有多少种跳法。</p>
<p>数据范围：1≤n≤20<br>进阶：空间复杂度 O(1) ， 时间复杂度 O(1)</p>
<p><strong>示例 1</strong><br>输入: 3<br>返回值: 4<br><strong>示例 2</strong><br>输入: 1<br>返回值: 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题思路：</span></span><br><span class="line"><span class="comment">// 设f[i] 表示 当前跳道第 i 个台阶的方法数。那么f[n]就是所求答案。</span></span><br><span class="line"><span class="comment">// 假设现在已经跳到了第 n 个台阶，那么前一步可以从哪些台阶到达呢？</span></span><br><span class="line"><span class="comment">// 如果上一步跳 1 步到达第 n 个台阶，说明上一步在第 n-1 个台阶。已知跳到第n-1个台阶的方法数为f[n-1]</span></span><br><span class="line"><span class="comment">// 如果上一步跳 2 步到达第 n 个台阶，说明上一步在第 n-2 个台阶。已知跳到第n-2个台阶的方法数为f[n-2]</span></span><br><span class="line"><span class="comment">// 。。。</span></span><br><span class="line"><span class="comment">// 如果上一步跳 n 步到达第 n 个台阶，说明上一步在第 0 个台阶。已知跳到 第0个台阶的方法数为f[0]</span></span><br><span class="line"><span class="comment">// 那么总的方法数就是所有可能的和。也就是f[n] = f[n-1] + f[n-2] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 显然初始条件f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// 所以我们就可以先求f[2]，然后f[3]...f[n-1]， 最后f[n]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++ j) &#123;</span><br><span class="line">                f[i] += f[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 对于方法一中的：f[n] = f[n-1] + f[n-2] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 那么f[n-1] 为多少呢？</span></span><br><span class="line"><span class="comment">// f[n-1] = f[n-2] + f[n-3] + ... + f[0]</span></span><br><span class="line"><span class="comment">// 所以一合并，f[n] = 2*f[n-1]，初始条件f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// 所以可以采用递归，记忆化递归，动态规划，递推。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            b = a &lt;&lt; <span class="number">1</span>; <span class="comment">//  口诀：左移乘2，右移除2</span></span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 这时候，你会发现一个规律：</span></span><br><span class="line"><span class="comment">// f[0] = f[1] = 1</span></span><br><span class="line"><span class="comment">// f[2] = 2 = 2&lt;&lt;0 = 1&lt;&lt;1</span></span><br><span class="line"><span class="comment">// f[3] = 4 = 2&lt;&lt;1 = 1&lt;&lt;2</span></span><br><span class="line"><span class="comment">// f[4] = 8 = 2&lt;&lt;2 = 1&lt;&lt;3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ70-矩形覆盖"><a href="#JZ70-矩形覆盖" class="headerlink" title="JZ70 矩形覆盖"></a>JZ70 矩形覆盖</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 递归 动态规划</p>
<p><strong>描述</strong></p>
<p>我们可以用 2<em>1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2</em>1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？</p>
<p>数据范围：0≤n≤38<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>注意：约定 n &#x3D;&#x3D; 0 时，输出 0</p>
<p>比如 n&#x3D;3 时，2*3 的矩形块有 3 种不同的覆盖方法(从同一个方向看):</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995"></p>
<p><strong>示例 1</strong><br>输入: 0<br>返回值: 0<br><strong>示例 2</strong><br>输入: 1<br>返回值: 1<br><strong>示例 3</strong><br>输入: 4<br>返回值: 5</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题思路：</span></span><br><span class="line"><span class="comment">// 因为小矩形长宽是2*1，所以每次新增加的一列，如果竖着放对应的情况与 target 为 n-1 时相同；如果横着放，对应的情况与 target 为 n-2 时相同。所以：f[n] = f[n-1] + f[n-2]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rectCover</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= target; i ++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ63-买卖股票的最好时机-一"><a href="#JZ63-买卖股票的最好时机-一" class="headerlink" title="JZ63 买卖股票的最好时机(一)"></a>JZ63 买卖股票的最好时机(一)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划 贪心</p>
<p><strong>描述</strong></p>
<p>假设你有一个数组 prices，长度为 n，其中 <code>prices[i]</code> 是股票在第 i 天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 2.如果不能获取到任何利润，请返回 0 3.假设买入卖出均无手续费</p>
<p>数据范围： 0≤n≤10^5, 0≤val≤10^4</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: <code>[8,9,2,5,4,7,1]</code><br>返回值: 5<br>说明: 在第 3 天(股票价格 &#x3D; 2)的时候买入，在第 6 天(股票价格 &#x3D; 7)的时候卖出，最大利润 &#x3D; 7-2 &#x3D; 5 ，不能选择在第 2 天买入，第 3 天卖出，这样就亏损 7 了；同时，你也不能在买入前卖出股票。<br><strong>示例 2</strong><br>输入: <code>[2,4,1]</code><br>返回值: 2<br><strong>示例 3</strong><br>输入: <code>[3,2,1]</code><br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span> <span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//dp[i][0]表示某一天不持股到该天为止的最大收益，dp[i][1]表示某天持股，到该天为止的最大收益</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//第一天不持股，总收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一天持股，总收益为减去该天的股价</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历后续每天，状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一天不持股，到该天为止的最大收益</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ47-礼物的最大价值"><a href="#JZ47-礼物的最大价值" class="headerlink" title="JZ47 礼物的最大价值"></a>JZ47 礼物的最大价值</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划 数组</p>
<p><strong>描述</strong></p>
<p>在一个 m * n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<br>如输入这样的一个二维数组，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1,3,1],</span><br><span class="line">[1,5,1],</span><br><span class="line">[4,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为 12</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0&lt;grid.length≤200</span><br><span class="line">0&lt;grid[0].length≤200</span><br></pre></td></tr></table></figure>

<p><strong>示例 1</strong><br>输入: <code>[[1,3,1],[1,5,1],[4,2,1]]</code><br>返回值: 12</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span> <span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j ++) &#123;</span><br><span class="line">                <span class="comment">// 取左边或者上面最大值加上当前格子的值</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ48-最长不含重复字符的子字符串"><a href="#JZ48-最长不含重复字符的子字符串" class="headerlink" title="JZ48 最长不含重复字符的子字符串"></a>JZ48 最长不含重复字符的子字符串</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串 哈希 双指针</p>
<p><strong>描述</strong></p>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br>数据范围:<br>s.length≤40000</p>
<p><strong>示例 1</strong><br>输入: “abcabcbb”<br>返回值: 3<br>说明: 因为无重复字符的最长子串是”abc”，所以其长度为 3。<br><strong>示例 2</strong><br>输入: “bbbbb”<br>返回值: 1<br>说明: 因为无重复字符的最长子串是”b”，所以其长度为 1。<br><strong>示例 3</strong><br>输入: “pwwkew”<br>返回值: 3<br>说明: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法1: 双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 哈希表记录窗口内非重复的字符</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置窗口左右边界</span></span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; right &lt; cs.length; right ++) &#123;</span><br><span class="line">            <span class="comment">// 窗口右移进入哈希表统计出现次数</span></span><br><span class="line">            map.merge(cs[right], <span class="number">1</span>, Integer::sum);</span><br><span class="line">            <span class="comment">// 出现次数大于1，则窗口内有重复</span></span><br><span class="line">            <span class="keyword">while</span> (map.get(cs[right]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 窗口左移，同时减去该字符的出现次数</span></span><br><span class="line">                map.merge(cs[left ++], -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 维护子串长度最大值</span></span><br><span class="line">            res = Math.max(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2: 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希表记录窗口内非重复的字符及其下标</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i]表示以下标i结尾的字符串最长不含重复子串的长度</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 哈希表中没有，说明不重复</span></span><br><span class="line">            <span class="keyword">if</span>(!mp.containsKey(s.charAt(i - <span class="number">1</span>)))</span><br><span class="line">                <span class="comment">//前一个加1</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 遇到重复字符</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = Math.min(dp[i - <span class="number">1</span>] + <span class="number">1</span>, i - mp.get(s.charAt(i - <span class="number">1</span>)));</span><br><span class="line">            <span class="comment">// 加入哈希表</span></span><br><span class="line">            mp.put(s.charAt(i - <span class="number">1</span>), i);</span><br><span class="line">            <span class="comment">// 维护最大值</span></span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ46-把数字翻译成字符串"><a href="#JZ46-把数字翻译成字符串" class="headerlink" title="JZ46 把数字翻译成字符串"></a>JZ46 把数字翻译成字符串</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 动态规划</p>
<p><strong>描述</strong></p>
<p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p>
<p>现在给一串数字，返回有多少种可能的译码结果</p>
<p>数据范围：字符串长度满足 0&lt;n≤90<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: “12”<br>返回值: 2<br>说明: 2 种可能的译码结果（”ab” 或”l”）<br><strong>示例 2</strong><br>输入: “31717126241541717”<br>返回值: 192<br>说明: 192 种可能的译码结果</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 解法: 动态规划，需要考虑无法编译的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solve</span> <span class="params">(String nums)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 排除0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 辅助数组初始化为1</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= nums.length(); i ++) &#123;</span><br><span class="line">            <span class="comment">// 当0的前面部署1或2时，无法译码，0种</span></span><br><span class="line">            <span class="keyword">if</span> (nums.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在11-19，21-26之间的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nums.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                || (nums.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums.charAt(i - <span class="number">1</span>) &lt; <span class="string">&#x27;7&#x27;</span>)) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="JZ12"><a href="#JZ12" class="headerlink" title="JZ12"></a>JZ12</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ13"><a href="#JZ13" class="headerlink" title="JZ13"></a>JZ13</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="JZ3"><a href="#JZ3" class="headerlink" title="JZ3"></a>JZ3</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ51"><a href="#JZ51" class="headerlink" title="JZ51"></a>JZ51</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ40"><a href="#JZ40" class="headerlink" title="JZ40"></a>JZ40</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ41"><a href="#JZ41" class="headerlink" title="JZ41"></a>JZ41</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="JZ65"><a href="#JZ65" class="headerlink" title="JZ65"></a>JZ65</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ15-二进制中-1-的个数"><a href="#JZ15-二进制中-1-的个数" class="headerlink" title="JZ15 二进制中 1 的个数"></a>JZ15 二进制中 1 的个数</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>输入一个整数 n ，输出该数 32 位二进制表示中 1 的个数。其中负数用补码表示。</p>
<p>数据范围：−2<sup>31</sup>&lt;&#x3D;n&lt;&#x3D;2<sup>31</sup>−1<br>即范围为: −2147483648&lt;&#x3D;n&lt;&#x3D;2147483647</p>
<p><strong>示例 1</strong><br>输入: 10<br>返回值: 2<br>说明: 十进制中 10 的 32 位二进制表示为 0000 0000 0000 0000 0000 0000 0000 1010，其中有两个 1。<br><strong>示例 2</strong><br>输入: -1<br>返回值: 32<br>说明: 负数使用补码表示，-1 的 32 位二进制表示为 1111 1111 1111 1111 1111 1111 1111 1111，其中 32 个 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution1(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解题思路：</span></span><br><span class="line">    <span class="comment">// 对从右向左的第一位1直接判断，遇到0直接略过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (mark != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; mark) != <span class="number">0</span>) &#123;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">            mark &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ16-数值的整数次方"><a href="#JZ16-数值的整数次方" class="headerlink" title="JZ16 数值的整数次方"></a>JZ16 数值的整数次方</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 基础数学</p>
<p><strong>描述</strong></p>
<p>实现函数 double Power(double base, int exponent)，求 base 的 exponent 次方。</p>
<p>注意： 1.保证 base 和 exponent 不同时为 0。 2.不得使用库函数，同时不需要考虑大数问题 3.有特殊判题，不用考虑小数点后面 0 的位数。</p>
<p>数据范围：|base|≤100，|exponent|≤100,保证最终结果一定满足 |val|≤10<sup>4</sup><br>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p><strong>示例 1</strong><br>输入: 2.00000,3<br>返回值: 8.00000<br><strong>示例 2</strong><br>输入: 2.10000,3<br>返回值: 9.26100<br><strong>示例 3</strong><br>输入: 2.00000,-2<br>返回值: 0.25000<br>说明: 2 的-2 次方等于 1&#x2F;4&#x3D;0.25</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 预处理: b 的 n 次方，当 n 是负数时转换成 1/b 的 n 次方</span></span><br><span class="line"><span class="comment">// 然后暴力解：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            ret *= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 用递归法（快速幂）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q_power(b, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">q_power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> q_power(b, n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">return</span> ret * ret * b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret * ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 用非递归的快速幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> b; <span class="comment">// 记录x^0, x^1, x^2 ...</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ56"><a href="#JZ56" class="headerlink" title="JZ56"></a>JZ56</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ64"><a href="#JZ64" class="headerlink" title="JZ64"></a>JZ64</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="JZ29"><a href="#JZ29" class="headerlink" title="JZ29"></a>JZ29</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ61"><a href="#JZ61" class="headerlink" title="JZ61"></a>JZ61</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ67"><a href="#JZ67" class="headerlink" title="JZ67"></a>JZ67</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JZ20"><a href="#JZ20" class="headerlink" title="JZ20"></a>JZ20</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例 1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例 3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><h4 id="JZ5-替换空格"><a href="#JZ5-替换空格" class="headerlink" title="JZ5 替换空格"></a>JZ5 替换空格</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 字符串</p>
<p><strong>描述</strong></p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。</p>
<p>数据范围: 0≤len(s)≤1000 。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。</p>
<p><strong>示例 1</strong><br>输入: “We Are Happy”<br>返回值: “We%20Are%20Happy”<br><strong>示例 2</strong><br>输入: “ “<br>返回值: “%20”</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法:2：</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                stringBuilder.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ21-调整数组顺序使奇数位于偶数前面-一"><a href="#JZ21-调整数组顺序使奇数位于偶数前面-一" class="headerlink" title="JZ21 调整数组顺序使奇数位于偶数前面(一)"></a>JZ21 调整数组顺序使奇数位于偶数前面(一)</h4><p>时间限制: 1 秒<br>空间限制: 64M<br>知识点: 数组</p>
<p><strong>描述</strong></p>
<p>输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>数据范围：0≤n≤5000，数组中每个数的值 0≤val≤10000<br>要求：时间复杂度 O(n)，空间复杂度 O(n)<br>进阶：时间复杂度 O(n<sup>2</sup>)，空间复杂度 O(1)</p>
<p><strong>示例 1</strong><br>输入: <code>[1,2,3,4]</code><br>返回值: <code>[1,3,2,4]</code><br><strong>示例 2</strong><br>输入: <code>[2,4,6,5,7]</code><br>返回值: <code>[5,7,2,4,6]</code><br><strong>示例 3</strong><br>输入: <code>[1,3,5,6,7]</code><br>返回值: <code>[1,3,5,7,6]</code></p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 用stream特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(array).boxed().sorted(Comparator.comparing(Integer::intValue, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 插入排序思想,时间复杂度 O(n^2)，空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">// 记录已经是奇数的位置下标（视作为有序区域），然后向后遍历，一经发现是奇数则进行“插入排序”，然后有序区下标加1。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//使用插入排序的思想</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 首先是对数值长度进行特判</span></span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录已经是奇数的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i ++)&#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="comment">// 如果该值为偶数</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//该值为奇数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span> (k &gt; j) &#123;</span><br><span class="line">                    <span class="comment">//这区间整体向后移动一位</span></span><br><span class="line">                    array[k] = array[k - <span class="number">1</span>];</span><br><span class="line">                    k --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移位之后将对应的值赋值</span></span><br><span class="line">                array[k] = temp;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果数数组</span></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3：</span></span><br><span class="line"><span class="comment">// 双指针, 一个处理基数，一个处理偶数，时间复杂度 O(n)，空间复杂度 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reOrderArray(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 所给数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="comment">// 辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 双指针：left right并初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 循环终止条件：left &lt; len || right &gt;= 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">numLeft</span> <span class="operator">=</span> left, numRight = right; left &lt; len || right &gt;= <span class="number">0</span>; left ++, right --) &#123;</span><br><span class="line">            <span class="comment">// 处理奇数情况</span></span><br><span class="line">            <span class="keyword">if</span> (array[left] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                num[numLeft] = array[left];</span><br><span class="line">                numLeft++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理偶数情况</span></span><br><span class="line">            <span class="keyword">if</span> (array[right] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                num[numRight] = array[right];</span><br><span class="line">                numRight--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JZ"><a href="#JZ" class="headerlink" title="JZ"></a>JZ</h4><p>时间限制: 1秒<br>空间限制: 64M<br>知识点:</p>
<p><strong>描述</strong></p>
<p><strong>示例1</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例2</strong><br>输入:<br>返回值:<br>说明:<br><strong>示例3</strong><br>输入:<br>返回值:<br>说明:</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="华为机试"><a href="#华为机试" class="headerlink" title="华为机试"></a>华为机试</h2><h3 id="较难"><a href="#较难" class="headerlink" title="较难"></a>较难</h3><h4 id="HJ3-明明的随机数"><a href="#HJ3-明明的随机数" class="headerlink" title="HJ3 明明的随机数"></a>HJ3 明明的随机数</h4><p>时间限制: 1 秒<br>空间限制: 32M<br>知识点: 数组</p>
<p><strong>描述</strong><br>明明生成了 N 个 1 到 500 之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。</p>
<p>数据范围： 1≤n≤1000，输入的数字大小满足 1≤val≤500</p>
<p><strong>输入描述：</strong><br>第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的”示例”。</p>
<p><strong>输出描述：</strong><br>输出多行，表示输入数据处理后的结果</p>
<p><strong>示例 1</strong><br>输入:<br>3<br>2<br>2<br>1<br>返回值:<br>1<br>2<br>说明:<br>输入解释：<br>第一个数字是 3，也即这个小样例的 N&#x3D;3，说明用计算机生成了 3 个 1 到 500 之间的随机整数，接下来每行一个随机数字，共 3 行，也即这 3 个随机数字为：<br>2<br>2<br>1<br>所以样例的输出为：<br>1<br>2</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            numSet.add(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; numList = numSet.stream().sorted().collect(Collectors.toList());</span><br><span class="line">        numList.forEach(num -&gt; &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//获取个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//创建TreeSet进行去重排序</span></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i &lt; num ;i++)&#123;</span><br><span class="line">            set.add(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><h4 id="HJ28-素数伴侣"><a href="#HJ28-素数伴侣" class="headerlink" title="HJ28 素数伴侣"></a>HJ28 素数伴侣</h4><p>时间限制: 1 秒<br>空间限制: 32M<br>知识点: 查找 排序</p>
<p><strong>描述</strong></p>
<p>题目描述<br>若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如 2 和 5、6 和 13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的 N （ N 为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有 4 个正整数：2，5，6，13，如果将 5 和 6 分为一组中只能得到一组“素数伴侣”，而将 2 和 5、6 和 13 编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。</p>
<p>输入:<br>有一个正偶数 n ，表示待挑选的自然数的个数。后面给出 n 个具体的数字。</p>
<p>输出:<br>输出一个整数 K ，表示你求得的“最佳方案”组成“素数伴侣”的对数。</p>
<p>数据范围：1≤n≤100，输入的数据大小满足 2≤val≤30000</p>
<p><strong>输入描述：</strong><br>输入说明<br>1 输入一个正偶数 n<br>2 输入 n 个整数</p>
<p><strong>输出描述：</strong><br>求得的“最佳方案”组成“素数伴侣”的对数。</p>
<p><strong>示例 1</strong><br>输入: 4<br>2 5 6 13<br>返回值: 2<br><strong>示例 2</strong><br>输入: 2<br>3 6<br>返回值: 0<br><strong>示例 3</strong><br>输入: 2<br>3 6<br>返回值: 0</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小技巧！！！素数不是偶数，那么和是素数的话就是奇数+偶数</span></span><br><span class="line">    <span class="comment">// 那么可以分成两堆,一堆偶数，一堆奇数</span></span><br><span class="line">    <span class="comment">// 匈牙利算法，先到先得，能让就让</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">            <span class="comment">// 标准输入</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="comment">// 用于记录输入的n个整数</span></span><br><span class="line">            <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="comment">// 用于存储所有的奇数</span></span><br><span class="line">            ArrayList&lt;Integer&gt; odds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 用于存储所有的偶数</span></span><br><span class="line">            ArrayList&lt;Integer&gt; evens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    odds.add(num);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    evens.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下标对应偶数的下标，值对应这个偶数的伴侣</span></span><br><span class="line">            <span class="type">int</span>[] evenMatch = <span class="keyword">new</span> <span class="title class_">int</span>[evens.size()];</span><br><span class="line">            <span class="comment">// 记录伴侣的对数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; odds.size(); i ++) &#123;</span><br><span class="line">                <span class="comment">// 用于标记对应的偶数是否查找过</span></span><br><span class="line">                <span class="type">boolean</span>[] evenUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[evens.size()];</span><br><span class="line">                <span class="comment">// 如果匹配上，则计数加1</span></span><br><span class="line">                <span class="keyword">if</span> (find(odds.get(i), evens, evenMatch, evenUsed)) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断奇数x能否找到伴侣</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> odd, ArrayList&lt;Integer&gt; evens, <span class="type">int</span>[] evenMatch, <span class="type">boolean</span>[] evenUsed)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; evens.size(); i ++) &#123;</span><br><span class="line">            <span class="comment">// 该位置偶数能与x组成素数伴侣，并且没被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (isPrime(odd + evens.get(i)) &amp;&amp; !evenUsed[i]) &#123;</span><br><span class="line">                evenUsed[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 如果第i个偶数没有伴侣，或者第i个偶数原来有伴侣，并且该伴侣能够重新找到伴侣的话(这里有递归调用)</span></span><br><span class="line">                <span class="comment">// 则奇数x可以设置为第i个偶数的伴侣</span></span><br><span class="line">                <span class="comment">// 这里采用了匈牙利算法，能让则让</span></span><br><span class="line">                <span class="keyword">if</span> (evenMatch[i] == <span class="number">0</span> || find(evenMatch[i], evens, evenMatch, evenUsed)) &#123;</span><br><span class="line">                    evenMatch[i] = odd;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完偶数都没有可以与传入奇数做伴侣的，该奇数只能孤独终老了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= num; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HJ44-Sudoku"><a href="#HJ44-Sudoku" class="headerlink" title="HJ44 Sudoku"></a>HJ44 Sudoku</h4><p>时间限制: 1 秒<br>空间限制: 32M<br>知识点: 思维 基础数学 搜索</p>
<p><strong>描述</strong><br>问题描述：数独（Sudoku）是一款大众喜爱的数字逻辑游戏。玩家需要根据 9X9 盘面上的已知数字，推算出所有剩余空格的数字，并且满足每一行、每一列、每一个 3X3 粗线宫内的数字均含 1-9，并且不重复。</p>
<p>数据范围：输入一个 9*9 的矩阵</p>
<p><strong>输入描述：</strong><br>包含已知数字的 9X9 盘面数组 [空缺位以数字 0 表示]</p>
<p><strong>输出描述：</strong><br>完整的 9X9 盘面数组</p>
<p><strong>示例 1</strong><br>输入:<br>0 9 2 4 8 1 7 6 3<br>4 1 3 7 6 2 9 8 5<br>8 6 7 3 5 9 4 1 2<br>6 2 4 1 9 5 3 7 8<br>7 5 9 8 4 3 1 2 6<br>1 3 8 6 2 7 5 9 4<br>2 7 1 5 3 8 6 4 9<br>3 8 6 9 1 4 2 5 7<br>0 4 5 2 7 6 8 3 1<br>返回值:<br>5 9 2 4 8 1 7 6 3<br>4 1 3 7 6 2 9 8 5<br>8 6 7 3 5 9 4 1 2<br>6 2 4 1 9 5 3 7 8<br>7 5 9 8 4 3 1 2 6<br>1 3 8 6 2 7 5 9 4<br>2 7 1 5 3 8 6 4 9<br>3 8 6 9 1 4 2 5 7<br>9 4 5 2 7 6 8 3 1</p>
<p><strong>答案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从左上角开始去遍历这个数独。</span></span><br><span class="line"><span class="comment">// 对于没有填入的格子（即格子数值为0），我们去枚举1～9每个数字填入，然后根据数独的性质（同行、同列、同一个九宫格不能有相同数字）去判断填入。</span></span><br><span class="line"><span class="comment">// 如果可以成功填完所有格子那么就是找到了答案。找到答案后可以用一个bool变量，然后注意在回溯的地方根据这个变量及时的return，防止已经找到答案后又回溯为0。</span></span><br><span class="line"><span class="comment">// 对于初始化就有值的格子，我们往右走（列数值加一），那么因为一行只有9个，所以当列走到头的时候，列的值变成0，行的值加1（其实就是换到了下一行的开头）。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">            <span class="comment">// 初始化数独</span></span><br><span class="line">            <span class="type">int</span>[][] sd = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++) &#123;</span><br><span class="line">                    sd[i][j] = sc.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 填充数独</span></span><br><span class="line">            dfs(sd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印数独</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++) &#123;</span><br><span class="line">                    System.out.print(sd[i][j]);</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] sd, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">9</span>; k ++) &#123;</span><br><span class="line">                <span class="comment">// check后满足</span></span><br><span class="line">                <span class="keyword">if</span> (check(sd, i, j, k)) &#123;</span><br><span class="line">                    sd[i][j] = k;</span><br><span class="line">                    <span class="comment">// 已经找到答案了，直接return</span></span><br><span class="line">                    <span class="keyword">if</span> (dfs(sd, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没找到答案，回溯</span></span><br><span class="line">                    sd[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(sd, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[][] sd, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 同行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sd[i][k] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sd[k][j] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同九宫格</span></span><br><span class="line">        <span class="comment">// 九宫格行的终点</span></span><br><span class="line">        <span class="comment">// 九宫格列的终点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">limitRow</span> <span class="operator">=</span> i / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limitCol</span> <span class="operator">=</span> j / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> limitRow; k &lt; limitRow + <span class="number">3</span>; k ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> limitCol; l &lt; limitCol + <span class="number">3</span>; l ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sd[k][l] == val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/coding-interviews">https://www.nowcoder.com/ta/coding-interviews</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problemset/top-100-liked-questions/">https://leetcode.com/problemset/top-100-liked-questions/</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E4%B8%93%E9%A2%98/" rel="tag"># 专题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/2018/11/26/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/" rel="prev" title="前端笔记">
                  <i class="fa fa-chevron-left"></i> 前端笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/2019/04/17/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4/" rel="next" title="修改文件、文件夹——创建、修改、访问时间">
                  修改文件、文件夹——创建、修改、访问时间 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Apomelo</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.2/algoliasearch-lite.umd.js" integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.43.1/instantsearch.production.min.js" integrity="sha256-jLNoKrKRDKAOg8JBqkl8jSy2tpqCGQ1/++9QRYtWl8k=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.3/mermaid.min.js","integrity":"sha256-TIYL00Rhw/8WaoUhYTLX9SKIEFdXxg+yMWSLVUbhiLg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"N5VN0ybf5xGuqDFhjzC5RlRL-MdYXbMMI","app_key":"ru1RlOeEotFp87wLFIHucgVu","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
