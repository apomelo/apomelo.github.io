<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"apomelo.cc","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"HQMNR1OKHR","apiKey":"cf13855186697063811959d3e9cf03be","indexName":"apomelo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="部署">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL笔记">
<meta property="og:url" content="https://apomelo.cc/posts/2019/11/21/mysql/index.html">
<meta property="og:site_name" content="Apomelo - 追逐">
<meta property="og:description" content="部署">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-undolog-update1.png">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-undolog-update2.png">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-undolog-update3.png">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-mvcc-1.png">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-mvcc-2.png">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-io-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%BB%B6%E8%BF%9F%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-index-b+tree-1.jpg">
<meta property="og:image" content="https://apomelo.cc/imgs/mysql/mysql-index-b+tree-2.jpg">
<meta property="article:published_time" content="2019-11-20T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-30T16:00:00.000Z">
<meta property="article:author" content="Apomelo">
<meta property="article:tag" content="db">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://apomelo.cc/imgs/mysql/mysql-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="https://apomelo.cc/posts/2019/11/21/mysql/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://apomelo.cc/posts/2019/11/21/mysql/","path":"posts/2019/11/21/mysql/","title":"MySQL笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL笔记 | Apomelo - 追逐</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2KQDESYMZF"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2KQDESYMZF","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?6c01cfc90b27c8f2cf8c97e38b2f117c"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Apomelo - 追逐</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2"><span class="nav-number">1.</span> <span class="nav-text">部署</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0"><span class="nav-number">1.2.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.</span> <span class="nav-text">遇到的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">用户相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7"><span class="nav-number">2.1.1.</span> <span class="nav-text">查看用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="nav-number">2.1.2.</span> <span class="nav-text">创建用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="nav-number">2.1.3.</span> <span class="nav-text">删除用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%9D%83%E9%99%90"><span class="nav-number">2.1.4.</span> <span class="nav-text">显示权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90"><span class="nav-number">2.1.5.</span> <span class="nav-text">授予权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E6%9D%83%E9%99%90"><span class="nav-number">2.1.6.</span> <span class="nav-text">回收权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B7%E6%96%B0%E6%9D%83%E9%99%90"><span class="nav-number">2.1.7.</span> <span class="nav-text">刷新权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SHOW-DATABASES"><span class="nav-number">2.2.</span> <span class="nav-text">SHOW DATABASES</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STATUS"><span class="nav-number">2.3.</span> <span class="nav-text">STATUS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USE"><span class="nav-number">2.4.</span> <span class="nav-text">USE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SHOW-TABLES"><span class="nav-number">2.5.</span> <span class="nav-text">SHOW TABLES</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DESC-table-name"><span class="nav-number">2.6.</span> <span class="nav-text">DESC table_name</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%8A%B6%E6%80%81"><span class="nav-number">2.7.</span> <span class="nav-text">查看表状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">2.8.</span> <span class="nav-text">小技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">3.1.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">3.1.2.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">3.1.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">3.1.4.</span> <span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">数据读取问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB"><span class="nav-number">3.2.1.</span> <span class="nav-text">脏读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">3.2.2.</span> <span class="nav-text">不可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BB%E8%AF%BB"><span class="nav-number">3.2.3.</span> <span class="nav-text">幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.4.</span> <span class="nav-text">不可重复读和幻读的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-uncommitted"><span class="nav-number">3.3.1.</span> <span class="nav-text">Read uncommitted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-committed"><span class="nav-number">3.3.2.</span> <span class="nav-text">Read committed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Repeatable-read"><span class="nav-number">3.3.3.</span> <span class="nav-text">Repeatable read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable"><span class="nav-number">3.3.4.</span> <span class="nav-text">Serializable</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%84%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD-Shared-Everything-%E5%92%8C-share-nothing-%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">数据库构架设计中 Shared Everything 和 share-nothing 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Shared-Everthting"><span class="nav-number">4.1.</span> <span class="nav-text">Shared Everthting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shared-Disk"><span class="nav-number">4.2.</span> <span class="nav-text">Shared Disk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shared-Nothing"><span class="nav-number">4.3.</span> <span class="nav-text">Shared Nothing</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">mysql 存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql-buffer-pool"><span class="nav-number">5.1.</span> <span class="nav-text">mysql buffer pool</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql-%E6%97%A5%E5%BF%97"><span class="nav-number">6.</span> <span class="nav-text">mysql 日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redo-log"><span class="nav-number">6.1.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binlog"><span class="nav-number">6.2.</span> <span class="nav-text">binlog</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.2.1.</span> <span class="nav-text">日志模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Statement%EF%BC%88%E5%9F%BA%E4%BA%8E-SQL-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%89"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">Statement（基于 SQL 语句的复制）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Row%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%89"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">Row（基于行的复制）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mixed%EF%BC%88%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">6.2.1.3.</span> <span class="nav-text">Mixed（混合模式）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undo-log"><span class="nav-number">6.3.</span> <span class="nav-text">undo log</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.3.1.</span> <span class="nav-text">undo log 日志格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log-%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.3.2.</span> <span class="nav-text">undo log 日志类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Update-undo-log-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">Update undo log 执行流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redo-log%E3%80%81binlog%E3%80%81undo-log-%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">redo log、binlog、undo log 区别与作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#update-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">6.5.</span> <span class="nav-text">update 语句的内部流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">6.6.</span> <span class="nav-text">两阶段提交</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVCC-Multi-Version-Concurrency-Control%EF%BC%8C%E5%8D%B3%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">MVCC (Multi-Version Concurrency Control，即多版本并发控制)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-MVCC"><span class="nav-number">7.1.</span> <span class="nav-text">为什么需要 MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">7.1.1.</span> <span class="nav-text">当前读和快照读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC-%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%9F"><span class="nav-number">7.1.2.</span> <span class="nav-text">MVCC 能解决什么问题，好处是？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.2.</span> <span class="nav-text">MVCC 实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="nav-number">7.2.1.</span> <span class="nav-text">隐式字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-%E6%97%A5%E5%BF%97"><span class="nav-number">7.2.2.</span> <span class="nav-text">undo 日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-View-%E8%AF%BB%E8%A7%86%E5%9B%BE"><span class="nav-number">7.2.3.</span> <span class="nav-text">Read View(读视图)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">7.3.</span> <span class="nav-text">MVCC 整体流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">8.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9B%AE%E7%9A%84"><span class="nav-number">8.1.</span> <span class="nav-text">索引目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E7%82%B9"><span class="nav-number">8.2.</span> <span class="nav-text">索引优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-number">8.3.</span> <span class="nav-text">索引原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98-IO-%E4%B8%8E%E9%A2%84%E8%AF%BB"><span class="nav-number">8.3.1.</span> <span class="nav-text">磁盘 IO 与预读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.4.</span> <span class="nav-text">索引的类型和数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree-%E7%B4%A2%E5%BC%95"><span class="nav-number">8.4.1.</span> <span class="nav-text">B+Tree 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB-%E4%B8%80%E6%A3%B5-B-%E6%A0%91%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E8%A1%8C%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">8.4.1.1.</span> <span class="nav-text">InnoDB 一棵 B+ 树可以存放多少行数据？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">8.4.2.</span> <span class="nav-text">哈希索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="nav-number">8.4.3.</span> <span class="nav-text">全文索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">8.4.4.</span> <span class="nav-text">空间数据索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">8.5.</span> <span class="nav-text">聚簇索引和非聚簇索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">8.5.1.</span> <span class="nav-text">聚簇索引的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8A%A3%E5%8A%BF"><span class="nav-number">8.5.2.</span> <span class="nav-text">聚簇索引的劣势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%AF%AF%E5%8C%BA%EF%BC%9A%E6%8A%8A%E4%B8%BB%E9%94%AE%E8%87%AA%E5%8A%A8%E8%AE%BE%E4%B8%BA%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">8.5.3.</span> <span class="nav-text">一个误区：把主键自动设为聚簇索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5"><span class="nav-number">9.1.</span> <span class="nav-text">分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%88%86%E9%A1%B5%E8%AF%AD%E5%8F%A5"><span class="nav-number">9.1.1.</span> <span class="nav-text">基础分页语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%80%E7%89%88"><span class="nav-number">9.1.2.</span> <span class="nav-text">优化第一版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E4%BC%98%E5%8C%96-%EF%BC%88%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%89"><span class="nav-number">9.1.3.</span> <span class="nav-text">再优化 （覆盖索引优化）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">9.2.</span> <span class="nav-text">索引优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93"><span class="nav-number">9.3.</span> <span class="nav-text">水平分库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93"><span class="nav-number">9.4.</span> <span class="nav-text">垂直分库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8"><span class="nav-number">9.5.</span> <span class="nav-text">水平分表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8"><span class="nav-number">9.6.</span> <span class="nav-text">垂直分表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%92%8C%E5%88%86%E8%A1%A8%E5%8C%BA%E5%88%AB"><span class="nav-number">9.7.</span> <span class="nav-text">分库和分表区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93"><span class="nav-number">9.7.1.</span> <span class="nav-text">什么时候水平分表，什么时候水平分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93"><span class="nav-number">9.7.2.</span> <span class="nav-text">什么时候垂直分表，什么时候垂直分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93"><span class="nav-number">9.7.3.</span> <span class="nav-text">什么时候水平分库，什么时候垂直分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8"><span class="nav-number">9.7.4.</span> <span class="nav-text">什么时候水平分表，什么时候垂直分表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">10.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Apomelo</p>
  <div class="site-description" itemprop="description">我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/apomelo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;apomelo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:apomeloc@gmail.com" title="E-Mail → mailto:apomeloc@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2019/11/21/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL笔记 | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-21 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-21T00:00:00+08:00">2019-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-07-01 00:00:00" itemprop="dateModified" datetime="2021-07-01T00:00:00+08:00">2021-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span id="/posts/2019/11/21/mysql/" class="post-meta-item leancloud_visitors" data-flag-title="MySQL笔记" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ubuntu 或者 centos, 更新过仓库之后, 直接用 apt 或者 yum 进行安装即可</p>
<p>安装<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/linux-installation.html">官方文档</a></p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ol>
<li><p>数据库备份, 备份所有数据库配置、系统数据库、自建数据库</p>
</li>
<li><p>确保更新路径是正确的</p>
</li>
<li><p>只能在 GA 版本之间升级</p>
</li>
<li><p>不能跨版本升级, 如: 5.5 —&gt; 5.7 是不支持的, 5.6 —&gt; 5.7 是可以的</p>
</li>
<li><p>跨版本升级最好先把当前版本升级到最新版本, 如 5.6 —&gt; 5.7, 需要先升级到最新的 5.6 版本, 然后再升级到 5.7</p>
</li>
<li><p>同一个大版本可以跨小版本升级, 如 5.7.x —&gt; 5.7.y</p>
</li>
<li><p>升级之前需要对比要升级的版本和当前版本之间的差异, 配置、系统表、server、innodb、sql</p>
</li>
<li><p>其他详细的信息参见 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/upgrading.html">MySQL 官网</a></p>
</li>
</ol>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>问题: 安装完之后怎么更改 root 用户密码都可以直接登录</p>
<p>版本: 5.7.26</p>
<p>原因:</p>
<ol>
<li><p>root 用户的认证插件默认是: auth_socket, 不是 mysql_native_password,</p>
</li>
<li><p>而 auth_socket 插件不关心, 也不需要密码, 它只检查用户是否使用 UNIX 套接字进行连接, 然后比较用户名</p>
</li>
<li><p><strong>如果要配置密码, 需要在同一命令中同时更改插件并设置密码</strong>, 首先更改插件然后设置密码将不起作用, 它将再次回退到 auth_socket</p>
</li>
</ol>
<p>修改密码命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">quit;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改密码还可以用下面两条, 推荐第一个, 第二个会有 warning, 但是认证插件是 auth_socket 的时候必须用上面那个指定认证插件的修改语句</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> <span class="keyword">USER</span> <span class="keyword">SET</span> authentication_string<span class="operator">=</span>PASSWORD(<span class="string">&#x27;密码&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 还可以修改 <span class="operator">/</span>etc<span class="operator">/</span>my.cnf 文件, 添加 <span class="keyword">skip</span><span class="operator">-</span><span class="keyword">grant</span><span class="operator">-</span>tables 或 <span class="keyword">skip</span><span class="operator">-</span><span class="keyword">grant</span><span class="operator">-</span>tables<span class="operator">=</span><span class="number">1</span>,</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 或者直接以 mysqld  <span class="comment">--skip-grant-tables &amp; 方式启动</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 当时没有以这样忽略密码验证的方式启动, 仍然能修改成功</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 该参数一般的使用情况是当 root 用户密码丢失时以此参数作为启动项</span><br></pre></td></tr></table></figure>

<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="用户相关命令"><a href="#用户相关命令" class="headerlink" title="用户相关命令"></a>用户相关命令</h2><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> concat(<span class="string">&#x27;User: &#x27;&#x27;&#x27;</span>,<span class="keyword">user</span>,<span class="string">&#x27;&#x27;&#x27;@&#x27;&#x27;&#x27;</span>,host,<span class="string">&#x27;&#x27;&#x27;;&#x27;</span>) <span class="keyword">as</span> query <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> `test`.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="显示权限"><a href="#显示权限" class="headerlink" title="显示权限"></a>显示权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;user&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> `test`.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">drop</span> <span class="keyword">on</span> <span class="string">&#x27;test&#x27;</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h2 id="SHOW-DATABASES"><a href="#SHOW-DATABASES" class="headerlink" title="SHOW DATABASES"></a>SHOW DATABASES</h2><p>查看所有的数据库, 等同于 SELECT schema_name FROM information_schema.schemata\G 用 \G 替换 “;” 以纵向报表的形式输出结果, 有利于阅读</p>
<h2 id="STATUS"><a href="#STATUS" class="headerlink" title="STATUS"></a>STATUS</h2><p>查看 mysql 数据库的运行状态</p>
<h2 id="USE"><a href="#USE" class="headerlink" title="USE"></a>USE</h2><p>命令选择数据库 例如 USE information_schema, 当使用此命令后<br>SELECT schema_name FROM information_schema.schemata\G, 可以更改为<br>SELECT schema_name FROM schemata\G</p>
<h2 id="SHOW-TABLES"><a href="#SHOW-TABLES" class="headerlink" title="SHOW TABLES"></a>SHOW TABLES</h2><p>查看数据库中的表<br>同样也可以在 information_schema 中查看, SHOW 命令是方便使用的简短模式<br>SELECT table_name FROM tables WHERE table_schema&#x3D;’jblog’;</p>
<h2 id="DESC-table-name"><a href="#DESC-table-name" class="headerlink" title="DESC table_name"></a>DESC table_name</h2><p>查看表结构</p>
<h2 id="查看表状态"><a href="#查看表状态" class="headerlink" title="查看表状态"></a>查看表状态</h2><p>SHOW 条件 或</p>
<p>SHOW STATUS like ‘%条件%’ 或</p>
<p>SHOW VARIABLES LIKE “%条件%” 等</p>
<p>可以查看 engine 数据库引擎, version, row, index 等信息</p>
<p>查询数据库连接:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Max_used_connections%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Threads_connected%&#x27;</span>; #当前连接数</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%table_lock%&#x27;</span>; #表锁定</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>; #行锁定</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%qcache%&#x27;</span>; #查询缓存情况</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Qcache%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Aborted_clients&#x27;</span>; #由于客户没有正确关闭连接已经死掉, 已经放弃的连接数量</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%query_cache%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%binlog%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_connections%&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>查看最大连接数量</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%timeout%&#x27;</span>; #查看超时时间</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_%&#x27;</span>; #查看日志是否启动</span><br></pre></td></tr></table></figure>

<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>当多行命令输入, 发现错误后, 用\c 结束</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>事务具有 ACID 特性, A: 原子性（atomicity, 或称不可分割性）、C: 一致性（consistency）、I: 隔离性（isolation, 又称独立性）、D: 持久性（durability）</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一个事务必须被视为一个不可分割的最小工作单元</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>数据库总是从一个一致性的状态转换到另一个一致性的状态</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>通常来说, 一个事务所做的修改在最终提交之前, 对其他事务是不可见的</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一旦事务提交, 其所做的修改就会永久保存到数据库中</p>
<h2 id="数据读取问题"><a href="#数据读取问题" class="headerlink" title="数据读取问题"></a>数据读取问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>读取未提交数据</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>前后多次读取, 数据内容不一致</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>前后多次读取, 数据总量不一致</p>
<p>当某个事务在读取某个范围内的记录时, 另外一个事务又在该范围内插入新的记录, 当之前的事务再次读取该范围的记录时, 会产生幻行</p>
<h3 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h3><ol>
<li>不可重复读是读取了其他事务更改的数据, 针对 update 操作</li>
<li>幻读是读取了其他事务新增的数据, 针对 insert 和 delete 操作</li>
</ol>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>数据库事务的隔离级别有 4 种, 由低到高分别为 Read uncommitted 、Read committed 、Repeatable read 、Serializable</p>
<h3 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h3><p>读未提交, 顾名思义, 就是一个事务可以读取另一个未提交事务的数据</p>
<p>从性能上来说, 该级别不会比其他的级别好太多, 但是缺乏其他级别的很多好处, 所以除非真的有非常必要的理由, 在实际应用中一般很少使用</p>
<h3 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h3><p>读提交, 顾名思义, 就是一个事务要等另一个事务提交后才能读取数据</p>
<p>大多数数据库系统的默认隔离级别都是 Read committed（但 MySQL 不是）</p>
<h3 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h3><p>重复读, 就是在开始读取数据（事务开启）时, 不再允许修改操作, 保证了在同一个事务中多次读取同样记录的结果是一致的</p>
<p>Repeatable read 是 MySQL 的默认事务隔离级别</p>
<p>InnoDB 通过多版本并发控制（MVCC, Multiversion Concurrency Control）<strong>基本</strong>解决了幻读的问题, MVCC 以乐观锁为理论基础, MVCC 的实现没有固定的规范, 每个数据库都会有不同的实现方式</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable 是最高的事务隔离级别, 在该级别下, 事务串行化顺序执行, 可以避免脏读、不可重复读与幻读</p>
<h1 id="数据库构架设计中-Shared-Everything-和-share-nothing-区别"><a href="#数据库构架设计中-Shared-Everything-和-share-nothing-区别" class="headerlink" title="数据库构架设计中 Shared Everything 和 share-nothing 区别"></a>数据库构架设计中 Shared Everything 和 share-nothing 区别</h1><h2 id="Shared-Everthting"><a href="#Shared-Everthting" class="headerlink" title="Shared Everthting"></a>Shared Everthting</h2><p>一般是针对单个主机, 完全透明共享 CPU&#x2F;MEMORY&#x2F;IO, 并行处理能力是最差的, 典型的代表 SQLServer</p>
<h2 id="Shared-Disk"><a href="#Shared-Disk" class="headerlink" title="Shared Disk"></a>Shared Disk</h2><p>各个处理单元使用自己的私有 CPU 和 Memory, 共享磁盘系统</p>
<p>典型的代表 Oracle Rac, 它是数据共享, 可通过增加节点来提高并行处理的能力, 扩展能力较好</p>
<p>其类似于 SMP（对称多处理）模式, 但是当存储器接口达到饱和的时候, 增加节点并不能获得更高的性能</p>
<h2 id="Shared-Nothing"><a href="#Shared-Nothing" class="headerlink" title="Shared Nothing"></a>Shared Nothing</h2><p>各个处理单元都有自己私有的 CPU&#x2F;内存&#x2F;硬盘等, 不存在共享资源, 类似于 MPP（大规模并行处理）模式, 各处理单元之间通过协议通信, 并行处理和扩展能力更好</p>
<p>典型代表 DB2 DPF 和 hadoop, 各节点相互独立, 各自处理自己的数据, 处理后的结果可能向上层汇总或在节点间流转</p>
<p>我们常说的 Sharding 其实就是 Share Nothing 架构, 它是把某个表从物理存储上被水平分割, 并分配给多台服务器（或多个实例）, 每台服务器可以独立工作, 具备共同的 schema, 比如 MySQL Proxy 和 Google 的各种架构, 只需增加服务器数就可以增加处理能力和容量</p>
<h1 id="mysql-存储结构"><a href="#mysql-存储结构" class="headerlink" title="mysql 存储结构"></a>mysql 存储结构</h1><p><img src="/imgs/mysql/mysql-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="mysql-存储结构"></p>
<h2 id="mysql-buffer-pool"><a href="#mysql-buffer-pool" class="headerlink" title="mysql buffer pool"></a>mysql buffer pool</h2><p>Buffer Pool 其实就是一块内存区域，用来缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘 IO，起到加速访问的作用。</p>
<h1 id="mysql-日志"><a href="#mysql-日志" class="headerlink" title="mysql 日志"></a>mysql 日志</h1><p>mysql 常用日志有以下几种：</p>
<ol>
<li>错误日志</li>
<li>查询日志</li>
<li>慢查询日志</li>
<li>事务日志【redo log（重做日志）、undo log（回滚日志）】</li>
<li>二进制日志【bin log】</li>
</ol>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log 是用于崩溃恢复和事务持久性的机制之一，它是一个循环记录缓冲区，用于记录在事务提交时所做的更改。在事务提交之前，所有的更改都会先被写入 redo log，然后再由数据库引擎写入磁盘。</p>
<p>当系统崩溃或者意外断电时，redo log 会被用来恢复未写入磁盘的事务。MySQL 在启动时会自动检查 redo log 是否需要进行崩溃恢复，并将未完成的事务重做。通过这种方式，redo log 可以保证事务的持久性和数据的一致性。</p>
<blockquote>
<p>redo log 主要有两部分文件组成，重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者是在磁盘中。<br>redo log 是物理格式的日志，记录的是物理数据页面的修改的信息，其 redo log 是顺序写入 redo log file 的物理文件中去的。</p>
</blockquote>
<p>如果 mysql 每次更新操作都要写进磁盘，那么整个过程的 io 成本、磁盘查找成本都会很高，进而影响 mysql 的性能。</p>
<p>针对以上这种情况 mysql 采用了 WAL 技术 (Write-Ahead Logging, 先写日志，再写磁盘) 。</p>
<p>redo log file 由多个物理文件组成，这些文件通常被称为 redo log 组。每个 redo log 组包含一个或多个 redo log 文件，每个文件的大小通常为几十兆到几百兆字节。</p>
<p>每个 redo log 文件都是一个循环缓冲区，它可以记录一定数量的事务更改。当 redo log 文件被写满时，MySQL 将其标记为不可用，然后开始写入下一个 redo log 文件。此时，MySQL 会将最早的 redo log 文件重用，覆盖其中的旧事务更改。</p>
<p>在每个 redo log 文件中，MySQL 将事务更改记录为一系列的日志条目 (log entry)，每个日志条目都包含了一个事务所做的更改。每个日志条目通常包含以下信息：</p>
<ul>
<li>事务 ID：每个事务都有一个唯一的标识符，用于将事务的多个日志条目关联起来。</li>
<li>操作类型：插入、更新或删除等操作类型。</li>
<li>数据对象：被更改的表、行或索引等数据对象。</li>
<li>旧值：在更新或删除操作中，记录被更改前的值。</li>
<li>新值：在插入或更新操作中，记录被更改后的值。</li>
</ul>
<p>当 MySQL 启动时，它会检查最后一个 redo log 文件中的最后一个日志条目，并根据其中的信息确定哪些事务未完成，然后尝试将这些事务恢复到正常状态。在 MySQL 运行期间，redo log 将持续记录所有已提交的事务更改，以确保在崩溃恢复时可以恢复所有未写入磁盘的事务更改。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>binlog 记录的是数据库中所有的更新操作，包括更新、插入、删除等操作。binlog 可以被用于备份、复制、恢复数据等场景。</p>
<p>binlog 可以用于许多用途，其中最常见的用途是数据备份和复制。使用 binlog，可以将数据库的所有更新操作记录下来，并在需要时将它们应用到另一个 MySQL 实例上，从而实现数据备份和复制。此外，binlog 还可以用于崩溃恢复，当 MySQL 重启时，它会读取最后一个 binlog 文件，然后将其中记录的所有更改应用到数据库中，以恢复未写入磁盘的更改。</p>
<p>binlog 也是以循环缓冲区的形式实现的。每个 binlog 文件包含一定数量的事件 (event)，每个事件记录一个事务的更改。每个事件由一个事件头 (event header) 和一个事件体 (event body) 组成，事件头包含了一些元数据信息，例如事件类型、时间戳、事务 ID 等，事件体则包含了具体的更改信息，例如被修改的表、修改前后的值等。</p>
<p><strong>注意</strong> 与 redo log 不同，binlog 是一种逻辑日志，它记录的是数据库的逻辑更改，而不是物理更改。这意味着 binlog 中记录的操作并不是直接修改了数据文件，而是以 SQL 语句的形式记录下来的，因此在使用 binlog 进行数据恢复时，可能会受到一些限制，例如在恢复期间需要使用相同的表结构、索引等。</p>
<p>默认情况下 binlog 日志是二进制格式，无法直接查看，需要借助工具：</p>
<ol>
<li>使用 mysqlbinlog 工具</li>
<li>使用 MySQL Workbench</li>
</ol>
<h3 id="日志模式"><a href="#日志模式" class="headerlink" title="日志模式"></a>日志模式</h3><p>binlog 支持三种日志格式： Statement、Row 和 Mixed</p>
<h4 id="Statement（基于-SQL-语句的复制）"><a href="#Statement（基于-SQL-语句的复制）" class="headerlink" title="Statement（基于 SQL 语句的复制）"></a>Statement（基于 SQL 语句的复制）</h4><p>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，提高性能。</p>
<p>由于记录的只是执行语句，为了这些语句能在 slave 上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在 slave 得到和在 master 端执行时候相同 的结果。</p>
<h4 id="Row（基于行的复制）"><a href="#Row（基于行的复制）" class="headerlink" title="Row（基于行的复制）"></a>Row（基于行的复制）</h4><p>优点：可以不记录执行的 sql 语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以 rowlevel 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，以及 trigger 的调用和触发无法被正确复制的问题。</p>
<p>缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</p>
<h4 id="Mixed（混合模式）"><a href="#Mixed（混合模式）" class="headerlink" title="Mixed（混合模式）"></a>Mixed（混合模式）</h4><p>一般的语句修改使用 statment 格式保存 binlog，如一些函数，statement 无法完成主从复制的操作，则采用 row 格式保存 binlog,MySQL 会根据执行的每一条具体的 sql 语句来区分对待记录的日志形式，也就是在 Statement 和 Row 之间选择一种。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log（回滚日志）用来记录数据被修改前的信息。正好跟前面的重做日志进行相反操作。undo log 主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>
<p>undo log 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读；</p>
<p>undo log 是逻辑格式的日志，在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 redo log 的。</p>
<h3 id="undo-log-日志格式"><a href="#undo-log-日志格式" class="headerlink" title="undo log 日志格式"></a>undo log 日志格式</h3><p>以 InnoDB 存储引擎为例，介绍一下其 undo log 的存储格式。</p>
<p>InnoDB 存储引擎的 undo log 存储在系统表空间中，具体来说：</p>
<ol>
<li>每个表都会有一个对应的 undo 表空间，其中存储了该表的 undo log 信息。</li>
<li>每个 undo 日志文件包含多个 undo 日志段（undo log segment）。</li>
<li>每个日志段又包含多个 undo 日志块（undo log block）。</li>
<li>undo 日志块的大小默认为 16KB，可以通过参数 innodb_undo_log_default_size 来修改。</li>
<li>每个 undo 日志块包含了多个 undo 记录（undo record），每个 undo 记录对应一个修改操作。</li>
</ol>
<p>每个 undo 记录的格式如下：</p>
<ul>
<li>Header（12 字节）： 包含 undo 记录的一些基本信息，如事务 ID、数据页编号、undo 记录长度等。</li>
<li>Transaction Information（10 字节）： 包含 undo 记录的事务信息，如最后一个修改该记录的事务 ID、上一个版本的 undo 段落编号等。</li>
<li>Rollback Segments Information（0~32 字节）： 用于记录 undo 记录中的数据在哪些 undo 段落中被修改过，以及这些段落中的事务 ID。</li>
<li>Data： 修改操作之前的数据。</li>
</ul>
<h3 id="undo-log-日志类型"><a href="#undo-log-日志类型" class="headerlink" title="undo log 日志类型"></a>undo log 日志类型</h3><p>undo log 主要分为 3 种：</p>
<ul>
<li>Insert undo log：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li>
<li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li>
<li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。<ul>
<li>删除操作都只是设置一下老记录的 DELETED_BIT，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB 有专门的 purge 线程来清理 DELETED_BIT 为 true 的记录。为了不影响 MVCC 的正常工作，purge 线程自己也维护了一个 read view（这个 read view 相当于系统中最老活跃事务的 read view）;如果某个记录的 DELETED_BIT 为 true，并且 DB_TRX_ID 相对于 purge 线程的 read view 可见，那么这条记录一定是可以被安全清除的。</li>
</ul>
</li>
</ul>
<p>对 MVCC 有帮助的实质是 update undo log ，undo log 实际上就是存在 rollback segment 中旧记录链</p>
<h4 id="Update-undo-log-执行流程"><a href="#Update-undo-log-执行流程" class="headerlink" title="Update undo log 执行流程"></a>Update undo log 执行流程</h4><ul>
<li>一个事务向 persion 表插入了一条新记录，记录如下，name 为 Jerry, age 为 24 岁，隐式主键是 1，事务 ID 和回滚指针，我们假设为 NULL</li>
</ul>
<p><img src="/imgs/mysql/mysql-undolog-update1.png" alt="mysql-undolog-update1"></p>
<ul>
<li>现在来了一个事务 1 对该记录的 name 做出了修改，改为 Tom<ol>
<li>在事务 1 修改该行(记录)数据时，数据库会先对该行加排他锁</li>
<li>然后把该行数据拷贝到 undo log 中，作为旧记录，即在 undo log 中有当前行的拷贝副本</li>
<li>拷贝完毕后，修改该行 name 为 Tom，并且修改隐藏字段的事务 ID 为当前事务 1 的 ID, 我们默认从 1 开始，之后递增，回滚指针指向拷贝到 undo log 的副本记录，即表示我的上一个版本就是它</li>
<li>事务提交后，释放锁</li>
</ol>
</li>
</ul>
<p><img src="/imgs/mysql/mysql-undolog-update2.png" alt="mysql-undolog-update2"></p>
<ul>
<li>又来了个事务 2 修改 person 表的同一个记录，将 age 修改为 30 岁<ol>
<li>在事务 2 修改该行数据时，数据库也先为该行加锁</li>
<li>然后把该行数据拷贝到 undo log 中，作为旧记录，发现该行记录已经有 undo log 了，那么最新的旧数据作为链表的表头，插在该行记录的 undo log 最前面</li>
<li>修改该行 age 为 30 岁，并且修改隐藏字段的事务 ID 为当前事务 2 的 ID, 那就是 2，回滚指针指向刚刚拷贝到 undo log 的副本记录</li>
<li>事务提交，释放锁</li>
</ol>
</li>
</ul>
<p><img src="/imgs/mysql/mysql-undolog-update3.png" alt="mysql-undolog-update3"></p>
<p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的 undo log 成为一条记录版本线性表，即链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该 undo log 的节点可能是会 purge 线程清除掉，向图中的第一条 insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p>
<h2 id="redo-log、binlog、undo-log-区别与作用"><a href="#redo-log、binlog、undo-log-区别与作用" class="headerlink" title="redo log、binlog、undo log 区别与作用"></a>redo log、binlog、undo log 区别与作用</h2><p>在 MySQL 数据库中，redo log、binlog 和 undo log 都是用于数据恢复和事务回滚的重要机制，它们分别具有不同的作用和特点，具体区别如下：</p>
<ul>
<li>Redo log：用于保证事务的持久性，记录了 InnoDB 存储引擎中的物理操作，如数据修改等，用于在数据库崩溃时重做未完成的事务。redo log 是在内存中操作的，具有高效性，通常会写入磁盘的方式是批量提交，降低了磁盘 I&#x2F;O 的开销。在 MySQL 中，redo log 的大小通过参数 innodb_log_file_size 来配置。</li>
<li>Binlog：用于记录 MySQL 中的逻辑操作，如对表的增删改查等操作，也用于主从复制和数据恢复。binlog 是基于语句的，记录了 SQL 语句的执行情况，具有较好的可读性和可恢复性。在 MySQL 中，binlog 的大小通过参数 max_binlog_size 来配置。</li>
<li>Undo log：用于记录事务的 undo 信息，包含了事务执行期间的所有修改操作及其 undo 信息，用于支持事务的回滚和 MVCC 机制。undo log 的大小通过参数 innodb_undo_tablespaces 来配置。</li>
</ul>
<p>综上所述，redo log 和 binlog 分别记录了不同的日志信息，具有不同的作用和特点，都是用于数据恢复和备份的关键机制；而 undo log 则是用于支持事务的回滚和 MVCC 机制，记录了事务执行期间的所有修改操作及其 undo 信息。在数据库系统中，这些机制都是非常重要的，能够有效地保障数据库的数据一致性和可靠性。</p>
<h2 id="update-语句的内部流程"><a href="#update-语句的内部流程" class="headerlink" title="update 语句的内部流程"></a>update 语句的内部流程</h2><p>示例语句： 给 ID&#x3D;2 这一行的 c 字段加 1</p>
<ol>
<li><p>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p>
</li>
</ol>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>两阶段提交，是为了 binlog 和 redolog 两分日志之间的逻辑一致。redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。可能造成的问题：</p>
<ol>
<li>数据库的状态可能和用它的日志恢复出来的库的状态不一致。</li>
<li>导致使用 binlog 进行数据同步的主从数据库数据不一致。</li>
</ol>
<p>示例： update 语句来做例子。假设当前 ID&#x3D;2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p>
<ol>
<li><p>先写 redo log 后写 binlog。<br>假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。 因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p>
</li>
<li><p>先写 binlog 后写 redo log。<br>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。 但是 binlog 里面已经记录了 “把 c 从 0 改成 1” 这个日志。 所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p>
</li>
</ol>
<h1 id="MVCC-Multi-Version-Concurrency-Control，即多版本并发控制"><a href="#MVCC-Multi-Version-Concurrency-Control，即多版本并发控制" class="headerlink" title="MVCC (Multi-Version Concurrency Control，即多版本并发控制)"></a>MVCC (Multi-Version Concurrency Control，即多版本并发控制)</h1><p>MVCC，全称 Multi-Version Concurrency Control，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<p>MVCC 多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念。</p>
<p>MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</p>
<h2 id="为什么需要-MVCC"><a href="#为什么需要-MVCC" class="headerlink" title="为什么需要 MVCC"></a>为什么需要 MVCC</h2><p>MVCC 是为了实现读-写冲突不加锁，而这个读指的是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。</p>
<p>在学习 MVCC 多版本并发控制之前，我们先了解一下，什么是 MySQL InnoDB 下的当前读和快照读？</p>
<h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><p>当前读： 指的是读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<blockquote>
<p>像 select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁) 这些操作都是一种当前读。</p>
</blockquote>
<p>快照读： 指的是不加锁的非阻塞读。</p>
<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC。<br>可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<blockquote>
<p>像不加锁的 select 操作就是快照读。</p>
</blockquote>
<p>实现这么一个 MVCC 理想概念，我们就需要 MySQL 提供具体的功能去实现它，而快照读就是 MySQL 为我们实现 MVCC 理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</p>
<h3 id="MVCC-能解决什么问题，好处是？"><a href="#MVCC-能解决什么问题，好处是？" class="headerlink" title="MVCC 能解决什么问题，好处是？"></a>MVCC 能解决什么问题，好处是？</h3><p>数据库并发场景有三种, 分别为：</p>
<ol>
<li>读-读：不存在任何问题，也不需要并发控制</li>
<li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ol>
<p>MVCC 带来的好处：</p>
<p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。</p>
<p>所以 MVCC 可以为数据库解决以下问题：</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题</li>
<li>但不能解决更新丢失问题</li>
</ul>
<blockquote>
<p>总而言之，MVCC 就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案</p>
</blockquote>
<p>在数据库中有了 MVCC，我们可以形成两个组合：</p>
<ul>
<li>MVCC + 悲观锁 MVCC 解决读写冲突，悲观锁解决写写冲突</li>
<li>MVCC + 乐观锁 MVCC 解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>这种组合的方式可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p>
<h2 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC 实现原理"></a>MVCC 实现原理</h2><p>在 mysql 中，它的实现原理主要是依赖记录中的 4 个隐式字段，undo 日志，Read View 来实现的。</p>
<h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的 DB_ROW_ID, DB_TRX_ID, DB_ROLL_PTR, DELETED_BIT 等字段</p>
<ul>
<li><strong>DB_ROW_ID</strong>: 6byte, 隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以 DB_ROW_ID 产生一个聚簇索引</li>
<li><strong>DB_TRX_ID</strong>: 6byte, 最近修改(修改&#x2F;插入)事务 ID：记录创建这条记录&#x2F;最后一次修改该记录的事务</li>
<li><strong>IDDB_ROLL_PTR</strong>: 7byte, 回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）</li>
<li><strong>DELETED_BIT</strong>: 1byte, 记录被更新或删除并不代表真的删除，而是删除 flag 变了</li>
</ul>
<p><img src="/imgs/mysql/mysql-mvcc-1.png" alt="mysql-mvcc-1"></p>
<p>如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID 是当前操作该记录的事务 ID； 而 DB_ROLL_PTR 是一个回滚指针，用于配合 undo 日志，指向上一个旧版本；delete flag 没有展示出来。</p>
<h3 id="undo-日志"><a href="#undo-日志" class="headerlink" title="undo 日志"></a>undo 日志</h3><p>参见上面 <a href="#undo-log">undo log</a></p>
<h3 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h3><p>Read View 是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID(当每个事务开启时，都会被分配一个 ID, 这个 ID 是递增的，所以最新的事务，ID 值越大)</p>
<p>Read View 主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个 Read View 读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，即可能是当前最新的数据，也有可能是该行记录的 undo log 里面的某个版本的数据。</p>
<p>Read View 遵循一个可见性算法，主要是将要被修改的数据的最新记录中的 DB_TRX_ID（即当前事务 ID）取出来，与系统当前其他活跃事务的 ID 去对比（由 Read View 维护），如果 DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 DB_ROLL_PTR 回滚指针去取出 Undo Log 中的 DB_TRX_ID 再比较，即遍历链表的 DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID, 那么这个 DB_TRX_ID 所在的旧记录就是当前事务能看见的最新老版本。</p>
<p>那么这个判断条件是什么呢？</p>
<p>我们可以把 Read View 简单的理解成有三个全局属性：</p>
<ul>
<li><strong>trx_list</strong>: 未提交事务 ID 列表，用来维护 Read View 生成时刻系统正活跃的事务 ID</li>
<li><strong>up_limit_id</strong>: 记录 trx_list 列表中事务 ID 最小的 ID</li>
<li><strong>low_limit_id</strong>: ReadView 生成时刻系统尚未分配的下一个事务 ID，也就是目前已出现过的事务 ID 的最大值 + 1</li>
</ul>
<p>比较步骤：</p>
<ol>
<li>首先比较 DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到 DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li>
<li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表 DB_TRX_ID 所在的记录在 Read View 生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li>
<li>判断 DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我 Read View 生成时刻，你这个事务还在活跃，还没有 Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在 Read View 生成之前就已经 Commit 了，你修改的结果，我当前事务是能看见的</li>
</ol>
<h2 id="MVCC-整体流程"><a href="#MVCC-整体流程" class="headerlink" title="MVCC 整体流程"></a>MVCC 整体流程</h2><p><img src="/imgs/mysql/mysql-mvcc-2.png" alt="mysql-mvcc-2"></p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h2><p><strong>索引的目的在于提高查询效率</strong>，可以类比字典，如果要查 “mysql” 这个单词，我们肯定需要定位到 m 字母，然后从上往下找到 y 字母，再找到剩下的 sql。如果没有索引，那么我们可能需要把所有单词看一遍才能找到想要的单词。</p>
<h2 id="索引优点"><a href="#索引优点" class="headerlink" title="索引优点"></a>索引优点</h2><ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。</li>
<li>将随机 I&#x2F;O 变为顺序 I&#x2F;O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。</li>
</ul>
<h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>除了字典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的： <strong>通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是可以通过同一种查找方式来锁定数据。</strong></p>
<p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果 1000 条数据，1 到 100 分成第一段，101 到 200 分成第二段，201 到 300 分成第三段……这样查第 250 条数据，只要找第三段就可以了，一下子去除了 90%的无效数据。但如果是 1 千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是 lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h3 id="磁盘-IO-与预读"><a href="#磁盘-IO-与预读" class="headerlink" title="磁盘 IO 与预读"></a>磁盘 IO 与预读</h3><p>前面提到了访问磁盘，那么这里先简单介绍一下磁盘 IO 和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。</p>
<ul>
<li>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；</li>
<li>旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，表示每分钟能转 7200 次，也就是说 1 秒钟能转 120 次，旋转延迟就是 1&#x2F;120&#x2F;2 &#x3D; 4.17ms；</li>
<li>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</li>
</ul>
<p>那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 5 + 4.17 &#x3D; 9ms 左右，听起来还挺不错的，但要知道一台 500 -MIPS 的机器每秒可以执行 5 亿条指令，因为指令依靠的是电的性质，换句话说执行一次 IO 的时间可以执行 40 万条指令，数据库动辄十万百万乃至千万级数据，每次 9 毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：</p>
<p><img src="/imgs/mysql/mysql-io-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%BB%B6%E8%BF%9F%E5%AF%B9%E6%AF%94.png" alt="mysql-io-计算机硬件延迟对比"></p>
<p>考虑到磁盘 IO 是非常高昂的操作，计算机操作系统做了一些优化，当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次 IO 读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为 4k 或 8k，也就是我们读取一页内的数据时候，实际上才发生了一次 IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h2 id="索引的类型和数据结构"><a href="#索引的类型和数据结构" class="headerlink" title="索引的类型和数据结构"></a>索引的类型和数据结构</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h3><p>B+ 树是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。</p>
<p>除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p><strong>InnoDB 的 B+ 树索引分为主索引和辅助索引。</strong></p>
<p><strong>InnoDB 对 B+ 树做了优化，同级节点中加入了前向指针，这样可以支持小于等于的快速查询</strong></p>
<p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p><img src="/imgs/mysql/mysql-index-b+tree-1.jpg" alt="mysql-index-b+tree-1"></p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<p><img src="/imgs/mysql/mysql-index-b+tree-2.jpg" alt="mysql-index-b+tree-2"></p>
<h4 id="InnoDB-一棵-B-树可以存放多少行数据？"><a href="#InnoDB-一棵-B-树可以存放多少行数据？" class="headerlink" title="InnoDB 一棵 B+ 树可以存放多少行数据？"></a>InnoDB 一棵 B+ 树可以存放多少行数据？</h4><p>这个问题的简单回答是：<strong>约 2 千万。</strong></p>
<p>这里我们假设 B+ 树高为 3，即存在一个根节点和若干个叶子节点，那么这棵 B+ 树的存放总记录数为：根节点指针数 * 单个叶子节点记录行数。</p>
<p>单个叶子节点（页）中的记录数： <code>16K/1K=16</code> 。（这里假设一行记录的数据大小为 1k，实际上现在很多互联网业务数据记录大小通常就是 1K 左右）。</p>
<p>那么现在我们需要计算出非叶子节点能存放多少指针？</p>
<p>其实这也很好算，我们假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即 <code>16384/14=1170</code> 。</p>
<p>那么可以算出一棵高度为 3 的 B+ 树，能存放 <code>1170*1170*16=21902400</code> 条这样的数据记录。</p>
<p><strong>所以在 InnoDB 中 B+ 树高度一般为 1-3 层，它就能满足千万级的数据存储</strong>。</p>
<p>在查找数据时一次页的查找代表一次 IO，所以通过主键索引查询通常只需要 1-3 次 IO 操作即可查找到数据。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p><strong>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”</strong>，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>聚簇索引： 将数据存储与索引放到了一块，找到索引也就找到了数据。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。<br>非聚簇索引： 将数据存储与索引分开，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致，<strong>非聚簇索引访问数据总是需要二次查找。</strong></p>
<p><strong>一个表只能有一个聚簇索引。</strong></p>
<h3 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h3><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为<strong>每次使用辅助索引检索都要经过两次 B+ 树查找</strong>，这不是多此一举吗？聚簇索引的优势在哪？</p>
<ol>
<li>由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了 Buffer 中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键 id 来组织数据，获得数据更快。</li>
<li>辅助索引使用主键作为 “指针” 而不是使用地址值作为指针的好处是： 减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是 InnoDB 在移动行时无须更新辅助索引中的这个”指针”。 也就是说行的位置（实现中通过 16K 的 Page 来定位）会随着数据库里数据的修改而发生变化（前面的 B+树节点分裂以及 Page 的分裂），使用聚簇索引就可以保证不管这个主键 B+树的节点如何变化，辅助索引树都不受影响。</li>
<li>聚簇索引适合用在排序的场合，非聚簇索引不适合。</li>
<li>取出一定范围数据的时候，使用用聚簇索引。</li>
<li>二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据。</li>
<li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I&#x2F;O。</li>
</ol>
<h3 id="聚簇索引的劣势"><a href="#聚簇索引的劣势" class="headerlink" title="聚簇索引的劣势"></a>聚簇索引的劣势</h3><ol>
<li>维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过 OPTIMIZE TABLE 优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片。</li>
<li>表因为使用 UUId（随机 ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用 int 的 auto_increment 作为主键</li>
<li>主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15&#x2F;16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的）</li>
<li>如果主键比较大的话，那辅助索引将会变的更大，因为<strong>辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间</strong></li>
</ol>
<h3 id="一个误区：把主键自动设为聚簇索引"><a href="#一个误区：把主键自动设为聚簇索引" class="headerlink" title="一个误区：把主键自动设为聚簇索引"></a>一个误区：把主键自动设为聚簇索引</h3><p><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻键值的页面可能相距甚远。<strong>如果已经设置了主键为聚簇索引，必须先删除主键，然后添加想要的聚簇索引，最后恢复设置主键即可</strong>。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `limit_test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `column1` <span class="type">decimal</span>(<span class="number">11</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span>,</span><br><span class="line">  `column2` <span class="type">decimal</span>(<span class="number">11</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span>,</span><br><span class="line">  `column3` <span class="type">decimal</span>(<span class="number">11</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<h3 id="基础分页语句"><a href="#基础分页语句" class="headerlink" title="基础分页语句"></a>基础分页语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> limit_test LIMIT <span class="number">0</span>,<span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LIMIT X 表示: 读取 X 条数据<br>LIMIT X, Y 表示: 跳过 X 条数据，读取 Y 条数据<br>LIMIT Y OFFSET X 表示: 跳过 X 条数据，读取 Y 条数据</p>
</blockquote>
<p>对于简单的小型应用程序和数据量不是很大的场景，这种方式还是没问题的。</p>
<p><strong>LIMIT 和 OFFSET 有什么问题</strong></p>
<p>OFFSET 和 LIMIT 对于数据量少的项目来说是没有问题的，但是，当数据库里的数据量超过服务器内存能够存储的能力，并且需要对所有数据进行分页，问题就会出现，为了实现分页，每次收到分页请求时，数据库都需要进行低效的全表遍历。</p>
<h3 id="优化第一版"><a href="#优化第一版" class="headerlink" title="优化第一版"></a>优化第一版</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> limit_test <span class="keyword">WHERE</span> id<span class="operator">&gt;</span><span class="number">10</span> limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>这是一种基于指针的分页。你要在本地保存上一次接收到的主键 (通常是一个 ID) 和 LIMIT，而不是 OFFSET 和 LIMIT，那么每一次的查询可能都与此类似。</p>
<p><strong>此方法缺点</strong></p>
<p>类似于查询 <code>SELECT * FROM table_name WHERE id &gt; 3400000 LIMIT 20;</code> 这样的效率非常快, 因为主键上是有索引的, 但是这样有个缺点, 就是 ID 必须是连续的, 并且查询不能有 WHERE 语句, 因为 WHERE 语句会造成过滤数据。那使用场景就非常的局限了。</p>
<h3 id="再优化-（覆盖索引优化）"><a href="#再优化-（覆盖索引优化）" class="headerlink" title="再优化 （覆盖索引优化）"></a>再优化 （覆盖索引优化）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> table_name LIMIT <span class="number">3400000</span>,<span class="number">20</span>) a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_name b <span class="keyword">ON</span> a.id <span class="operator">=</span> b.id;</span><br><span class="line"># 或者是</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> table_name LIMIT <span class="number">3400000</span>,<span class="number">20</span>) b <span class="keyword">USING</span> (id);</span><br></pre></td></tr></table></figure>

<p>MySQL 的查询完全命中索引的时候，称为覆盖索引，是非常快的，因为查询只需要在索引上进行查找，之后可以直接返回，而不用再回数据表拿数据。 因此我们可以先查出索引的 ID ，然后根据 ID 拿数据。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>MySQL 索引优化是为了提高数据库查询性能和减少查询时间，以下是一些常见的 MySQL 索引优化方法：</p>
<ol>
<li><p>选择合适的索引类型：<br>MySQL 支持多种索引类型，如 B-tree 索引、哈希索引、全文索引等。根据具体的查询需求和数据特点，选择适合的索引类型。</p>
</li>
<li><p>确定索引字段：<br>索引字段的选择非常重要。通常，选择常被用于查询条件的字段、经常被用于连接表的字段、用于排序和分组的字段等作为索引字段。</p>
</li>
<li><p>唯一索引和组合索引：<br>对于具有唯一性要求的字段，可以创建唯一索引。而对于经常一起使用的多个字段，可以创建组合索引，以提高查询效率。</p>
</li>
<li><p>避免冗余索引：<br>避免在表中创建冗余的、重复的索引，因为冗余索引会增加数据库的维护成本，并降低插入、更新和删除操作的性能。</p>
</li>
<li><p>避免过长的索引：<br>索引字段的长度越长，索引的维护和查询所需的资源就越多。因此，避免创建过长的索引，只选择必要的字段长度。</p>
</li>
<li><p>使用覆盖索引：<br>如果查询语句只需要索引字段的数据，而不需要从数据表中读取其他字段，可以使用覆盖索引。覆盖索引可以减少查询的 IO 操作，提高查询效率。</p>
</li>
<li><p>定期维护和优化索引：<br>定期分析和优化数据库中的索引，删除不再需要的索引，重新构建或重新组织索引，以保持索引的高效性。</p>
</li>
<li><p>注意索引和数据的一致性：<br>确保索引和数据的一致性，当对数据表进行更新、插入或删除操作时，需要及时更新和维护相关的索引。</p>
</li>
<li><p>监控和调优查询性能：<br>使用 MySQL 提供的性能监控工具和查询分析工具，定位和优化查询性能较差的 SQL 语句，避免全表扫描和慢查询等问题。</p>
</li>
</ol>
<p>以上是一些常见的 MySQL 索引优化方法，根据具体的数据库结构和查询需求，可以针对性地选择和应用这些方法，以提高数据库查询性能和优化索引效果。</p>
<h2 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h2><p><strong>问题：为什么需要水平分库，水平分库是为了解决什么问题？</strong></p>
<p>水平分库（Sharding）是一种数据库分片策略，用于解决大规模数据存储和处理的问题。它是将数据库中的数据按照某种规则分散存储在多个独立的数据库实例中，从而实现数据的分布式存储和处理。</p>
<p>水平分库的主要目的是解决以下问题：</p>
<ol>
<li><strong>数据规模的扩展性问题：</strong> 当数据库中的数据规模不断增大，单个数据库实例可能无法承受高并发的查询和更新操作。水平分库将数据分散存储在多个数据库实例中，每个实例只需要处理一部分数据，从而有效地扩展了数据规模的处理能力。</li>
<li><strong>高并发访问问题：</strong> 单个数据库实例在面对高并发的读写请求时可能会出现性能瓶颈。水平分库将数据分散存储在多个实例中，可以平均分担并发请求的负载，提高了系统的并发处理能力。</li>
<li><strong>地理位置和延迟问题：</strong> 当用户分布在不同的地理位置时，访问同一个数据库实例可能会受到网络延迟影响。水平分库可以将数据存储在靠近用户的地理位置的实例中，减少访问延迟。</li>
<li><strong>热点数据问题：</strong> 在单个数据库实例中，某些数据可能会成为热点数据，导致性能不均衡。水平分库可以将热点数据分散到不同的实例中，减少了热点数据对性能的影响。</li>
<li><strong>硬件资源利用问题：</strong> 某些数据库实例可能具有更好的硬件资源，而某些实例可能资源紧张。水平分库可以根据需求将数据分散到不同的实例中，充分利用不同实例的硬件资源。</li>
</ol>
<p>需要注意的是，水平分库虽然能够有效解决上述问题，但也引入了一些新的挑战，如数据一致性、跨分片事务、查询跨分片等问题。因此，在设计和实施水平分库时，需要综合考虑系统的需求、架构和数据访问模式，以及针对挑战的解决方案。</p>
<h2 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h2><p><strong>问题：为什么需要垂直分库，垂直分库是为了解决什么问题？</strong></p>
<p>垂直分库（Vertical Sharding）是一种数据库分片策略，用于解决数据库表中不同的数据属性和访问模式之间的差异问题。它是将数据库中的不同数据列（字段）分散存储在多个独立的数据库实例中，从而实现数据的分布式存储和处理。</p>
<p>垂直分库的主要目的是解决以下问题：</p>
<ol>
<li><strong>数据冗余问题：</strong> 数据库中的某些表可能包含了大量不同属性的数据，但某些属性只在特定的访问模式下被使用，导致了数据的冗余存储。通过垂直分库，可以将不同属性的数据分开存储在不同的实例中，减少了数据的冗余。</li>
<li><strong>访问模式的差异问题：</strong> 数据库表中的不同属性可能会被不同的应用程序或访问模式使用。某些属性可能在频繁的查询中使用，而其他属性可能只在特定的分析任务中使用。通过垂直分库，可以将不同属性的数据存储在不同的实例中，从而根据不同的访问模式进行优化。</li>
<li><strong>性能优化问题：</strong> 某些属性的查询可能会对性能产生负面影响，例如频繁的全表扫描。通过垂直分库，可以将这些可能影响性能的属性存储在独立的实例中，从而保护其他数据的查询性能。</li>
<li><strong>硬件资源利用问题：</strong> 某些属性可能需要更高性能的硬件资源，而其他属性可能对性能要求较低。通过垂直分库，可以根据需求将数据分散到不同的实例中，充分利用不同实例的硬件资源。</li>
<li><strong>安全性问题：</strong> 某些属性可能包含敏感信息，需要更高级别的访问控制和安全保护。通过垂直分库，可以将敏感属性存储在独立的实例中，加强数据的安全性。</li>
</ol>
<p>需要注意的是，垂直分库也引入了一些新的挑战，如跨分片的查询、数据一致性等问题。在设计和实施垂直分库时，需要综合考虑系统的需求、架构和数据属性，以及针对挑战的解决方案。垂直分库通常与水平分库等其他分片策略结合使用，以达到更好的数据管理和性能优化效果。</p>
<h2 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h2><p><strong>问题：为什么需要水平分表，水平分表是为了解决什么问题</strong></p>
<p>水平分表（Table Sharding）是一种数据库分片策略，用于解决单个表中数据量过大导致查询性能下降的问题。它是将单个数据库表中的数据按照某种规则分散存储在多个独立的表中，从而实现数据的分布式存储和处理。</p>
<p>水平分表的主要目的是解决以下问题：</p>
<ol>
<li><strong>数据规模的扩展性问题：</strong> 当数据库表中的数据量逐渐增大，单个表可能会变得庞大，导致查询性能下降，例如查询时间延长。水平分表可以将表中的数据分散存储在多个表中，每个表只包含部分数据，从而有效地扩展了数据规模的处理能力。</li>
<li><strong>高并发访问问题：</strong> 单个表在面对高并发的读写请求时可能会出现性能瓶颈。水平分表可以将并发请求分散到不同的表中，平均分担了并发请求的负载，提高了系统的并发处理能力。</li>
<li><strong>数据维护和备份问题：</strong> 大表的维护和备份可能会变得困难和耗时。通过水平分表，可以将数据分散到多个表中，使数据的维护和备份变得更加高效。</li>
<li><strong>查询性能问题：</strong> 针对特定查询，查询时间可能会随着数据量的增加而增加。通过水平分表，可以减小每个表的数据量，从而提高查询性能。</li>
<li><strong>硬件资源利用问题：</strong> 某些表可能需要更高性能的硬件资源，而其他表可能对性能要求较低。通过水平分表，可以根据需求将数据分散到不同的表中，充分利用不同表的硬件资源。</li>
</ol>
<p>需要注意的是，水平分表也引入了一些新的挑战，如跨分片的查询、数据一致性等问题。在设计和实施水平分表时，需要综合考虑系统的需求、架构和数据访问模式，以及针对挑战的解决方案。水平分表通常与水平分库等其他分片策略结合使用，以达到更好的数据管理和性能优化效果。</p>
<h2 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h2><p><strong>问题：为什么需要垂直分表，垂直分表是为了解决什么问题？</strong></p>
<p>垂直分表（Vertical Sharding）是一种数据库分片策略，用于解决单个数据表中不同数据属性的差异问题。它是将一个大的数据表按照数据属性的差异，将不同的列（字段）分散存储在多个独立的表中，从而实现数据的分布式存储和处理。</p>
<p>垂直分表的主要目的是解决以下问题：</p>
<ol>
<li><strong>数据冗余问题：</strong> 在单个大表中，可能包含了大量不同属性的数据，但某些属性只在特定的查询或应用场景下使用。这导致了数据的冗余存储，浪费了存储空间和维护成本。通过垂直分表，可以将不同属性的数据分散存储在不同的表中，减少了数据的冗余。</li>
<li><strong>查询性能优化：</strong> 单个大表在执行查询时可能会遇到性能瓶颈，尤其是在需要扫描全表的情况下。通过垂直分表，可以将常用的查询字段分散到多个表中，提高查询性能。</li>
<li><strong>维护和备份问题：</strong> 大表的维护和备份可能会变得复杂和耗时。通过垂直分表，可以将不同属性的数据分散到多个表中，简化了维护和备份过程。</li>
<li><strong>访问权限和安全性：</strong> 不同属性的数据可能拥有不同的访问权限和安全性需求。通过垂直分表，可以将敏感数据分散存储在独立的表中，加强了数据的安全性。</li>
<li><strong>表的设计灵活性：</strong> 在某些情况下，大表的设计可能变得复杂和难以维护。通过垂直分表，可以将不同属性的数据分散到多个表中，提高了表的设计灵活性和可维护性。</li>
</ol>
<p>需要注意的是，垂直分表也会引入一些新的挑战，如跨表查询、数据一致性等问题。在设计和实施垂直分表时，需要综合考虑系统的需求、架构和数据属性，以及针对挑战的解决方案。垂直分表通常与其他分片策略如水平分表或水平分库结合使用，以满足复杂的数据管理和性能优化需求。</p>
<h2 id="分库和分表区别"><a href="#分库和分表区别" class="headerlink" title="分库和分表区别"></a>分库和分表区别</h2><h3 id="什么时候水平分表，什么时候水平分库"><a href="#什么时候水平分表，什么时候水平分库" class="headerlink" title="什么时候水平分表，什么时候水平分库"></a>什么时候水平分表，什么时候水平分库</h3><p>水平分表和水平分库是解决不同问题的数据库分片策略，选择何时使用取决于系统的需求、性能目标和架构设计。下面是一些情况说明何时使用水平分表和水平分库：</p>
<p><strong>水平分表：</strong></p>
<ol>
<li><strong>数据表过大：</strong> 当单个数据表的数据量逐渐增大，导致查询性能下降时，可以考虑水平分表。分散数据到多个表中，每个表只包含部分数据，可以提高查询性能。</li>
<li><strong>查询模式差异：</strong> 不同属性的数据在不同的查询模式下使用频率差异较大时，可以考虑水平分表。将不同属性的数据分散到不同的表中，根据查询模式进行优化。</li>
<li><strong>硬件资源利用：</strong> 某些属性的数据需要更高性能的硬件资源，而其他属性可能对性能要求较低。在这种情况下，可以考虑将数据按照属性分散到不同的表中，以充分利用硬件资源。</li>
</ol>
<p><strong>水平分库：</strong></p>
<ol>
<li><strong>数据规模过大：</strong> 当整个数据库的数据规模逐渐增大，单个数据库实例难以承受高并发和大规模数据存储时，可以考虑水平分库。将数据分散存储在多个独立的数据库实例中，提高了数据规模的扩展性。</li>
<li><strong>地理分布和延迟问题：</strong> 当用户分布在不同地理位置时，访问同一个数据库实例可能会受到网络延迟的影响。通过水平分库，可以将数据存储在靠近用户的地理位置的实例中，减少访问延迟。</li>
<li><strong>高并发访问问题：</strong> 单个数据库实例在面对高并发的读写请求时可能会出现性能瓶颈。水平分库可以将并发请求分散到不同实例中，提高系统的并发处理能力。</li>
</ol>
<p>需要根据实际情况来选择水平分表还是水平分库，有时也可能需要结合两者一起使用，以满足复杂的数据管理和性能优化需求。在做出决策时，需要综合考虑数据访问模式、查询需求、数据规模、性能要求和系统架构等因素。</p>
<h3 id="什么时候垂直分表，什么时候垂直分库"><a href="#什么时候垂直分表，什么时候垂直分库" class="headerlink" title="什么时候垂直分表，什么时候垂直分库"></a>什么时候垂直分表，什么时候垂直分库</h3><p>垂直分表和垂直分库是解决不同问题的数据库分片策略，选择何时使用取决于系统的需求、性能目标和架构设计。下面是一些情况说明何时使用垂直分表和垂直分库：</p>
<p><strong>垂直分表：</strong></p>
<ol>
<li><strong>数据表中存在属性差异：</strong> 当单个数据表中的数据属性差异很大，不同属性的数据被不同的查询模式或应用程序使用时，可以考虑垂直分表。将不同属性的数据分开存储在不同的表中，以优化不同的访问模式。</li>
<li><strong>属性的访问模式不同：</strong> 数据库表中的某些属性可能在不同的访问模式下被使用，有些属性可能在频繁的查询中使用，而其他属性可能只在特定的分析任务中使用。通过垂直分表，可以将不同属性的数据存储在不同的表中，根据不同的访问模式进行优化。</li>
</ol>
<p><strong>垂直分库：</strong></p>
<ol>
<li><strong>数据规模过大：</strong> 当整个数据库中的数据规模逐渐增大，单个数据库实例无法应对高并发和大规模数据存储需求时，可以考虑垂直分库。将数据库中不同的数据表分散存储在多个独立的数据库实例中，提高了数据规模的扩展性。</li>
<li><strong>访问权限和安全性不同：</strong> 不同的数据表可能包含不同级别的敏感信息，需要不同级别的访问权限和安全保护。在这种情况下，可以考虑将敏感数据表分散存储在不同的数据库实例中，增强数据的安全性。</li>
</ol>
<p>需要根据实际情况来选择垂直分表还是垂直分库，也可能需要结合两者一起使用，以满足复杂的数据管理和性能优化需求。在做出决策时，需要综合考虑数据访问模式、查询需求、数据规模、性能要求、安全性和系统架构等因素。</p>
<h3 id="什么时候水平分库，什么时候垂直分库"><a href="#什么时候水平分库，什么时候垂直分库" class="headerlink" title="什么时候水平分库，什么时候垂直分库"></a>什么时候水平分库，什么时候垂直分库</h3><p>水平分库和垂直分库是数据库分片策略，用于解决不同类型的问题。以下是一些情况说明何时使用水平分库和垂直分库：</p>
<p><strong>水平分库：</strong></p>
<ol>
<li><strong>数据规模过大：</strong> 当整个数据库中的数据量逐渐增大，单个数据库实例无法应对高并发和大规模数据存储需求时，可以考虑水平分库。将不同的数据表分散存储在多个独立的数据库实例中，提高了数据规模的扩展性。</li>
<li><strong>地理分布和延迟问题：</strong> 当用户分布在不同地理位置时，访问同一个数据库实例可能会受到网络延迟的影响。通过水平分库，可以将数据存储在靠近用户的地理位置的实例中，减少访问延迟。</li>
<li><strong>高并发访问问题：</strong> 单个数据库实例在面对高并发的读写请求时可能会出现性能瓶颈。水平分库可以将并发请求分散到不同的实例中，提高系统的并发处理能力。</li>
</ol>
<p><strong>垂直分库：</strong></p>
<ol>
<li><strong>数据表属性差异大：</strong> 当不同的数据表在属性上有显著的差异，不同属性的数据需要不同的硬件资源或访问权限时，可以考虑垂直分库。将不同的数据表分散存储在不同的数据库实例中，以优化性能和资源利用。</li>
<li><strong>数据表的访问模式差异：</strong> 如果不同属性的数据表在不同的访问模式下被使用，例如一些表在频繁查询中使用，而其他表仅在特定场景下使用，可以考虑垂直分库。</li>
<li><strong>安全性需求不同：</strong> 不同的数据表可能包含不同级别的敏感信息，需要不同级别的访问权限和安全保护。在这种情况下，可以考虑将敏感数据表分散存储在不同的数据库实例中，增强数据的安全性。</li>
</ol>
<p>需要根据实际情况来选择水平分库还是垂直分库，有时也可能需要结合两者一起使用，以满足复杂的数据管理和性能优化需求。在做出决策时，需要综合考虑数据访问模式、查询需求、数据规模、性能要求、资源利用和系统架构等因素。</p>
<h3 id="什么时候水平分表，什么时候垂直分表"><a href="#什么时候水平分表，什么时候垂直分表" class="headerlink" title="什么时候水平分表，什么时候垂直分表"></a>什么时候水平分表，什么时候垂直分表</h3><p>水平分表和垂直分表是数据库分片策略，用于解决不同类型的问题。下面是一些情况说明何时使用水平分表和垂直分表：</p>
<p><strong>水平分表：</strong></p>
<ol>
<li><strong>数据量过大：</strong> 当单个数据表的数据量逐渐增大，导致查询性能下降时，可以考虑水平分表。分散数据到多个表中，每个表只包含部分数据，可以提高查询性能。</li>
<li><strong>数据增长速度较快：</strong> 如果数据量的增长速度较快，导致数据表在短时间内就会变得庞大，可以考虑水平分表，以避免未来的性能问题。</li>
<li><strong>查询热点问题：</strong> 如果某些查询在特定时间段内变得异常热门，可能会导致查询性能下降。水平分表可以将查询负载分散到多个表中，提高性能。</li>
</ol>
<p><strong>垂直分表：</strong></p>
<ol>
<li><strong>数据表中属性差异大：</strong> 当单个数据表中的不同属性的数据使用频率差异很大时，可以考虑垂直分表。将不同属性的数据分开存储在不同的表中，以便优化查询性能。</li>
<li><strong>数据表设计复杂：</strong> 如果单个数据表的设计变得复杂，难以维护，可以考虑垂直分表。将不同属性的数据分散到多个表中，可以简化每个表的设计和维护。</li>
<li><strong>数据表的访问模式差异：</strong> 如果不同属性的数据在不同的访问模式下被使用，例如一些属性在频繁查询中使用，而其他属性仅在特定场景下使用，可以考虑垂直分表。</li>
</ol>
<p>需要根据实际情况来选择水平分表还是垂直分表，有时也可能需要结合两者一起使用，以满足复杂的数据管理和性能优化需求。在做出决策时，需要综合考虑数据访问模式、查询需求、数据规模、性能要求、数据属性和系统架构等因素。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onsuccessway/p/3552524.html">mysql 查看数据库、表的基本命令</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41918841/article/details/82997651">使用“plugin: auth_socket”更改 MySQL 5.7 中的用户密码</a></li>
<li><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html">MySQL - MySQL InnoDB 的 MVCC 实现机制</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1888595">mysql 日志：redo log、binlog、undo log 区别与作用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.51cto.com/article/718182.html">LIMIT 和 OFFSET 分页性能差！今天来介绍如何高性能分页</a></li>
<li><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html">MySQL - 索引(B+树)</a></li>
<li><a target="_blank" rel="noopener" href="https://learnku.com/articles/62264">对线面试官：InnoDB 中一棵 B+树能存多少行数据？</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/db/" rel="tag"># db</a>
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/2019/09/05/jenkins/" rel="prev" title="jenkins部署及使用">
                  <i class="fa fa-angle-left"></i> jenkins部署及使用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/2020/03/28/maven/" rel="next" title="maven 笔记">
                  maven 笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Apomelo</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.19.1/algoliasearch-lite.umd.js" integrity="sha256-qzlNbRtZWHoUV5I2mI2t9QR7oYXlS9oNctX+0pECXI0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.8/instantsearch.production.min.js" integrity="sha256-xUys6KCuRGBxFaRaYZlWulRUjY48XFv6/Q2s0mb1dmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"N5VN0ybf5xGuqDFhjzC5RlRL-MdYXbMMI","app_key":"ru1RlOeEotFp87wLFIHucgVu","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
