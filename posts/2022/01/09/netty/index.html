<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"apomelo.cc","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"HQMNR1OKHR","apiKey":"cf13855186697063811959d3e9cf03be","indexName":"apomelo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="netty 简介Netty 是一个高性能、异步事件驱动的 NIO 网络应用框架, 它提供了对 TCP、UDP 和文件传输的支持. 基于 Netty, 可以快速的开发和部署高性能、 高可用的网络服务端和客户端应用.">
<meta property="og:type" content="article">
<meta property="og:title" content="netty笔记">
<meta property="og:url" content="https://apomelo.cc/posts/2022/01/09/netty/index.html">
<meta property="og:site_name" content="Apomelo - 追逐">
<meta property="og:description" content="netty 简介Netty 是一个高性能、异步事件驱动的 NIO 网络应用框架, 它提供了对 TCP、UDP 和文件传输的支持. 基于 Netty, 可以快速的开发和部署高性能、 高可用的网络服务端和客户端应用.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-ChannelPipeline.jpg">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-tcp%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.png">
<meta property="og:image" content="https://apomelo.cc/source/imgs/netty/netty-diagram-DelimiterBasedFrameDecoder.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-memory-linux%E5%86%85%E5%AD%98%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-memory-linux%E5%86%85%E5%AD%98%E9%9B%B6%E6%8B%B7%E8%B4%9D.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-memory-linux%E5%86%85%E5%AD%98%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-memory-CompositeByteBuf.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-memory-CompositeByteBuf2.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-memory-CompositeByteBuf3.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-memory-ByteBuf-slice.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/ResourceLeakDetector-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/DefaultResourceLeak-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/LeakAwareByteBuf-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-DMA-%E2%BE%B8%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-DMA-%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-DMA-%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-slab%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-jemalloc-%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-thread-reactor-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-thread-reactor-%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-thread-reactor-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-thread-reactor-%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-thread-reactor-netty%E6%94%B9%E8%BF%9B.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-thread-reactor-netty%E6%94%B9%E8%BF%9B2.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-thread-ThreadLocal-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png">
<meta property="og:image" content="https://apomelo.cc/imgs/netty/netty-%E6%97%B6%E9%97%B4%E8%BD%AE.png">
<meta property="article:published_time" content="2022-01-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-08T16:00:00.000Z">
<meta property="article:author" content="Apomelo">
<meta property="article:tag" content="java">
<meta property="article:tag" content="netty">
<meta property="article:tag" content="io">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://apomelo.cc/imgs/netty/netty-ChannelPipeline.jpg">


<link rel="canonical" href="https://apomelo.cc/posts/2022/01/09/netty/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://apomelo.cc/posts/2022/01/09/netty/","path":"posts/2022/01/09/netty/","title":"netty笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>netty笔记 | Apomelo - 追逐</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2KQDESYMZF"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2KQDESYMZF","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?6c01cfc90b27c8f2cf8c97e38b2f117c"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Apomelo - 追逐</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#netty-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">netty 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#netty-%E4%BC%98%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">netty 优点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E-mina-%E5%AF%B9%E6%AF%94"><span class="nav-number">2.1.</span> <span class="nav-text">与 mina 对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO-%E7%AE%80%E4%BB%8B"><span class="nav-number">3.</span> <span class="nav-text">NIO 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-%E4%B8%8E-IO-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">NIO 与 IO 的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#netty-%E7%BB%84%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">netty 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bootstrap-%E5%92%8C-ServerBootstrap"><span class="nav-number">4.1.</span> <span class="nav-text">Bootstrap 和 ServerBootstrap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NioEventLoop-%E5%92%8C-NioEventLoopGroup"><span class="nav-number">4.2.</span> <span class="nav-text">NioEventLoop 和 NioEventLoopGroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future-%E5%92%8C-ChannelFuture"><span class="nav-number">4.3.</span> <span class="nav-text">Future 和 ChannelFuture</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelPipeline"><span class="nav-number">4.4.</span> <span class="nav-text">ChannelPipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel"><span class="nav-number">4.5.</span> <span class="nav-text">Channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelHandler"><span class="nav-number">4.6.</span> <span class="nav-text">ChannelHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ServerBootstrap-%E7%9A%84-childHandler-%E4%B8%8E-handler-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.6.1.</span> <span class="nav-text">ServerBootstrap 的 childHandler()与 handler()的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelHandlerContext"><span class="nav-number">4.7.</span> <span class="nav-text">ChannelHandlerContext</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelInitializer"><span class="nav-number">4.8.</span> <span class="nav-text">ChannelInitializer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">4.8.1.</span> <span class="nav-text">异常处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#netty-%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="nav-number">5.</span> <span class="nav-text">netty 编解码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8-Encoder"><span class="nav-number">5.1.</span> <span class="nav-text">编码器 Encoder</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">5.1.1.</span> <span class="nav-text">抽象解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageToByteEncoder"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">MessageToByteEncoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageToMessageEncoder"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">MessageToMessageEncoder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%B2%E5%AE%9E%E7%8E%B0%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">已实现解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StringEncoder"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">StringEncoder</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E5%99%A8-Decoder"><span class="nav-number">5.2.</span> <span class="nav-text">解码器 Decoder</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E8%A7%A3%E7%A0%81%E5%99%A8-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">抽象解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ByteToMessageDecoder"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">ByteToMessageDecoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReplayingDecoder"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">ReplayingDecoder</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.2.1.2.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageToMessageDecoder"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">MessageToMessageDecoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">如何选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%B2%E5%AE%9E%E7%8E%B0%E8%A7%A3%E7%A0%81%E5%99%A8-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">已实现解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DelimiterBasedFrameDecoder"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">DelimiterBasedFrameDecoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LineBasedFrameDecoder"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">LineBasedFrameDecoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FixedLengthFrameDecoder"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">FixedLengthFrameDecoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LengthFieldBasedFrameDecoder"><span class="nav-number">5.2.2.4.</span> <span class="nav-text">LengthFieldBasedFrameDecoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringDecoder"><span class="nav-number">5.2.2.5.</span> <span class="nav-text">StringDecoder</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85"><span class="nav-number">5.3.</span> <span class="nav-text">TCP 粘包、拆包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">5.3.1.</span> <span class="nav-text">粘包、拆包解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%96%B9"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">接收方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">应用层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">粘包、拆包示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E4%B8%A2%E5%8C%85"><span class="nav-number">5.4.</span> <span class="nav-text">UDP 丢包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E4%B8%A2%E5%8C%85%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.4.1.</span> <span class="nav-text">主要丢包原因</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#netty-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">netty 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">6.1.</span> <span class="nav-text">netty 零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">6.1.1.</span> <span class="nav-text">Linux 零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sendfile-%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">sendfile 模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sendfile-DMA-gather-copy-%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">sendfile + DMA gather copy 模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D-1"><span class="nav-number">6.1.2.</span> <span class="nav-text">netty 零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">堆外内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompositeByteBuf"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">CompositeByteBuf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unpooled-wrappedBuffer-%E6%93%8D%E4%BD%9C"><span class="nav-number">6.1.2.3.</span> <span class="nav-text">Unpooled.wrappedBuffer 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ByteBuf-slice-%E6%93%8D%E4%BD%9C"><span class="nav-number">6.1.2.4.</span> <span class="nav-text">ByteBuf.slice 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93-FileRegion"><span class="nav-number">6.1.2.5.</span> <span class="nav-text">文件传输 FileRegion</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netty-%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B"><span class="nav-number">6.2.</span> <span class="nav-text">netty 泄漏检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceLeakDetector-%E7%AE%80%E4%BB%8B"><span class="nav-number">6.2.1.</span> <span class="nav-text">ResourceLeakDetector 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceLeakDetector-%E5%A4%A7%E8%87%B4%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">6.2.2.</span> <span class="nav-text">ResourceLeakDetector 大致工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E7%AD%89%E7%BA%A7"><span class="nav-number">6.2.3.</span> <span class="nav-text">检测等级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">6.2.4.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DefaultResourceLeak"><span class="nav-number">6.2.4.1.</span> <span class="nav-text">DefaultResourceLeak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TraceRecord"><span class="nav-number">6.2.4.2.</span> <span class="nav-text">TraceRecord</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ResourceLeakDetector"><span class="nav-number">6.2.4.3.</span> <span class="nav-text">ResourceLeakDetector</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%A3%80%E6%B5%8B%E5%92%8C%E9%AB%98%E7%BA%A7%E6%A3%80%E6%B5%8B"><span class="nav-number">6.2.5.</span> <span class="nav-text">简单检测和高级检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">6.2.6.</span> <span class="nav-text">泄漏总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jemalloc-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">6.3.</span> <span class="nav-text">jemalloc 基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%9B%AE%E6%A0%87-memory-allocator"><span class="nav-number">6.3.1.</span> <span class="nav-text">内存分配器目标(memory allocator)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jemalloc-ptmalloc-tcmalloc-%E5%AF%B9%E6%AF%94"><span class="nav-number">6.3.2.</span> <span class="nav-text">jemalloc, ptmalloc, tcmalloc 对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">常用内存分配器算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">6.3.3.1.</span> <span class="nav-text">动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%BE%B8%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-first-fit"><span class="nav-number">6.3.3.1.1.</span> <span class="nav-text">⾸次适应算法 (first fit)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-next-fit"><span class="nav-number">6.3.3.1.2.</span> <span class="nav-text">循环首次适应算法 (next fit)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-best-fit"><span class="nav-number">6.3.3.1.3.</span> <span class="nav-text">最佳适应算法 (best fit)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.3.2.</span> <span class="nav-text">伙伴算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Slab-%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.3.3.</span> <span class="nav-text">Slab 算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jemalloc-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.3.4.</span> <span class="nav-text">jemalloc 架构设计</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">netty 线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-NIO-%E6%96%B0%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">Java NIO 新连接处理流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netty-reactor-%E6%9E%B6%E6%9E%84"><span class="nav-number">7.2.</span> <span class="nav-text">netty reactor 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reactor-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-number">7.2.1.</span> <span class="nav-text">reactor 设计思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reactor-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90"><span class="nav-number">7.2.2.</span> <span class="nav-text">reactor 核心组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95-Reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.2.3.</span> <span class="nav-text">单 Reactor 单线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">7.2.3.1.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.2.4.</span> <span class="nav-text">单 Reactor 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="nav-number">7.2.4.1.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.2.5.</span> <span class="nav-text">主从 Reactor 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="nav-number">7.2.5.1.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netty-%E6%94%B9%E8%BF%9B-reactor"><span class="nav-number">7.2.6.</span> <span class="nav-text">netty 改进 reactor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0"><span class="nav-number">7.2.6.1.</span> <span class="nav-text">简要概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="nav-number">7.2.6.2.</span> <span class="nav-text">详细说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netty-%E7%9A%84-FastThreadLocal"><span class="nav-number">7.3.</span> <span class="nav-text">netty 的 FastThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-ThreadLocal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.1.</span> <span class="nav-text">JDK ThreadLocal 基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">ThreadLocal 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocalMap-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.3.1.2.</span> <span class="nav-text">ThreadLocalMap 内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocalMap-%E4%B8%AD-Entry-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.1.3.</span> <span class="nav-text">ThreadLocalMap 中 Entry 设计原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FastThreadLocal-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="nav-number">7.3.2.</span> <span class="nav-text">FastThreadLocal 为什么快</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FastThreadLocal-%E6%BA%90%E7%A0%81%E5%AE%9A%E4%B9%89"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">FastThreadLocal 源码定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FastThreadLocalThread-%E6%BA%90%E7%A0%81%E5%AE%9A%E4%B9%89"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">FastThreadLocalThread 源码定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InternalThreadLocalMap-%E6%BA%90%E7%A0%81%E5%AE%9A%E4%B9%89"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">InternalThreadLocalMap 源码定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">7.3.2.4.</span> <span class="nav-text">源码解析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#netty-%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="nav-number">8.</span> <span class="nav-text">netty 时间轮</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95"><span class="nav-number">8.1.</span> <span class="nav-text">时间轮算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netty-HashedWheelTimer-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">8.2.</span> <span class="nav-text">netty HashedWheelTimer 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashedWheelTimer-%E6%BA%90%E7%A0%81%E5%AE%9A%E4%B9%89"><span class="nav-number">8.2.1.</span> <span class="nav-text">HashedWheelTimer 源码定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashedWheelTimer-%E7%A4%BA%E4%BE%8B"><span class="nav-number">8.2.2.</span> <span class="nav-text">HashedWheelTimer 示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Apomelo</p>
  <div class="site-description" itemprop="description">我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/apomelo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;apomelo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:apomeloc@gmail.com" title="E-Mail → mailto:apomeloc@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://apomelo.cc/posts/2022/01/09/netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apomelo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apomelo - 追逐">
      <meta itemprop="description" content="我有一壶酒，足以慰风尘。<br/>尽倾江海里，赠饮天下人。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="netty笔记 | Apomelo - 追逐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          netty笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-09T00:00:00+08:00">2022-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span id="/posts/2022/01/09/netty/" class="post-meta-item leancloud_visitors" data-flag-title="netty笔记" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="netty-简介"><a href="#netty-简介" class="headerlink" title="netty 简介"></a>netty 简介</h1><p>Netty 是一个高性能、异步事件驱动的 NIO 网络应用框架, 它提供了对 TCP、UDP 和文件传输的支持. 基于 Netty, 可以快速的开发和部署高性能、 高可用的网络服务端和客户端应用.</p>
<span id="more"></span>

<h1 id="netty-优点"><a href="#netty-优点" class="headerlink" title="netty 优点"></a>netty 优点</h1><ol>
<li><p>设计</p>
<ul>
<li>针对多种传输类型的统一接口 - 阻塞和非阻塞</li>
<li>简单但更强大的线程模型</li>
<li>真正的无连接的数据报套接字支持</li>
<li>链接逻辑支持复用</li>
</ul>
</li>
<li><p>易用性</p>
<ul>
<li>大量的 Javadoc 和 代码实例</li>
<li>API 使用简单, 开发门槛低 (对 IO 读写以及线程安全做了大量封装)</li>
<li>基于事件模式, 对网络事件进行串行化处理, 在保证高效的同时, 又降低了编程的复杂度</li>
<li>除了在 JDK 1.6 + 额外的限制. (一些特征是只支持在 Java 1.7 +. 可选的功能可能有额外的限制. )</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>预置了多种编解码功能, 支持多种主流协议</li>
<li>定制能力强, 可以通过 ChannelHandler 对通信框架进行灵活地扩展</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>比核心 Java API 更好的吞吐量, 较低的延时</li>
<li>资源消耗更少, 这个得益于共享池和重用</li>
<li>减少内存拷贝</li>
</ul>
</li>
<li><p>健壮性</p>
<ul>
<li>消除由于慢, 快, 或重载连接产生的 OutOfMemoryError</li>
<li>消除经常发现在 NIO 在高速网络中的应用中的不公平的读&#x2F;写比</li>
</ul>
</li>
<li><p>安全</p>
<ul>
<li>完整的 SSL &#x2F; TLS 和 StartTLS 的支持</li>
<li>运行在受限的环境例如 Applet 或 OSGI</li>
</ul>
</li>
<li><p>社区</p>
<ul>
<li>发布的更早和更频繁</li>
<li>社区驱动</li>
</ul>
</li>
</ol>
<h2 id="与-mina-对比"><a href="#与-mina-对比" class="headerlink" title="与 mina 对比"></a>与 mina 对比</h2><ol>
<li>都是 Trustin Lee 的作品, Netty 更晚, 也更成熟;</li>
<li>Mina 将内核和一些特性的联系过于紧密, 使得用户在不需要这些特性的时候无法脱离, 相比下性能会有所下降, Netty 解决了这个设计问题;</li>
<li>Netty 的文档更清晰, 很多 Mina 的特性在 Netty 里都有;</li>
<li>Netty 更新周期更短, 新版本的发布比较快;</li>
<li>它们的架构差别不大, Mina 靠 apache 生存, 而 Netty 靠 jboss, 和 jboss 的结合度非常高, Netty 有对 google protocal buf 的支持, 有更完整的 ioc 容器支持(spring,guice,jbossmc 和 osgi);</li>
<li>Netty 和 Mina 在处理 UDP 时有一些不同, Netty 将 UDP 无连接的特性暴露出来; 而 Mina 对 UDP 进行了高级层次的抽象, 可以把 UDP 当成”面向连接”的协议, 而要 Netty 做到这一点比较困难.</li>
</ol>
<h1 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h1><p>NIO 主要有三大核心部分: Channel(通道), Buffer(缓冲区), Selector.</p>
<p>传统 IO 基于字节流和字符流进行操作, 而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作, 数据总是从通道读取到缓冲区中, 或者从缓冲区写入到通道中.</p>
<p>Selector(选择区)用于监听多个通道的事件 (比如: 连接打开, 数据到达) . 因此, 单个线程可以监听多个数据通道</p>
<p>NIO 详细介绍参考: <a href="/posts/2022/01/09/IO%E6%B5%81/" title="IO流">[io流]</a></p>
<h2 id="NIO-与-IO-的区别"><a href="#NIO-与-IO-的区别" class="headerlink" title="NIO 与 IO 的区别"></a>NIO 与 IO 的区别</h2><ul>
<li>IO 是面向流的, NIO 是面向缓冲区的</li>
<li>IO 流是阻塞的, NIO 流是不阻塞的</li>
<li>NIO 有选择器, 而 IO 没有</li>
</ul>
<h1 id="netty-组件"><a href="#netty-组件" class="headerlink" title="netty 组件"></a>netty 组件</h1><p>一个 netty 应用的常见组件:</p>
<ul>
<li>Bootstrap 和 ServerBootstrap</li>
<li>NioEventLoop 和 NioEventLoopGroup</li>
<li>Future 和 ChannelFuture</li>
<li>ChannelPipeline</li>
<li>Channel</li>
<li>ChannelHandler</li>
<li>ChannelHandlerContext</li>
<li>ChannelInitializer</li>
</ul>
<h2 id="Bootstrap-和-ServerBootstrap"><a href="#Bootstrap-和-ServerBootstrap" class="headerlink" title="Bootstrap 和 ServerBootstrap"></a>Bootstrap 和 ServerBootstrap</h2><p>bootstrap 用于引导 Netty 的启动, Bootstrap 是客户端的引导类, ServerBootstrap 是服务端引导类.</p>
<h2 id="NioEventLoop-和-NioEventLoopGroup"><a href="#NioEventLoop-和-NioEventLoopGroup" class="headerlink" title="NioEventLoop 和 NioEventLoopGroup"></a>NioEventLoop 和 NioEventLoopGroup</h2><p>NioEventLoopGroup 可以理解为线程池, NioEventLoop 理解为一个线程, 每个 EventLoop 对应一个 Selector, 负责处理多个 Channel 上的事件.</p>
<h2 id="Future-和-ChannelFuture"><a href="#Future-和-ChannelFuture" class="headerlink" title="Future 和 ChannelFuture"></a>Future 和 ChannelFuture</h2><p>Netty 中的操作都是异步的, 等待完成或者注册监听.</p>
<h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><p>用于保存处理过程需要用到的 ChannelHandler 和 ChannelHandlerContext</p>
<p>ChannelPipeline 是一个 handler 的集合, 它负责处理和拦截出站和入站的事件和操作<br>ChannelPipeline 实现了拦截过滤器模式, 使用户能控制事件的处理方式<br>在 Netty 中, 每个 Channel 都有且只有一个 ChannelPipeline 与之对应</p>
<p>一个 Channel 包含了一个 ChannelPipeline, 而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler</p>
<p>read 事件(入站事件)和 write 事件(出站事件)在一个双向链表中, 入站事件会从链表 head 往后传递到最后一个入站的 handler, 出站事件会从链表 tail 往前传递到最前一个出站的 handler, 两种类型的 handler 互不干扰</p>
<p><img src="/imgs/netty/netty-ChannelPipeline.jpg" alt="netty-ChannelPipeline"></p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Netty 网络通信的组件, 用于网络 IO 操作, 表示一个连接, 可以理解为每一个连接, 就是一个 Channel</p>
<p>通过 Channel 可以获得当前网络连接的通道的状态与网络配置参数</p>
<p>Channel 提供异步的网络 IO 操作, 调用后立即返回 ChannelFuture, 通过注册监听, 或者同步等待, 最终获取结果</p>
<p>Channel 根据不同的协议、不同的阻塞类型, 分为不同的 Channel 类型</p>
<h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>ChannelHandler 属于业务的核心接口, 用于处理 IO 事件或者拦截 IO 操作 (业务请求), 并将其转发到 ChannelPipeline (业务处理链) 中的下一个处理程序</p>
<h3 id="ServerBootstrap-的-childHandler-与-handler-的区别"><a href="#ServerBootstrap-的-childHandler-与-handler-的区别" class="headerlink" title="ServerBootstrap 的 childHandler()与 handler()的区别"></a>ServerBootstrap 的 childHandler()与 handler()的区别</h3><p>ServerBootstrap 的 childHandler() 与 handler() 添加的 handlers 是针对不同的 EventLoopGroup 起作用</p>
<ol>
<li>通过 handler 添加的 handlers 是对 bossGroup 线程组起作用</li>
<li>通过 childHandler 添加的 handlers 是对 workerGroup 线程组起作用</li>
<li><strong>handler 在初始化时就会执行, 而 childHandler 会在客户端成功 connect 后才执行, 这是两者的区别</strong></li>
</ol>
<p>Bootstrap 的 handler()</p>
<ol>
<li>客户端 Bootstrap 只有 handler()方法, 因为客户端只需要一个事件线程组</li>
</ol>
<h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><p>用于传输业务数据, 保存 Channel 相关的所有上下文信息, 同时关联一个 ChannelHandler</p>
<h2 id="ChannelInitializer"><a href="#ChannelInitializer" class="headerlink" title="ChannelInitializer"></a>ChannelInitializer</h2><p>ChannelInitializer 是一个特殊的 ChannelInboundHandler, 当一个 Channel 被注册到它的 EventLoop 时, 提供一个简单的方式用于初始化.<br>它的实现类通常在 Bootstrap.handler(ChannelHandler)&#x2F;ServerBootstrap.handler(ChannelHandler)和 ServerBootstrap.childHandler(ChannelHandler)的上下文中使用, 用于构建 channel 的 ChannelPipeline.</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>类 ChannelInitializer 对异常处理的方式就是做两个事情:</p>
<ol>
<li>打印日志</li>
<li>关闭 channel</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 打印日志</span></span><br><span class="line">    logger.warn(<span class="string">&quot;Failed to initialize a channel. Closing: &quot;</span> + ctx.channel(), cause);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ctx.pipeline();</span><br><span class="line">        <span class="comment">// 在关闭channel之前, 检查channel的pipeline中是否还包含当前ChannelInitializer的handler</span></span><br><span class="line">        <span class="keyword">if</span> (pipeline.context(<span class="built_in">this</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果有, 去除它</span></span><br><span class="line">            pipeline.remove(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 关闭channel</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然子类可以继续覆盖这个实现. 不过一般都够用了.</p>
<h1 id="netty-编解码"><a href="#netty-编解码" class="headerlink" title="netty 编解码"></a>netty 编解码</h1><p>netty 涉及到编解码的组件有 Channel、ChannelHandler、ChannelPipe</p>
<p>编解码可以理解序列化和反序列化, 即: 序列化是把消息对象转换成字节码; 反序列化是把字节码再转换成消息对象</p>
<p>Netty 里面提供默认的编解码器, 也支持自定义编解码器</p>
<ul>
<li>Encoder: 编码器, 负责处理 “入站 InboundHandler” 数据</li>
<li>Decoder: 解码器, 负责 “出站 OutboundHandler” 数据</li>
</ul>
<h2 id="编码器-Encoder"><a href="#编码器-Encoder" class="headerlink" title="编码器 Encoder"></a>编码器 Encoder</h2><p>Encoder 对应的是 ChannelOutboundHandler, 消息对象转换为字节数组</p>
<p>Netty 本身未提供和解码一样的编码器, 是因为场景不同, 两者非对等的</p>
<p>Encoder 最重要的实现类是 <code>MessageToByteEncoder&lt;T&gt;</code>, 这个类的作用就是将消息实体 T 从对象转换成 byte, 写入到 ByteBuf, 然后再丢给剩下的 ChannelOutboundHandler 传给客户端</p>
<p>主要是一个方法:</p>
<p>encode: encode 方法是继承 MessageToByteEncoder 唯一需要重写的方法</p>
<h3 id="抽象解码器"><a href="#抽象解码器" class="headerlink" title="抽象解码器"></a>抽象解码器</h3><h4 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h4><p>消息转为字节数组,调用 write 方法, 会先判断当前编码器是否支持需要发送的消息类型, 如果不支持, 则透传</p>
<h4 id="MessageToMessageEncoder"><a href="#MessageToMessageEncoder" class="headerlink" title="MessageToMessageEncoder"></a>MessageToMessageEncoder</h4><p>用于从一种消息编码为另外一种消息 (例如 POJO 到 POJO)</p>
<h3 id="已实现解码器"><a href="#已实现解码器" class="headerlink" title="已实现解码器"></a>已实现解码器</h3><h4 id="StringEncoder"><a href="#StringEncoder" class="headerlink" title="StringEncoder"></a>StringEncoder</h4><p>文本编码器, 将字符串编码为字节码</p>
<h2 id="解码器-Decoder"><a href="#解码器-Decoder" class="headerlink" title="解码器 Decoder"></a>解码器 Decoder</h2><p>Decoder 对应的是 ChannelInboundHandler, 主要是字节数组转换为消息对象</p>
<p>主要是两个方法:</p>
<ul>
<li>decode: ByteBuf 中有数据进来时调用</li>
<li>decodeLast: 只有在 Channel 的生命周期结束之前会调用一次</li>
</ul>
<h3 id="抽象解码器-1"><a href="#抽象解码器-1" class="headerlink" title="抽象解码器"></a>抽象解码器</h3><h4 id="ByteToMessageDecoder"><a href="#ByteToMessageDecoder" class="headerlink" title="ByteToMessageDecoder"></a>ByteToMessageDecoder</h4><p>用于将字节转为消息, 需要检查缓冲区是否有足够的字节</p>
<h4 id="ReplayingDecoder"><a href="#ReplayingDecoder" class="headerlink" title="ReplayingDecoder"></a>ReplayingDecoder</h4><p>ReplayingDecoder 是 byte-to-message 解码的一种特殊的抽象基类, 读取缓冲区的数据之前需要检查缓冲区是否有足够的字节, 使用 ReplayingDecoder 就无需自己检查; 若 ByteBuf 中有足够的字节, 则会正常读取; 若没有足够的字节则会停止解码.</p>
<p>RelayingDecoder 在使用的时候需要搞清楚的两个方法是 checkpoint(S s)和 state(), 其中 checkpoint 的参数 S, 代表的是 ReplayingDecoder 所处的状态, 一般是枚举类型. RelayingDecoder 是一个有状态的 Handler, 状态表示的是它目前读取到了哪一步, checkpoint(S s)是设置当前的状态, state()是获取当前的状态.</p>
<p>ReplayingDecoder 比 ByteToMessageDecoder 更加灵活, 能够通过巧妙的方式来处理复杂的业务逻辑, 但是也是因为这个原因, 使得 ReplayingDecoder 带有一定的局限性:</p>
<ul>
<li>不是所有的标准 ByteBuf 操作都被支持, 如果调用一个不支持的操作会抛出 UnreplayableOperationException</li>
<li>ReplayingDecoder 略慢于 ByteToMessageDecoder</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>在这里我们模拟一个简单的 Decoder, 假设每个包包含 length:int 和 content:String 两个数据, 其中 length 可以为 0, 代表一个空包, 大于 0 的时候代表 content 的长度.</p>
<p>操作步骤:</p>
<ol>
<li>继承 ReplayingDecoder, 泛型 LiveState, 用来表示当前读取的状态</li>
<li>描述 LiveState, 有读取长度和读取内容两个状态</li>
<li>初始化的时候设置为读取长度的状态</li>
<li>读取的时候通过 state()方法来确定当前处于什么状态</li>
<li>如果读取出来的长度大于 0, 则设置为读取内容状态, 下一次读取的时候则从这个位置开始</li>
<li>读取完成, 往结果里面放解析好的数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiveDecoder</span> <span class="keyword">extends</span> <span class="title class_">ReplayingDecoder</span>&lt;LiveDecoder.LiveState&gt; &#123; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LiveState</span> &#123; <span class="comment">//2</span></span><br><span class="line">        LENGTH,</span><br><span class="line">        CONTENT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">LiveMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiveDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(LiveState.LENGTH); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state()) &#123; <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">case</span> LENGTH:</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> byteBuf.readInt();</span><br><span class="line">                <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    checkpoint(LiveState.CONTENT); <span class="comment">// 5</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(message); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CONTENT:</span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[message.getLength()];</span><br><span class="line">                byteBuf.readBytes(bytes);</span><br><span class="line">                <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">                message.setContent(content);</span><br><span class="line">                list.add(message);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;invalid state:&quot;</span> + state());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageToMessageDecoder"><a href="#MessageToMessageDecoder" class="headerlink" title="MessageToMessageDecoder"></a>MessageToMessageDecoder</h4><p>用于从一种消息解码为另外一种消息 (例如 POJO 到 POJO)</p>
<h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>如果不引入过多的复杂性则使用 ReplayingDecoder, 否则使用 ByteToMessageDecoder</p>
<h3 id="已实现解码器-1"><a href="#已实现解码器-1" class="headerlink" title="已实现解码器"></a>已实现解码器</h3><h4 id="DelimiterBasedFrameDecoder"><a href="#DelimiterBasedFrameDecoder" class="headerlink" title="DelimiterBasedFrameDecoder"></a>DelimiterBasedFrameDecoder</h4><p>指定消息分隔符的解码器</p>
<h4 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h4><p>以换行符为结束标志的解码器</p>
<h4 id="FixedLengthFrameDecoder"><a href="#FixedLengthFrameDecoder" class="headerlink" title="FixedLengthFrameDecoder"></a>FixedLengthFrameDecoder</h4><p>固定长度解码器</p>
<h4 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h4><p>message &#x3D; header+body, 基于长度解码的通用解码器</p>
<h4 id="StringDecoder"><a href="#StringDecoder" class="headerlink" title="StringDecoder"></a>StringDecoder</h4><p>文本解码器, 将接收到的字节码转化为字符串, 一般会与上面的进行配合, 然后在后面添加业务 handle</p>
<h2 id="TCP-粘包、拆包"><a href="#TCP-粘包、拆包" class="headerlink" title="TCP 粘包、拆包"></a>TCP 粘包、拆包</h2><p>TCP 是一个流协议, 就是没有界限的一长串二进制数据. TCP 作为传输层协议并不不了解上层业务数据的具体含义, 它会根据 TCP 缓冲区的实际情况进行数据包的划分, 所以在业务上认为是一个完整的包, 可能会被 TCP 拆分成多个包进行发送, 也有可能把多个小的包封装成一个大的数据包发送, 这就是所谓的 TCP 粘包和拆包问题. 面向流的通信是无消息保护边界的.</p>
<p>UDP: 是有边界协议, 没有粘包和拆包的问题</p>
<ol>
<li>TCP 拆包: 一个完整的包可能会被 TCP 拆分为多个包进行发送</li>
<li>TCP 粘包: 把多个小的包封装成一个大的数据包发送, client 发送的若干数据包 Server 接收时粘成一包</li>
</ol>
<p>发送方和接收方都可能出现这个原因:</p>
<ul>
<li>发送方的原因: TCP 是流协议,TCP 默认会使用 Nagle 算法 (Nagle 算法就是为了尽可能发送大块数据, 避免网络中充斥着许多小数据块,当你连续发送小数据块的时候,他会收集到一定的大小才发出去)</li>
<li>接收方的原因: TCP 接收到数据放置缓存中, 应用程序从缓存中读取</li>
</ul>
<p>如下图所示, client 发了两个数据包 D1 和 D2, 但是 server 端可能会收到如下几种情况的数据:</p>
<p><img src="/imgs/netty/netty-tcp%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.png" alt="netty-tcp粘包拆包"></p>
<h3 id="粘包、拆包解决方案"><a href="#粘包、拆包解决方案" class="headerlink" title="粘包、拆包解决方案"></a>粘包、拆包解决方案</h3><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p>对于发送方造成的粘包问题, 可以通过关闭 Nagle 算法来解决, 使用 TCP_NODELAY 选项来关闭算法</p>
<h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p>接收方没有办法来处理粘包现象, 只能将问题交给应用层来处理</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层的解决办法简单可行, 不仅能解决接收方的粘包问题, 还可以解决发送方的粘包问题</p>
<p>解决办法:</p>
<ol>
<li>格式化数据: 每条数据有固定的格式 (开始符, 结束符) , 这种方法简单易行, 但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符.</li>
<li>消息定长: 传输的数据大小固定长度, 例如每段的长度固定为 100 字节, 如果不够空位补空格.</li>
<li>发送长度: 发送每条数据时, 将数据的长度一并发送, 例如规定数据的前 4 位是数据的长度, 应用层在处理时可以根据长度来判断每个分组的开始和结束位置.</li>
</ol>
<p>Netty 提供了多个解码器, 可以进行分包的操作, 如下:</p>
<ul>
<li>LineBasedFrameDecoder (回车换行分包)</li>
<li>DelimiterBasedFrameDecoder (特殊分隔符分包)</li>
<li>FixedLengthFrameDecoder (固定长度报文来分包)</li>
</ul>
<p>这些分包解码器只需要放在我们的字符串解码器之前就好了,这些分包解码器也是入站 Handler,继承了我们的 InboundHandler:</p>
<p><img src="/source/imgs/netty/netty-diagram-DelimiterBasedFrameDecoder.png" alt="netty-diagram-DelimiterBasedFrameDecoder"></p>
<h3 id="粘包、拆包示例"><a href="#粘包、拆包示例" class="headerlink" title="粘包、拆包示例"></a>粘包、拆包示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.io.netty.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> C</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackUnpackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; <span class="keyword">new</span> <span class="title class_">Server</span>().start(<span class="number">8888</span>)).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; <span class="keyword">new</span> <span class="title class_">Client</span>().start(<span class="number">8888</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">            <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="type">EventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">                bootstrap.group(bossGroup, workGroup)</span><br><span class="line">                        .channel(NioServerSocketChannel.class)</span><br><span class="line">                        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                        .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG))</span><br><span class="line">                        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"><span class="comment">//                                // 特殊分隔符分包解码器</span></span><br><span class="line"><span class="comment">//                                // 加入之后本例子中不会发生拆包粘包问题</span></span><br><span class="line"><span class="comment">//                                pipeline.addLast(new DelimiterBasedFrameDecoder(1024, Unpooled.copiedBuffer(&quot;!&quot;.getBytes())));</span></span><br><span class="line">                                <span class="comment">// 向pipeline加入解码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                                <span class="comment">// 向pipeline加入编码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                                <span class="comment">// 加入自己的业务处理handler</span></span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChatServerHandler</span>());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                log.info(<span class="string">&quot;server启动...&quot;</span>);</span><br><span class="line">                <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line">                <span class="comment">// 关闭通道</span></span><br><span class="line">                channelFuture.channel().closeFuture().sync();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;exception: &quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                bossGroup.shutdownGracefully();</span><br><span class="line">                workGroup.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">            <span class="type">EventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">                bootstrap.group(workGroup)</span><br><span class="line">                        .channel(NioSocketChannel.class)</span><br><span class="line">                        .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                        .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG))</span><br><span class="line">                        .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"><span class="comment">//                                // 加入特殊分隔符分包解码器 (在本例子中无用, 本例子客户端不需要解码器)</span></span><br><span class="line"><span class="comment">//                                pipeline.addLast(new DelimiterBasedFrameDecoder(1024, Unpooled.copiedBuffer(&quot;!&quot;.getBytes())));</span></span><br><span class="line"><span class="comment">//                                // 向pipeline加入解码器 (在本例子中无用, 本例子客户端不需要解码器)</span></span><br><span class="line"><span class="comment">//                                pipeline.addLast(&quot;decoder&quot;, new StringDecoder());</span></span><br><span class="line">                                <span class="comment">// 向pipeline加入编码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"><span class="comment">//                                // 加入自己的业务处理handler (在本例子中无用, 本例子客户端不需要业务处理器)</span></span><br><span class="line"><span class="comment">//                                pipeline.addLast(new ChatServerHandler());</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                log.info(<span class="string">&quot;client启动...&quot;</span>);</span><br><span class="line">                <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, port).sync();</span><br><span class="line">                <span class="comment">// 得到 channel</span></span><br><span class="line">                <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (count++ &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                    channel.writeAndFlush(<span class="string">&quot;你好,我是Netty!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;发送次数: &#123;&#125;&quot;</span>, count - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 睡眠一段时间等待消息发送完</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;exception: &quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                workGroup.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChatServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            log.info(msg);</span><br><span class="line">            <span class="comment">// 根据 &quot;你&quot; 判断消息发送情况, 结果会小于实际发送次数, 因为 &quot;你&quot; 的字节发生了拆包</span></span><br><span class="line">            log.info(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count.addAndGet(appearNumber(msg, <span class="string">&quot;你&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定字符串出现的次数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> srcText  源字符串</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> findText 要查找的字符串</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 出现次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">appearNumber</span><span class="params">(String srcText, String findText)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(findText);</span><br><span class="line">            <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(srcText);</span><br><span class="line">            <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">20230411 160139.853 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] 你好,我是Netty!</span><br><span class="line">20230411 160139.853 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] count: 991</span><br><span class="line">20230411 160139.853 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] 你好,我是Netty!你好,我是Netty!</span><br><span class="line">20230411 160139.853 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] count: 992</span><br><span class="line">20230411 160139.854 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] 你好,我是Netty!你好,我是Netty!你好,我是Netty!你好,我是Netty!你�</span><br><span class="line">20230411 160139.854 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] count: 997</span><br><span class="line">20230411 160139.854 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] ��,我是Netty!你好,我是Netty!</span><br><span class="line">20230411 160139.854 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] count: 998</span><br><span class="line">20230411 160139.854 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] 你好,我是Netty!</span><br><span class="line">20230411 160139.854 pid:test_project thread:nioEventLoopGroup-3-1 INFO [ChatServerHandler] count: 999</span><br></pre></td></tr></table></figure>

<p>由输出可以看到发生了粘包、拆包问题, 多个 “你好,我是 Netty!” 合并在了一起; 输出中的乱码是因为 “好” 字发生了拆包, UTF-8 的中文是 3 个字节, 3 个字节被拆分了两部分</p>
<h2 id="UDP-丢包"><a href="#UDP-丢包" class="headerlink" title="UDP 丢包"></a>UDP 丢包</h2><h3 id="主要丢包原因"><a href="#主要丢包原因" class="headerlink" title="主要丢包原因"></a>主要丢包原因</h3><ol>
<li><strong>接收端处理时间过长导致丢包</strong>: 调用 recv 方法接收端收到数据后, 处理数据花了一些时间, 处理完后再次调用 recv 方法, 在这二次调用间隔里,发过来的包可能丢失. 对于这种情况可以修改接收端, 将包接收后存入一个缓冲区, 然后迅速返回继续 recv.</li>
<li><strong>发送的包巨大丢包</strong>: 虽然 send 方法会做大包切割成小包发送的事情, 但包太大也不行. 例如超过 50K 的一个 udp 包, 不切割直接通过 send 方法发送也会导致这个包丢失. 这种情况需要切割成小包再逐个 send.</li>
<li><strong>发送的包较大</strong>: 超过接受者缓存导致丢包: 包超过 mtu size 数倍, 几个大的 udp 包可能会超过接收者的缓冲, 导致丢包. 这种情况可以设置 socket 接收缓冲. 遇到过这种问题, 可以把接收缓冲设置成 64K 解决.<br><code>int nRecvBuf=32*1024;//设置为 32K</code><br><code>setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&amp;nRecvBuf,sizeof(int));</code></li>
<li><strong>发送的包频率太快</strong>: 虽然每个包的大小都小于 mtu size 但是频率太快, 例如 40 多个 mut size 的包连续发送中间不 sleep, 也有可能导致丢包. 这种情况也有时可以通过设置 socket 接收缓冲解决, 但有时解决不了. 所以在发送频率过快的时候还是考虑 sleep 一下吧.</li>
<li><strong>局域网内不丢包, 公网上丢包</strong>: 这个问题可以通过切割小包并 sleep 发送解决的. 如果流量太大, 这个办法也不灵了. 总之 udp 丢包总是会有的, 如果出现了切割小包的方法解决不了, 还有这个几个方法: 要么减小流量, 要么换 tcp 协议传输, 要么做丢包重传的工作.</li>
</ol>
<h1 id="netty-内存管理"><a href="#netty-内存管理" class="headerlink" title="netty 内存管理"></a>netty 内存管理</h1><p>为了减轻 GC 的压力、以及避免频繁向 OS 申请和释放内存, Netty 基于 JeMalloc 思想自己实现了一套内存管理方案. 不管是堆内存还是直接内存, 都可以交给 Netty 来统一管理, 这带来了两个好处, 一是可以减轻 GC 的压力, 二是可以避免向 OS 频繁申请和释放内存, Netty 一次性申请一大块内存, 然后按需分配.</p>
<p>**注意: ByteBuf 不等于内存, ByteBuf 是 Java 对象, 它工作需要内存做支撑. ByteBuf 本身通过 Recycler 来实现回收重用, 内存通过 JeMalloc 来进行管理复用. **</p>
<p>以 ByteBuf 为例, 网络 IO 的每次读写都需要 ByteBuf 支撑, 为了避免频繁的创建和销毁 ByteBuf, Netty 通过 Recycler 来回收对象进行重用. 同时为了避免频繁的申请和释放内存, Netty 通过 JeMalloc 技术来管理内存.</p>
<h2 id="netty-零拷贝"><a href="#netty-零拷贝" class="headerlink" title="netty 零拷贝"></a>netty 零拷贝</h2><p>零拷贝是一个耳熟能详的词语, 在 Linux、Kafka、RocketMQ 等知名的产品中都有使用, 通常用于提升 I&#x2F;O 性能.</p>
<p>在介绍 netty 零拷贝之前简单熟悉一下 linux 零拷贝</p>
<h3 id="Linux-零拷贝"><a href="#Linux-零拷贝" class="headerlink" title="Linux 零拷贝"></a>Linux 零拷贝</h3><p>所谓零拷贝, 就是在数据操作时, 不需要将数据从一个内存位置拷贝到另外一个内存位置, 这样可以减少一次内存拷贝的损耗, 从而节省了 CPU 时钟周期和内存带宽.</p>
<p>从文件中读取数据, 然后将数据传输到网络上, 传统的数据拷贝过程会分为以下几个阶段:</p>
<p><img src="/imgs/netty/netty-memory-linux%E5%86%85%E5%AD%98%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D.png" alt="netty-memory-linux内存传统拷贝"></p>
<p>从上图中可以看出, 从数据读取到发送一共经历了四次数据拷贝, 具体流程如下:</p>
<ol>
<li>当用户进程发起 read() 调用后, 上下文从用户态切换至内核态. DMA 引擎从文件中读取数据, 并存储到内核态缓冲区, 这里是第一次数据拷贝.</li>
<li>请求的数据从内核态缓冲区拷贝到用户态缓冲区, 然后返回给用户进程. 第二次数据拷贝的过程同时, 会导致上下文从内核态再次切换到用户态.</li>
<li>用户进程调用 send() 方法期望将数据发送到网络中, 此时会触发第三次线程切换, 用户态会再次切换到内核态, 请求的数据从用户态缓冲区被拷贝到 Socket 缓冲区.</li>
<li>最终 send() 系统调用结束返回给用户进程, 发生了第四次上下文切换. 第四次拷贝会异步执行, 从 Socket 缓冲区拷贝到协议引擎中.</li>
</ol>
<blockquote>
<p>说明: DMA (Direct Memory Access, 直接内存存取) 是现代大部分硬盘都支持的特性, DMA 接管了数据读写的工作, 不需要 CPU 再参与 I&#x2F;O 中断的处理, 从而减轻了 CPU 的负担.</p>
</blockquote>
<h4 id="sendfile-模式"><a href="#sendfile-模式" class="headerlink" title="sendfile 模式"></a>sendfile 模式</h4><p>传统的数据拷贝过程为什么不是将数据直接传输到用户缓冲区呢? 其实引入内核缓冲区可以充当缓存的作用, 这样就可以实现文件数据的预读, 提升 I&#x2F;O 的性能. 但是当请求数据量大于内核缓冲区大小时, 在完成一次数据的读取到发送可能要经历数倍次数的数据拷贝, 这就造成严重的性能损耗.</p>
<p>接下来我们介绍下使用零拷贝技术之后数据传输的流程: DMA 引擎从文件读取数据后放入到内核缓冲区, 然后可以直接从内核缓冲区传输到 Socket 缓冲区, 从而减少内存拷贝的次数.</p>
<p>在 Linux 中系统调用 sendfile() 可以实现将数据从一个文件描述符传输到另一个文件描述符, 从而实现了零拷贝技术. 在 Java 中也使用了零拷贝技术, 它就是 NIO FileChannel 类中的 transferTo() 方法, transferTo() 底层就依赖了操作系统零拷贝的机制, 它可以将数据从 FileChannel 直接传输到另外一个 Channel. transferTo() 方法的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把数据从当前通道复制给目标通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferTo</span><span class="params">(<span class="type">long</span> position, <span class="type">long</span> count, WriteableByteChannel target)</span></span><br></pre></td></tr></table></figure>

<p><code>transferTo()</code> 详细用法可以参考: <a href="/posts/2022/01/09/IO%E6%B5%81/" title="IO流">[io流]</a> 中的 <code>通道间数据复制</code> 模块</p>
<p>在使用了 FileChannel#transferTo() 传输数据之后, 我们看下数据拷贝流程发生了哪些变化, 如下图所示:</p>
<p><img src="/imgs/netty/netty-memory-linux%E5%86%85%E5%AD%98%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="netty-memory-linux内存零拷贝"></p>
<p>比较大的一个变化是, DMA 引擎从文件中读取数据拷贝到内核态缓冲区之后, 由操作系统直接拷贝到 Socket 缓冲区, 不再拷贝到用户态缓冲区, 所以数据拷贝的次数从之前的 4 次减少到 3 次.</p>
<p>**但是上述的优化离达到零拷贝的要求还是有差距的, 能否继续减少内核中的数据拷贝次数呢? **</p>
<h4 id="sendfile-DMA-gather-copy-模式"><a href="#sendfile-DMA-gather-copy-模式" class="headerlink" title="sendfile + DMA gather copy 模式"></a>sendfile + DMA gather copy 模式</h4><p>Linux 2.4 版本对 sendfile 系统调用进行修改, 为 DMA 拷贝引入了 gather 操作. 它将内核空间 (kernel space) 的读缓冲区 (read buffer) 中对应的数据描述信息 (内存地址、地址偏移量) 记录到相应的网络缓冲区 ( socket buffer) 中, 由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区 (read buffer) 拷贝到网卡设备中. 这样就省去了内核空间中仅剩的 1 次 CPU 拷贝操作, sendfile 的伪代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sendfile</span>(socket_fd, file_fd, len);</span><br></pre></td></tr></table></figure>

<p>在硬件的支持下, sendfile 拷贝方式不再从内核缓冲区的数据拷贝到 socket 缓冲区, 取而代之的仅仅是缓冲区文件描述符和数据长度的拷贝, 这样 DMA 引擎直接利用 gather 操作将页缓存中数据打包发送到网络中即可, 本质就是和虚拟内存映射的思路类似.</p>
<p>拷贝流程如下图所示:</p>
<p><img src="/imgs/netty/netty-memory-linux%E5%86%85%E5%AD%98%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96.png" alt="netty-memory-linux内存零拷贝优化.png"></p>
<p>基于 sendfile + DMA gather copy 系统调用的零拷贝方式, 整个拷贝过程会发生 2 次上下文切换、0 次 CPU 拷贝以及 2 次 DMA 拷贝, 用户程序读写数据的流程如下:</p>
<ol>
<li>用户进程通过 sendfile() 函数向内核 (kernel) 发起系统调用, 上下文从用户态 (user space) 切换为内核态 (kernel space) .</li>
<li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间 (kernel space) 的读缓冲区 (read buffer) .</li>
<li>CPU 把读缓冲区 (read buffer) 的文件描述符 (file descriptor) 和数据长度拷贝到网络缓冲区 (socket buffer) .</li>
<li>基于已拷贝的文件描述符 (file descriptor) 和数据长度, CPU 利用 DMA 控制器的 gather&#x2F;scatter 操作直接批量地将数据从内核的读缓冲区 (read buffer) 拷贝到网卡进行数据传输.</li>
<li>上下文从内核态 (kernel space) 切换回用户态 (user space) , sendfile 系统调用执行返回.</li>
</ol>
<p>sendfile + DMA gather copy 拷贝方式同样存在用户程序不能对数据进行修改的问题, 而且本身需要硬件的支持, 它只适用于将数据从文件拷贝到 socket 套接字上的传输过程.</p>
<h3 id="netty-零拷贝-1"><a href="#netty-零拷贝-1" class="headerlink" title="netty 零拷贝"></a>netty 零拷贝</h3><p>介绍完传统 Linux 的零拷贝技术之后, 我们再来学习下 Netty 中的零拷贝如何实现. Netty 中的零拷贝和传统 Linux 的零拷贝不太一样. Netty 中的零拷贝技术除了操作系统级别的功能封装, 更多的是面向用户态的数据操作优化, 主要体现在以下 5 个方面:</p>
<ol>
<li>堆外内存, 避免 JVM 堆内存到堆外内存的数据拷贝.</li>
<li>CompositeByteBuf 类, 可以组合多个 Buffer 对象合并成一个逻辑上的对象, 避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer.</li>
<li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象, 包装过程中不会产生内存拷贝.</li>
<li>ByteBuf.slice 操作与 Unpooled.wrappedBuffer 相反, slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象, 切分过程中不会产生内存拷贝, 底层共享一个 byte 数组的存储空间.</li>
<li>Netty 使用 FileRegion 实现文件传输, FileRegion 底层封装了 FileChannel#transferTo() 方法, 可以将文件缓冲区的数据直接传输到目标 Channel, 避免内核缓冲区和用户态缓冲区之间的数据拷贝, 这属于操作系统级别的零拷贝.</li>
</ol>
<p>下面我们从以上 5 个方面逐一进行介绍.</p>
<h4 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h4><p>如果在 JVM 内部执行 I&#x2F;O 操作时, 必须将数据拷贝到堆外内存, 才能执行系统调用. 这是所有 VM 语言都会存在的问题. 那么为什么操作系统不能直接使用 JVM 堆内存进行 I&#x2F;O 的读写呢? 主要有两点原因: 第一, 操作系统并不感知 JVM 的堆内存, 而且 JVM 的内存布局与操作系统所分配的是不一样的, 操作系统并不会按照 JVM 的行为来读写数据. 第二, 同一个对象的内存地址随着 JVM GC 的执行可能会随时发生变化, 例如 JVM GC 的过程中会通过压缩来减少内存碎片, 这就涉及对象移动的问题了.</p>
<p>Netty 在进行 I&#x2F;O 操作时都是使用的堆外内存, 可以避免数据从 JVM 堆内存到堆外内存的拷贝.</p>
<blockquote>
<p>Netty 也可以声明为堆内内存</p>
</blockquote>
<h4 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h4><p>CompositeByteBuf 是 Netty 中实现零拷贝机制非常重要的一个数据结构, CompositeByteBuf 可以理解为一个虚拟的 Buffer 对象, 它是由多个 ByteBuf 组合而成, 但是在 CompositeByteBuf 内部保存着每个 ByteBuf 的引用关系, 从逻辑上构成一个整体. 比较常见的像 HTTP 协议数据可以分为头部信息 header 和消息体数据 body, 分别存在两个不同的 ByteBuf 中, 通常我们需要将两个 ByteBuf 合并成一个完整的协议数据进行发送, 可以使用如下方式完成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个新的 ByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">httpBuf</span> <span class="operator">=</span> Unpooled.buffer(header.readableBytes() + body.readableBytes());</span><br><span class="line"><span class="comment">// 将 header 拷贝到新的 ByteBuf</span></span><br><span class="line">httpBuf.writeBytes(header);</span><br><span class="line"><span class="comment">// 将 body 拷贝到新的 ByteBuf</span></span><br><span class="line">httpBuf.writeBytes(body);</span><br></pre></td></tr></table></figure>

<p>可以看出合并过程中涉及两次 CPU 拷贝, 这非常浪费性能. 如果使用 CompositeByteBuf 如何实现类似的需求呢? 如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个新的 CompositeByteBuf</span></span><br><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">httpBuf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line"><span class="comment">// 调用 addComponents() 方法来添加 header 和 body</span></span><br><span class="line">httpBuf.addComponents(<span class="literal">true</span>, header, body);</span><br></pre></td></tr></table></figure>

<p>CompositeByteBuf 通过调用 addComponents() 方法来添加多个 ByteBuf, 但是底层的 byte 数组是复用的, 不会发生内存拷贝. 但对于用户来说, 它可以当作一个整体进行操作. 那么 CompositeByteBuf 内部是如何存放这些 ByteBuf, 并且如何进行合并的呢? 我们先通过一张图看下 CompositeByteBuf 的内部结构:</p>
<p><img src="/imgs/netty/netty-memory-CompositeByteBuf.png" alt="netty-memory-CompositeByteBuf"></p>
<p>从图上可以看出, CompositeByteBuf 内部维护了一个 Components 数组. 在每个 Component 中存放着不同的 ByteBuf, 各个 ByteBuf 独立维护自己的读写索引, 而 CompositeByteBuf 自身也会单独维护一个读写索引. 由此可见, Component 是实现 CompositeByteBuf 的关键所在, 下面看下 Component 结构定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf srcBuf; <span class="comment">// 原始的 ByteBuf</span></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf; <span class="comment">// srcBuf 去除包装之后的 ByteBuf</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> srcAdjustment; <span class="comment">// 这个 CompositeByteBuf 相对于 srcBuf 的起始索引</span></span><br><span class="line">    <span class="type">int</span> adjustment; <span class="comment">// 这个 CompositeByteBuf 相对于 buf 的起始索引</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> offset; <span class="comment">// Component 在 CompositeByteBuf 中的内部偏移索引</span></span><br><span class="line">    <span class="type">int</span> endOffset; <span class="comment">// Component 在 CompositeByteBuf 中的内部结束索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteBuf slice; <span class="comment">// cached slice, may be null</span></span><br><span class="line"></span><br><span class="line">    Component(ByteBuf srcBuf, <span class="type">int</span> srcOffset, ByteBuf buf, <span class="type">int</span> bufOffset,</span><br><span class="line">            <span class="type">int</span> offset, <span class="type">int</span> len, ByteBuf slice) &#123;</span><br><span class="line">        <span class="built_in">this</span>.srcBuf = srcBuf;</span><br><span class="line">        <span class="built_in">this</span>.srcAdjustment = srcOffset - offset;</span><br><span class="line">        <span class="built_in">this</span>.buf = buf;</span><br><span class="line">        <span class="built_in">this</span>.adjustment = bufOffset - offset;</span><br><span class="line">        <span class="built_in">this</span>.offset = offset;</span><br><span class="line">        <span class="built_in">this</span>.endOffset = offset + len;</span><br><span class="line">        <span class="built_in">this</span>.slice = slice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">srcIdx</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index + srcAdjustment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">idx</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index + adjustment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> endOffset - offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便理解上述 Component 中的属性含义, 我同样以 HTTP 协议中 header 和 body 为示例, 通过一张图来描述 CompositeByteBuf 组合后其中 Component 的布局情况, 如下所示:</p>
<p><img src="/imgs/netty/netty-memory-CompositeByteBuf2.png" alt="netty-memory-CompositeByteBuf2"></p>
<p>从图中可以看出, header 和 body 分别对应两个 ByteBuf, 假设 ByteBuf 的内容分别为 “header” 和 “body”, 那么 header ByteBuf 中 offset<del>endOffset 为 0</del>6, body ByteBuf 对应的 offset<del>endOffset 为 6</del>10. 由此可见, Component 中的 offset 和 endOffset 可以表示当前 ByteBuf 可以读取的范围, 通过 offset 和 endOffset 可以将每一个 Component 所对应的 ByteBuf 连接起来, 形成一个逻辑整体.</p>
<p>此外 Component 中 srcAdjustment 和 adjustment 表示这个 CompositeByteBuf 相对于 srcBuf 的起始索引. 初始 adjustment &#x3D; readIndex - offset, 这样通过 ByteBuf 在 CompositeByteBuf 的起始索引就可以直接定位到 Component 中 ByteBuf 的读索引位置. 例如: 当 header ByteBuf 读取 1 个字节, body ByteBuf 读取 2 个字节, 此时每个 Component 的属性如下图所示.</p>
<p><img src="/imgs/netty/netty-memory-CompositeByteBuf3.png" alt="netty-memory-CompositeByteBuf3"></p>
<h4 id="Unpooled-wrappedBuffer-操作"><a href="#Unpooled-wrappedBuffer-操作" class="headerlink" title="Unpooled.wrappedBuffer 操作"></a>Unpooled.wrappedBuffer 操作</h4><p>介绍完 CompositeByteBuf 之后, 再来理解 Unpooled.wrappedBuffer 操作就非常容易了.</p>
<p>Unpooled.wrappedBuffer 同时也是创建 CompositeByteBuf 对象的另一种推荐做法.</p>
<p>Unpooled 提供了一系列用于包装数据源的 wrappedBuffer 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a new big-endian buffer which wraps the specified array. A modification on the specified array&#x27;s content will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(<span class="type">byte</span>[] array)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new big-endian buffer which wraps the sub-region of the specified array. A modification on the specified array&#x27;s content will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(<span class="type">byte</span>[] array, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new buffer which wraps the specified NIO buffer&#x27;s current slice. A modification on the specified buffer&#x27;s content will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(ByteBuffer buffer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new buffer which wraps the specified memory address. If doFree is true the memoryAddress will automatically be freed once the reference count of the ByteBuf reaches 0.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(<span class="type">long</span> memoryAddress, <span class="type">int</span> size, <span class="type">boolean</span> doFree)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new buffer which wraps the specified buffer&#x27;s readable bytes. A modification on the specified buffer&#x27;s content will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(ByteBuf buffer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new big-endian composite buffer which wraps the specified arrays without copying them. A modification on the specified arrays&#x27; content will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(<span class="type">byte</span>[]... arrays)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new big-endian composite buffer which wraps the readable bytes of the specified buffers without copying them. A modification on the content of the specified buffers will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(ByteBuf... buffers)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new big-endian composite buffer which wraps the slices of the specified NIO buffers without copying them. A modification on the content of the specified buffers will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(ByteBuffer... buffers)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(<span class="type">int</span> maxNumComponents, ByteWrapper&lt;T&gt; wrapper, T[] array)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new big-endian composite buffer which wraps the specified arrays without copying them. A modification on the specified arrays&#x27; content will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(<span class="type">int</span> maxNumComponents, <span class="type">byte</span>[]... arrays)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new big-endian composite buffer which wraps the readable bytes of the specified buffers without copying them. A modification on the content of the specified buffers will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(<span class="type">int</span> maxNumComponents, ByteBuf... buffers)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new big-endian composite buffer which wraps the slices of the specified NIO buffers without copying them. A modification on the content of the specified buffers will be visible to the returned buffer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">wrappedBuffer</span><span class="params">(<span class="type">int</span> maxNumComponents, ByteBuffer... buffers)</span>;</span><br></pre></td></tr></table></figure>

<p>Unpooled.wrappedBuffer 方法可以将不同的数据源的一个或者多个数据包装成一个大的 ByteBuf 对象, 其中数据源的类型包括 byte[]、ByteBuf、ByteBuffer. 包装的过程中不会发生数据拷贝操作, 包装后生成的 ByteBuf 对象和原始 ByteBuf 对象是共享底层的 byte 数组.</p>
<h4 id="ByteBuf-slice-操作"><a href="#ByteBuf-slice-操作" class="headerlink" title="ByteBuf.slice 操作"></a>ByteBuf.slice 操作</h4><p>ByteBuf.slice 和 Unpooled.wrappedBuffer 的逻辑正好相反, ByteBuf.slice 是将一个 ByteBuf 对象切分成多个共享同一个底层存储的 ByteBuf 对象.</p>
<p>ByteBuf 提供了两个 slice 切分方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a slice of this buffer&#x27;s readable bytes. Modifying the content of the returned buffer or this buffer affects each other&#x27;s content while they maintain separate indexes and marks. This method is identical to buf.slice(buf.readerIndex(), buf.readableBytes()). This method does not modify readerIndex or writerIndex of this buffer.</span></span><br><span class="line"><span class="comment">// Note that this method returns a retained buffer unlike slice(). This method behaves similarly to slice().retain() except that this method may return a buffer implementation that produces less garbage.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title function_">slice</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a slice of this buffer&#x27;s sub-region. Modifying the content of the returned buffer or this buffer affects each other&#x27;s content while they maintain separate indexes and marks. This method does not modify readerIndex or writerIndex of this buffer.</span></span><br><span class="line"><span class="comment">// Also be aware that this method will NOT call retain() and so the reference count will NOT be increased.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title function_">slice</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>假设我们已经有一份完整的 HTTP 数据, 可以通过 slice 方法切分获得 header 和 body 两个 ByteBuf 对象, 对应的内容分别为 “header” 和 “body”, 实现方式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">httpBuf</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">header</span> <span class="operator">=</span> httpBuf.slice(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">body</span> <span class="operator">=</span> httpBuf.slice(<span class="number">6</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>通过 slice 切分后都会返回一个新的 ByteBuf 对象, 而且新的对象有自己独立的 readerIndex、writerIndex 索引, 如下图所示. 由于新的 ByteBuf 对象与原始的 ByteBuf 对象数据是共享的, 所以通过新的 ByteBuf 对象进行数据操作也会对原始 ByteBuf 对象生效.</p>
<p><img src="/imgs/netty/netty-memory-ByteBuf-slice.png" alt="netty-memory-ByteBuf-slice"></p>
<h4 id="文件传输-FileRegion"><a href="#文件传输-FileRegion" class="headerlink" title="文件传输 FileRegion"></a>文件传输 FileRegion</h4><p>在 Netty 源码的 example 包中, 提供了 FileRegion 的使用示例, 以下代码片段摘自 FileServerHandler.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(msg, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        length = raf.length();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ctx.writeAndFlush(<span class="string">&quot;ERR: &quot;</span> + e.getClass().getSimpleName() + <span class="string">&quot;: &quot;</span> + e.getMessage() + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">0</span> &amp;&amp; raf != <span class="literal">null</span>) &#123;</span><br><span class="line">            raf.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.write(<span class="string">&quot;OK: &quot;</span> + raf.length() + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ctx.pipeline().get(SslHandler.class) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// SSL not enabled - can use zero-copy file transfer.</span></span><br><span class="line">        ctx.write(<span class="keyword">new</span> <span class="title class_">DefaultFileRegion</span>(raf.getChannel(), <span class="number">0</span>, length));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// SSL enabled - cannot use zero-copy file transfer.</span></span><br><span class="line">        ctx.write(<span class="keyword">new</span> <span class="title class_">ChunkedFile</span>(raf));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.writeAndFlush(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 FileRegion 的使用示例可以看出, Netty 使用 FileRegion 实现文件传输的零拷贝. FileRegion 的默认实现类是 DefaultFileRegion, 通过 DefaultFileRegion 将文件内容写入到 NioSocketChannel. 那么 FileRegion 是如何实现零拷贝的呢? 我们通过源码看看 FileRegion 到底使用了什么黑科技.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFileRegion</span> <span class="keyword">extends</span> <span class="title class_">AbstractReferenceCounted</span> <span class="keyword">implements</span> <span class="title class_">FileRegion</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File f; <span class="comment">// 传输的文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> position; <span class="comment">// 文件的起始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> count; <span class="comment">// 传输的字节数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> transferred; <span class="comment">// 已经写入的字节数</span></span><br><span class="line">    <span class="keyword">private</span> FileChannel file; <span class="comment">// 文件对应的 FileChannel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferTo</span><span class="params">(WritableByteChannel target, <span class="type">long</span> position)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count - position;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span> || position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;position out of range: &quot;</span> + position +</span><br><span class="line">                    <span class="string">&quot; (expected: 0 - &quot;</span> + (<span class="built_in">this</span>.count - <span class="number">1</span>) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (refCnt() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Call open to make sure fc is initialized. This is a no-oop if we called it before.</span></span><br><span class="line">        open();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">written</span> <span class="operator">=</span> file.transferTo(<span class="built_in">this</span>.position + position, count, target);</span><br><span class="line">        <span class="keyword">if</span> (written &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            transferred += written;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (written == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If the amount of written data is 0 we need to check if the requested count is bigger then the</span></span><br><span class="line">            <span class="comment">// actual file itself as it may have been truncated on disk.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/8868</span></span><br><span class="line">            validate(<span class="built_in">this</span>, position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> written;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出, FileRegion 其实就是对 FileChannel 的包装, 并没有什么特殊操作, 底层使用的是 JDK NIO 中的 FileChannel#transferTo() 方法实现文件传输, 所以 FileRegion 是操作系统级别的零拷贝, 对于传输大文件会很有帮助.</p>
<p>可以看出 Netty 对于 ByteBuf 做了更多精进的设计和优化.</p>
<h2 id="netty-泄漏检测"><a href="#netty-泄漏检测" class="headerlink" title="netty 泄漏检测"></a>netty 泄漏检测</h2><p>Netty 统一管理内存在减轻 GC 的压力, 避免向 OS 频繁申请和释放内存的同时, 也带来一个坏处, 就是开发者使用完毕后, 必须及时释放掉资源, 否则会导致内存泄漏.</p>
<p>自己管理内存会带来更好的性能, 但是也增大了内存泄漏的可能性. 为了尽量避免内存泄漏, Netty 提供了 ResourceLeakDetector 资源泄漏探测器, 它会对分配的资源进行检测, 一旦发生泄漏, 它会进行报告, 让开发者能及时发现并进行修正. ​</p>
<h3 id="ResourceLeakDetector-简介"><a href="#ResourceLeakDetector-简介" class="headerlink" title="ResourceLeakDetector 简介"></a>ResourceLeakDetector 简介</h3><p>当 Channel 有数据可读时, Netty 默认会通过 PooledByteBufAllocator 创建一个 ByteBuf, 并将数据写入到 ByteBuf, 然后通过 Pipeline 将 ChannelRead 事件传播出去. 如下, 是一个简单的使用示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakDemo</span> &#123;</span><br><span class="line">    <span class="comment">// VM Args:-Dio.netty.leakDetection.level=PARANOID 100%采样检测</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> PooledByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">        buf = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 再申请一次, 此时会检测到泄漏并报告</span></span><br><span class="line">        PooledByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序, 控制台会报告资源泄漏的情况, 输出如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">161610.021 pid:test_project thread:main ERROR [ResourceLeakDetector] LEAK: ByteBuf.release() was not called before it<span class="string">&#x27;s garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.</span></span><br><span class="line"><span class="string">Recent access records:</span></span><br><span class="line"><span class="string">Created at:</span></span><br><span class="line"><span class="string">    io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:403)</span></span><br><span class="line"><span class="string">    io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:188)</span></span><br><span class="line"><span class="string">    io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:179)</span></span><br><span class="line"><span class="string">    io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:116)</span></span><br><span class="line"><span class="string">    test.io.netty.demo.LeakDemo.main(LeakDemo.java:9)</span></span><br></pre></td></tr></table></figure>

<h3 id="ResourceLeakDetector-大致工作流程"><a href="#ResourceLeakDetector-大致工作流程" class="headerlink" title="ResourceLeakDetector 大致工作流程"></a>ResourceLeakDetector 大致工作流程</h3><p><img src="/imgs/netty/ResourceLeakDetector-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="ResourceLeakDetector-工作流程"></p>
<h3 id="检测等级"><a href="#检测等级" class="headerlink" title="检测等级"></a>检测等级</h3><p>Netty 提供了 4 个检测等级, 不同的级别采样率不同, 开销也不一样, 用户可以根据实际情况选择合适的级别</p>
<table>
<thead>
<tr>
<th><strong>检测等级</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DISABLED</td>
<td>禁用检测</td>
</tr>
<tr>
<td>SIMPLE</td>
<td>简单检测, 少量的采样, 不报告泄漏的位置</td>
</tr>
<tr>
<td>ADVANCED</td>
<td>高级检测, 少量的采样, 会报告泄漏的位置</td>
</tr>
<tr>
<td>PARANOID</td>
<td>偏执检测, 100%采样, 会报告泄漏的位置</td>
</tr>
</tbody></table>
<p>通过设置 JVM 参数 <code>-Dio.netty.leakDetection.level=PARANOID</code> 来调整检测等级. ​</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>分析一下源码, 看看 Netty 是如何检测资源泄漏并及时报告用户的. 在看 ResourceLeakDetector 前, 先了解几个比较重要的类. ​</p>
<p>源码基于 netty 4.1.79.Final 版本分析</p>
<h4 id="DefaultResourceLeak"><a href="#DefaultResourceLeak" class="headerlink" title="DefaultResourceLeak"></a>DefaultResourceLeak</h4><p>DefaultResourceLeak 是默认的资源泄漏追踪器, 它继承自 <code>WeakReference</code>, 它会为追踪对象建立一个弱引用连接, 当追踪对象被 GC 回收后, JVM 会将 <code>WeakReference</code> 加入到 <code>refQueue</code>, 通过 <code>refQueue</code> 就能判断是否存在资源泄漏了.</p>
<p><img src="/imgs/netty/DefaultResourceLeak-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="DefaultResourceLeak-继承关系"></p>
<p>先看它的属性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 追踪记录的头节点, 单向链表.</span></span><br><span class="line"><span class="comment"> * 访问对象时, 会记录访问的堆栈信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> TraceRecord head;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> droppedRecords;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活跃的资源集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;DefaultResourceLeak&lt;?&gt;&gt; allLeaks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追踪对象的一致性哈希码, 确保关闭对象和追踪对象一致</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> trackedHash;</span><br></pre></td></tr></table></figure>

<p>再看构造函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> referent 引用本身, ByteBuf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> refQueue 弱引用队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allLeaks 活跃的资源集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialHint 自定义泄漏信息提示类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DefaultResourceLeak(</span><br><span class="line">        Object referent,</span><br><span class="line">        ReferenceQueue&lt;Object&gt; refQueue,</span><br><span class="line">        Set&lt;DefaultResourceLeak&lt;?&gt;&gt; allLeaks,</span><br><span class="line">        Object initialHint) &#123;</span><br><span class="line">    <span class="built_in">super</span>(referent, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> referent != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算追踪对象的一致性哈希, close时判断追踪对象和关闭对象是同一个</span></span><br><span class="line">    trackedHash = System.identityHashCode(referent);</span><br><span class="line">    <span class="comment">// 将当前DefaultResourceLeak加入到活跃资源集合中</span></span><br><span class="line">    allLeaks.add(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 记录追踪的堆栈信息, TraceRecord.BOTTOM代表链尾</span></span><br><span class="line">    headUpdater.set(<span class="built_in">this</span>, initialHint == <span class="literal">null</span> ?</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TraceRecord</span>(TraceRecord.BOTTOM) : <span class="keyword">new</span> <span class="title class_">TraceRecord</span>(TraceRecord.BOTTOM, initialHint));</span><br><span class="line">    <span class="built_in">this</span>.allLeaks = allLeaks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultResourceLeak 的创建过程还是比较简单的, 重要的是 TraceRecord 的创建, 它才是记录追踪堆栈的功能类. ​</p>
<h4 id="TraceRecord"><a href="#TraceRecord" class="headerlink" title="TraceRecord"></a>TraceRecord</h4><p>TraceRecord 记录着追踪对象访问的堆栈轨迹, 它继承自 <code>Throwable</code>, 这样它就可以通过调用 <code>Throwable.getStackTrace()</code> 获取堆栈跟踪的元素数组了.<br>​<br>TraceRecord 类本身不复杂, 重要的是它的 <code>toString()</code> 方法, 它会把追踪对象的访问堆栈信息给构建出来.</p>
<p>属性如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外的提示信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String hintString;</span><br><span class="line"><span class="comment">// 下一个节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TraceRecord next;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> pos;</span><br></pre></td></tr></table></figure>

<p>构造函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hint 额外的提示信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TraceRecord(TraceRecord next, Object hint) &#123;</span><br><span class="line">    <span class="comment">// This needs to be generated even if toString() is never called as it may change later on.</span></span><br><span class="line">    hintString = hint <span class="keyword">instanceof</span> ResourceLeakHint ? ((ResourceLeakHint) hint).toHintString() : hint.toString();</span><br><span class="line">    <span class="built_in">this</span>.next = next;</span><br><span class="line">    <span class="built_in">this</span>.pos = next.pos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toString()方法, 用来构建追踪对象的堆栈信息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建跟踪的堆栈信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">2048</span>);</span><br><span class="line">    <span class="keyword">if</span> (hintString != <span class="literal">null</span>) &#123;</span><br><span class="line">        buf.append(<span class="string">&quot;\tHint: &quot;</span>).append(hintString).append(NEWLINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取堆栈信息</span></span><br><span class="line">    StackTraceElement[] array = getStackTrace();</span><br><span class="line">    <span class="comment">// 跳过前三个元素, 前三个堆栈信息是ResourceLeakDetector相关, 报告出来无意义</span></span><br><span class="line">    out: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="type">StackTraceElement</span> <span class="variable">element</span> <span class="operator">=</span> array[i];</span><br><span class="line">        <span class="comment">// Strip the noisy stack trace elements.</span></span><br><span class="line">        String[] exclusions = excludedMethods.get();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; exclusions.length; k += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// Suppress a warning about out of bounds access</span></span><br><span class="line">            <span class="comment">// since the length of excludedMethods is always even, see addExclusions()</span></span><br><span class="line">            <span class="keyword">if</span> (exclusions[k].equals(element.getClassName())</span><br><span class="line">                    &amp;&amp; exclusions[k + <span class="number">1</span>].equals(element.getMethodName())) &#123; <span class="comment">// lgtm[java/index-out-of-bounds]</span></span><br><span class="line">                <span class="keyword">continue</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf.append(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">        buf.append(element.toString());</span><br><span class="line">        buf.append(NEWLINE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ResourceLeakDetector"><a href="#ResourceLeakDetector" class="headerlink" title="ResourceLeakDetector"></a>ResourceLeakDetector</h4><p>回到 ResourceLeakDetector, 以 <code>PooledByteBufAllocator.newDirectBuffer()</code> 申请池化的直接内存为例, 它创建完 ByteBuf 后不会立即返回, 它需要在 ByteBuf 发生泄漏时感知到, 因此需要对 ByteBuf 做一个包装.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ByteBuf <span class="title function_">newDirectBuffer</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> maxCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 申请一个池化的, 基于直接内存的ByteBuf, 这里的细节先不管</span></span><br><span class="line">    <span class="type">PoolThreadCache</span> <span class="variable">cache</span> <span class="operator">=</span> threadCache.get();</span><br><span class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="literal">null</span>) &#123;</span><br><span class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">                UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="built_in">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UnpooledDirectByteBuf</span>(<span class="built_in">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试感知Buf的资源泄漏</span></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toLeakAwareBuffer()</code> 会判断是简单检测还是高级检测, 返回不同的包装类, 这个包装类后面会说.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试感知Buf的资源泄漏</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> ByteBuf <span class="title function_">toLeakAwareBuffer</span><span class="params">(ByteBuf buf)</span> &#123;</span><br><span class="line">    ResourceLeakTracker&lt;ByteBuf&gt; leak;</span><br><span class="line">    <span class="comment">// 获取检测等级</span></span><br><span class="line">    <span class="keyword">switch</span> (ResourceLeakDetector.getLevel()) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIMPLE: <span class="comment">// 简单检测, 返回 SimpleLeakAwareByteBuf 包装类</span></span><br><span class="line">            leak = AbstractByteBuf.leakDetector.track(buf);</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将 ByteBuf 包装成 SimpleLeakAwareByteBuf</span></span><br><span class="line">                buf = <span class="keyword">new</span> <span class="title class_">SimpleLeakAwareByteBuf</span>(buf, leak);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADVANCED:</span><br><span class="line">        <span class="keyword">case</span> PARANOID: <span class="comment">// 高级检测, 返回 AdvancedLeakAwareByteBuf 包装类</span></span><br><span class="line">            leak = AbstractByteBuf.leakDetector.track(buf);</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将 ByteBuf 包装成 AdvancedLeakAwareByteBuf</span></span><br><span class="line">                buf = <span class="keyword">new</span> <span class="title class_">AdvancedLeakAwareByteBuf</span>(buf, leak);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 禁用检测, 不包装直接返回</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractByteBuf.leakDetector.track(buf)</code> 方法比较核心, 它会返回一个 buf 的泄漏追踪器, 当 buf 被正常释放时, 包装类会自动关闭追踪器, 反之资源泄漏时, 追踪器可以感知到, 并发出报告.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ResourceLeakTracker&lt;T&gt; <span class="title function_">track</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> track0(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个obj的泄漏追踪器</span></span><br><span class="line"><span class="comment">// 主要做了两件事: 创建追踪器、报告泄漏情况</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> DefaultResourceLeak <span class="title function_">track0</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取检测等级</span></span><br><span class="line">    <span class="type">Level</span> <span class="variable">level</span> <span class="operator">=</span> ResourceLeakDetector.level;</span><br><span class="line">    <span class="keyword">if</span> (level == Level.DISABLED) &#123;</span><br><span class="line">        <span class="comment">// 禁用检测</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于PARANOID等级, 需要判断是否采样</span></span><br><span class="line">    <span class="keyword">if</span> (level.ordinal() &lt; Level.PARANOID.ordinal()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((PlatformDependent.threadLocalRandom().nextInt(samplingInterval)) == <span class="number">0</span>) &#123;</span><br><span class="line">            reportLeak();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultResourceLeak</span>(obj, refQueue, allLeaks, getInitialHint(resourceType));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 报告泄漏</span></span><br><span class="line">    reportLeak();</span><br><span class="line">    <span class="comment">// 等级为PARANOID, 100%检测</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultResourceLeak</span>(obj, refQueue, allLeaks, getInitialHint(resourceType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了几个属性, 说明下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ByteBuf被检测后, 会创建一个弱引用指向它, GC时如果ByteBuf没有强引用被回收,</span></span><br><span class="line"><span class="comment">// ByteBuf被回收后, JVM会将WeakReference放入到refQueue中, 通过refQueue就可以判断是否发生内存泄漏.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; refQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经报告的泄漏对象集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; reportedLeaks =</span><br><span class="line">    Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Boolean&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 采样的间隔, 默认128</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> samplingInterval;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活跃的资源集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;DefaultResourceLeak&lt;?&gt;&gt; allLeaks =</span><br><span class="line">    Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;DefaultResourceLeak&lt;?&gt;, Boolean&gt;());</span><br></pre></td></tr></table></figure>

<p><code>reportLeak()</code> 的功能是报告资源的泄漏情况, 前面说过当追踪对象被 GC 回收掉后, JVM 会将 WeakReference 加入到 refQueue 中, 因此这里会遍历 refQueue, 取出泄漏对象后, 调用它的 <code>toString()</code> 来获取堆栈信息, <code>reportUntracedLeak()</code> 就很简单了, 只是通过 logger 进行输出.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报告泄漏情况</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportLeak</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!needReport()) &#123;</span><br><span class="line">        <span class="comment">// 不需要报告, 从refQueue中取出引用被clear掉</span></span><br><span class="line">        clearRefQueue();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历refQueue, 报告泄漏的情况</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">DefaultResourceLeak</span> <span class="variable">ref</span> <span class="operator">=</span> (DefaultResourceLeak) refQueue.poll();</span><br><span class="line">        <span class="comment">// 没有泄漏的对象了, 退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将自己清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (!ref.dispose()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泄漏的具体信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">records</span> <span class="operator">=</span> ref.getReportAndClearRecords();</span><br><span class="line">        <span class="comment">// 添加到已报告的对象集合中</span></span><br><span class="line">        <span class="keyword">if</span> (reportedLeaks.add(records)) &#123;</span><br><span class="line">            <span class="comment">// 调用logger.error()报告资源泄漏的情况</span></span><br><span class="line">            <span class="keyword">if</span> (records.isEmpty()) &#123;</span><br><span class="line">                reportUntracedLeak(resourceType);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reportTracedLeak(resourceType, records);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultResourceLeak.getReportAndClearRecords()</code> 调用了 <code>DefaultResourceLeak.generateReport()</code> 构建堆栈信息, 让用户感知到资源在哪里发生了泄漏. <code>generateReport()</code> 也比较简单, 就是对 TraceRecord 做遍历, 拼接方法调用的堆栈信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getReportAndClearRecords</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TraceRecord</span> <span class="variable">oldHead</span> <span class="operator">=</span> headUpdater.getAndSet(<span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> generateReport(oldHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateReport</span><span class="params">(TraceRecord oldHead)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldHead == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Already closed</span></span><br><span class="line">        <span class="keyword">return</span> EMPTY_STRING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">dropped</span> <span class="operator">=</span> droppedRecordsUpdater.get(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">duped</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">present</span> <span class="operator">=</span> oldHead.pos + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Guess about 2 kilobytes per stack trace</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(present * <span class="number">2048</span>).append(NEWLINE);</span><br><span class="line">    buf.append(<span class="string">&quot;Recent access records: &quot;</span>).append(NEWLINE);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    Set&lt;String&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;(present);</span><br><span class="line">    <span class="comment">// 遍历TraceRecord, 拼装堆栈信息</span></span><br><span class="line">    <span class="keyword">for</span> (; oldHead != TraceRecord.BOTTOM; oldHead = oldHead.next) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> oldHead.toString();</span><br><span class="line">        <span class="keyword">if</span> (seen.add(s)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldHead.next == TraceRecord.BOTTOM) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;Created at:&quot;</span>).append(NEWLINE).append(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27;#&#x27;</span>).append(i++).append(<span class="string">&#x27;:&#x27;</span>).append(NEWLINE).append(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            duped++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (duped &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf.append(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">                .append(duped)</span><br><span class="line">                .append(<span class="string">&quot; leak records were discarded because they were duplicates&quot;</span>)</span><br><span class="line">                .append(NEWLINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dropped &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf.append(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">            .append(dropped)</span><br><span class="line">            .append(<span class="string">&quot; leak records were discarded because the leak record count is targeted to &quot;</span>)</span><br><span class="line">            .append(TARGET_RECORDS)</span><br><span class="line">            .append(<span class="string">&quot;. Use system property &quot;</span>)</span><br><span class="line">            .append(PROP_TARGET_RECORDS)</span><br><span class="line">            .append(<span class="string">&quot; to increase the limit.&quot;</span>)</span><br><span class="line">            .append(NEWLINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf.setLength(buf.length() - NEWLINE.length());</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此, 创建资源泄漏追踪器和泄漏报告的流程就全部结束了.</p>
<h3 id="简单检测和高级检测"><a href="#简单检测和高级检测" class="headerlink" title="简单检测和高级检测"></a>简单检测和高级检测</h3><p>创建完 ResourceLeakTracker 资源泄漏追踪器后, Netty 还需要将 ByteBuf 进行包装, 这里用到了 <strong>装饰器模式</strong>, 装饰类的功能有两个:</p>
<ol>
<li>追踪对象被 release 后, 关闭追踪器.</li>
<li>追踪对象被访问后, 记录堆栈.</li>
</ol>
<p>对于第二个功能点, 只有高级检测才需要, 因此 Netty 提供了两个包装类: SimpleLeakAwareByteBuf 和 AdvancedLeakAwareByteBuf, 简单检测和高级检测.</p>
<p>它俩的区别就是简单检测不会记录追踪对象访问的堆栈信息, 只会单纯的报告发生了泄漏, 这样的好处是开销较小, 坏处是无法确定泄漏的位置.</p>
<p><img src="/imgs/netty/LeakAwareByteBuf-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="LeakAwareByteBuf-继承关系"></p>
<p>装饰类需要依赖一个原生的 ByteBuf, 所有的操作都委托给 ByteBuf 去执行, 它会在需要增强的方法前后插入一些扩展功能. ​</p>
<p>以增强后的 <code>release()</code> 方法示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleLeakAwareByteBuf 中的 release 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果对象成功释放 则关闭追踪器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">super</span>.release()) &#123;</span><br><span class="line">        closeLeak();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AdvancedLeakAwareByteBuf 中的 release 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录访问的堆栈信息, 大量的方法调用都需要记录堆栈</span></span><br><span class="line">    leak.record();</span><br><span class="line">    <span class="comment">// 调用 SimpleLeakAwareByteBuf 中的 release 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>closeLeak()</code> 会调用 <code>DefaultResourceLeak.close()</code> 关闭追踪:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleLeakAwareByteBuf 中的 closeLeak 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeLeak</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Close the ResourceLeakTracker with the tracked ByteBuf as argument. This must be the same that was used when</span></span><br><span class="line">    <span class="comment">// calling DefaultResourceLeak.track(...).</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">closed</span> <span class="operator">=</span> leak.close(trackedByteBuf);</span><br><span class="line">    <span class="keyword">assert</span> closed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultResourceLeak 中的 close 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">close</span><span class="params">(T trackedObject)</span> &#123;</span><br><span class="line">    <span class="comment">// Ensure that the object that was tracked is the same as the one that was passed to close(...).</span></span><br><span class="line">    <span class="keyword">assert</span> trackedHash == System.identityHashCode(trackedObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> close();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// This method will do `synchronized(trackedObject)` and we should be sure this will not cause deadlock.</span></span><br><span class="line">        <span class="comment">// It should not, because somewhere up the callstack should be a (successful) `trackedObject.release`,</span></span><br><span class="line">        <span class="comment">// therefore it is unreasonable that anyone else, anywhere, is holding a lock on the trackedObject.</span></span><br><span class="line">        <span class="comment">// (Unreasonable but possible, unfortunately.)</span></span><br><span class="line">        reachabilityFence0(trackedObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭追踪</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从活跃资源集合中移除自己</span></span><br><span class="line">    <span class="keyword">if</span> (allLeaks.remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="comment">// 清除弱引用</span></span><br><span class="line">        <span class="comment">// Call clear so the reference is not even enqueued.</span></span><br><span class="line">        clear();</span><br><span class="line">        <span class="comment">// 清空TraceRecord</span></span><br><span class="line">        headUpdater.set(<span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leak.record()</code> 会调用 <code>DefaultResourceLeak.record0()</code> 方法记录堆栈信息, 创建一个 TraceRecord 加入到追踪记录的链表中</p>
<h3 id="泄漏总结"><a href="#泄漏总结" class="headerlink" title="泄漏总结"></a>泄漏总结</h3><p>Netty 根据 WeakReference 弱引用来判断对象是否发生内存泄漏, 通过创建一个追踪对象的装饰类来进行增强, 当追踪对象被 release 后, 自动关闭追踪器, 否则在发生泄漏时进行报告.<br>​<br>如果开启了资源泄漏检测, Netty 会为追踪对象创建一个泄漏追踪器 ResourceLeakTracker, ResourceLeakTracker 包含一个单向链表, 链表由一系列 TraceRecord 组成, 它代表的是对象访问的堆栈记录, 如果发生了资源泄漏, Netty 会根据这个链表构建资源泄漏的位置信息并写入日志.<br>​<br>Netty 提供了两种检测机制, 分别是简单的和高级的, 对于高级检测, Netty 还会记录追踪对象的访问堆栈信息, 在报告时可以快速定位到资源泄漏的具体位置, 缺点是这会带来较大的额外开销, 不建议在线上使用.</p>
<h2 id="jemalloc-基本原理"><a href="#jemalloc-基本原理" class="headerlink" title="jemalloc 基本原理"></a>jemalloc 基本原理</h2><p>jemalloc 是由 Jason Evans 在 FreeBSD 项目中引入的新一代内存分配器. 它是一个通用的 malloc 实现, 侧重于减少内存碎片和提升高并发场景下内存的分配效率, 其目标是能够替代 malloc. jemalloc 应用十分广泛, 在 Firefox、Redis、Rust、Netty 等出名的产品或者编程语言中都有大量使用. 具体细节可以参考 Jason Evans 发表的论文 <a target="_blank" rel="noopener" href="https://www.bsdcan.org/2006/papers/jemalloc.pdf">《A Scalable Concurrent malloc Implementation for FreeBSD》</a></p>
<h3 id="内存分配器目标-memory-allocator"><a href="#内存分配器目标-memory-allocator" class="headerlink" title="内存分配器目标(memory allocator)"></a>内存分配器目标(memory allocator)</h3><ol>
<li>减少内存碎片, 包括内部碎片和外部碎片</li>
<li>提高性能</li>
<li>提高安全性</li>
</ol>
<h3 id="jemalloc-ptmalloc-tcmalloc-对比"><a href="#jemalloc-ptmalloc-tcmalloc-对比" class="headerlink" title="jemalloc, ptmalloc, tcmalloc 对比"></a>jemalloc, ptmalloc, tcmalloc 对比</h3><ul>
<li>ptmalloc 是基于 glibc 实现的内存分配器, 它是一个标准实现, 所以兼容性较好. pt 表示 per thread 的意思. 当然 ptmalloc 确实在多线程的性能优化上下了很多功夫. 由于过于考虑性能问题, 多线程之间内存无法实现共享, 只能每个线程都独立使用各自的内存, 所以在内存开销上是有很大浪费的.</li>
<li>tcmalloc 出身于 Google, 全称是 thread-caching malloc, 所以 tcmalloc 最大的特点是带有线程缓存, tcmalloc 非常出名, 目前在 Chrome、Safari 等知名产品中都有所应有. tcmalloc 为每个线程分配了一个局部缓存, 对于小对象的分配, 可以直接由线程局部缓存来完成, 对于大对象的分配场景, tcmalloc 尝试采用自旋锁来减少多线程的锁竞争问题.</li>
<li>jemalloc 借鉴了 tcmalloc 优秀的设计思路, 所以在架构设计方面两者有很多相似之处, 同样都包含 thread cache 的特性. 但是 jemalloc 在设计上比 ptmalloc 和 tcmalloc 都要复杂, jemalloc 将内存分配粒度划分为 Small、Large、Huge 三个分类, 并记录了很多 meta 数据, 所以在空间占用上要略多于 tcmalloc, 不过在大内存分配的场景, jemalloc 的内存碎片要少于 tcmalloc. jemalloc 内部采用红黑树管理内存块和分页, Huge 对象通过红黑树查找索引数据可以控制在指数级时间.</li>
</ul>
<p>虽然几个内存分配器的侧重点不同, 但是它们的核心目标是一致的:</p>
<ul>
<li>高效的内存分配和回收, 提升单线程或者多线程场景下的性能.</li>
<li>减少内存碎片, 包括内部碎片和外部碎片, 提高内存的有效利用率.</li>
</ul>
<blockquote>
<p>内存碎片: Linux 中物理内存会被划分成若干个 4K 大小的内存页 Page, 物理内存的分配和回收都是基于 Page 完成的, Page 内产生的内存碎片称为内部碎片, Page 之间产生的内存碎片称为外部碎片.</p>
</blockquote>
<h3 id="常用内存分配器算法"><a href="#常用内存分配器算法" class="headerlink" title="常用内存分配器算法"></a>常用内存分配器算法</h3><p>最常用的内存分配器算法有:</p>
<ul>
<li>动态内存分配</li>
<li>伙伴算法</li>
<li>Slab 算法</li>
</ul>
<h4 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h4><p>动态内存分配 (Dynamic memory allocation, 简称 DMA) 又称为堆内存分配, 操作系统根据程序运行过程中的需求即时分配内存, 且分配的内存大小就是程序需求的大小. 在大部分场景下, 只有在程序运行的时候才知道所需要分配的内存大小, 如果提前分配可能会分配的大小无法把控, 分配太大会浪费空间, 分配太小会无法使用.</p>
<p>DMA 是从一整块内存中按需分配, 对于分配出的内存会记录元数据, 同时还会使用空闲分区链维护空闲内存, 便于在内存分配时查找可用的空闲分区, 常用的有三种查找策略:</p>
<ol>
<li>⾸次适应算法 (first fit)</li>
<li>循环首次适应算法 (next fit)</li>
<li>最佳适应算法 (best fit)</li>
</ol>
<h5 id="⾸次适应算法-first-fit"><a href="#⾸次适应算法-first-fit" class="headerlink" title="⾸次适应算法 (first fit)"></a>⾸次适应算法 (first fit)</h5><p>空闲分区链以地址递增的顺序将空闲分区以双向链表的形式连接在一起, 从空闲分区链中找到第一个满足分配条件的空闲分区, 然后从空闲分区中划分出一块可用内存给请求进程, 剩余的空闲分区仍然保留在空闲分区链中.</p>
<p>如下图所示, P1 和 P2 的请求可以在内存块 A 中完成分配.</p>
<p>但是该算法每次都从低地址开始查找, 造成低地址部分会不断被分配, 同时也会产生很多小的空闲分区.</p>
<p><img src="/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-DMA-%E2%BE%B8%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="netty-内存分配器-DMA-循环首次适应算法"></p>
<h5 id="循环首次适应算法-next-fit"><a href="#循环首次适应算法-next-fit" class="headerlink" title="循环首次适应算法 (next fit)"></a>循环首次适应算法 (next fit)</h5><p>该算法是由首次适应算法的变种, 循环首次适应算法不再是每次从链表的开始进行查找, 而是从上次找到的空闲分区的下⼀个空闲分区开始查找.</p>
<p>如下图所示, P1 请求在内存块 A 完成分配, 然后再为 P2 分配内存时, 是直接继续向下寻找可用分区, 最终在 B 内存块中完成分配.</p>
<p>该算法相比⾸次适应算法空闲分区的分布更加均匀, 而且查找的效率有所提升, 但是正因为如此会造成空闲分区链中大的空闲分区会越来越少.</p>
<p><img src="/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-DMA-%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="netty-内存分配器-DMA-循环首次适应算法"></p>
<h5 id="最佳适应算法-best-fit"><a href="#最佳适应算法-best-fit" class="headerlink" title="最佳适应算法 (best fit)"></a>最佳适应算法 (best fit)</h5><p>空闲分区链以空闲分区大小递增的顺序将空闲分区以双向链表的形式连接在一起, 每次从空闲分区链的开头进行查找, 这样第一个满足分配条件的空间分区就是最优解.</p>
<p>如下图所示, 在 A 内存块分配完 P1 请求后, 空闲分区链重新按分区大小进行排序, 再为 P2 请求查找满足条件的空闲分区.</p>
<p>该算法的空间利用率更高, 但同样也会留下很多较难利用的小空闲分区, 由于每次分配完需要重新排序, 所以会有造成性能损耗.</p>
<p><img src="/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-DMA-%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="netty-内存分配器-DMA-最佳适应算法"></p>
<h4 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h4><p>伙伴算法是一种非常经典的内存分配算法, 它采用了分离适配的设计思想, 将物理内存按照 2 的次幂进行划分, 内存分配时也是按照 2 的次幂大小进行按需分配, 例如 4KB、 8KB、16KB 等. 假设我们请求分配的内存大小为 10KB, 那么会按照 16KB 分配.</p>
<p><img src="/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95.png" alt="netty-内存分配器-伙伴算法"></p>
<p>伙伴算法把内存划分为 11 组不同的 2 次幂大小的内存块集合, 每组内存块集合都用双向链表连接. 链表中每个节点的内存块大小分别为 1、2、4、8、16、32、64、128、256、512 和 1024 个连续的 Page (每个 Page 4KB), 例如第一组链表的节点为 2^0 个连续 Page, 第二组链表的节点为 2^1 个连续 Page, 以此类推.</p>
<p>假设我们需要分配 10K 大小的内存块, 看下伙伴算法的具体分配过程:</p>
<ol>
<li>首先需要找到存储 2^4 连续 Page 所对应的链表, 即数组下标为 4;</li>
<li>查找 2^4 链表中是否有空闲的内存块, 如果有则分配成功;</li>
<li>如果 2^4 链表不存在空闲的内存块, 则继续沿数组向上查找, 即定位到数组下标为 5 的链表, 链表中每个节点存储 2^5 的连续 Page;</li>
<li>如果 2^5 链表中存在空闲的内存块, 则取出该内存块并将它分割为 2 个 2^4 大小的内存块, 其中一块分配给进程使用, 剩余的一块链接到 2^4 链表中.</li>
</ol>
<p>释放内存时候伙伴算法又会发生什么行为呢?</p>
<ol>
<li>当进程使用完内存归还时, 需要检查其伙伴块的内存是否释放, 所谓伙伴块是不仅大小相同, 而且两个块的地址是连续的, 其中低地址的内存块起始地址必须为 2 的整数次幂.</li>
<li>如果伙伴块是空闲的, 那么就会将两个内存块合并成更大的块, 然后重复执行上述伙伴块的检查机制.</li>
<li>直至伙伴块是非空闲状态, 那么就会将该内存块按照实际大小归还到对应的链表中.</li>
</ol>
<p>频繁的合并会造成 CPU 浪费, 所以并不是每次释放都会触发合并操作, 当链表中的内存块个数小于某个阈值时, 并不会触发合并操作.</p>
<p>由此可见, 伙伴算法有效地减少了外部碎片, 但是有可能会造成非常严重的内部碎片, 最严重的情况会带来 50% 的内存碎片.</p>
<h4 id="Slab-算法"><a href="#Slab-算法" class="headerlink" title="Slab 算法"></a>Slab 算法</h4><p>因为伙伴算法都是以 Page 为最小管理单位, 在小内存的分配场景, 伙伴算法并不适用, 如果每次都分配一个 Page 岂不是非常浪费内存, 因此 Slab 算法应运而生了. Slab 算法在伙伴算法的基础上, 对小内存的场景专门做了优化, 采用了内存池的方案, 解决内部碎片问题.</p>
<p>Linux 内核使用的就是 Slab 算法, 因为内核需要频繁地分配小内存, 所以 Slab 算法提供了一种高速缓存机制, 使用缓存存储内核对象, 当内核需要分配内存时, 基本上可以通过缓存中获取. 此外 Slab 算法还可以支持通用对象的初始化操作, 避免对象重复初始化的开销. 下图是 Slab 算法的结构图, Slab 算法实现起来非常复杂, 本文只做一个简单的了解.</p>
<p><img src="/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-slab%E7%AE%97%E6%B3%95.png" alt="netty-内存分配器-slab算法"></p>
<p>在 Slab 算法中维护着大小不同的 Slab 集合, 在最顶层是 cache_chain, cache_chain 中维护着一组 kmem_cache 引用, kmem_cache 负责管理一块固定大小的对象池. 通常会提前分配一块内存, 然后将这块内存划分为大小相同的 slot, 不会对内存块再进行合并, 同时使用位图 bitmap 记录每个 slot 的使用情况.</p>
<p>kmem_cache 中包含三个 Slab 链表: 完全分配使用 slab_full、部分分配使用 slab_partial 和完全空闲 slabs_empty, 这三个链表负责内存的分配和释放. 每个链表中维护的 Slab 都是一个或多个连续 Page, 每个 Slab 被分配多个对象进行存储. Slab 算法是基于对象进行内存管理的, 它把相同类型的对象分为一类. 当分配内存时, 从 Slab 链表中划分相应的内存单元; 当释放内存时, Slab 算法并不会丢弃已经分配的对象, 而是将它保存在缓存中, 当下次再为对象分配内存时, 直接会使用最近释放的内存块.</p>
<p>单个 Slab 可以在不同的链表之间移动, 例如当一个 Slab 被分配完, 就会从 slab_partial 移动到 slabs_full, 当一个 Slab 中有对象被释放后, 就会从 slab_full 再次回到 slab_partial, 所有对象都被释放完的话, 就会从 slab_partial 移动到 slab_empty.</p>
<p>至此, 三种最常用的内存分配算法已经介绍完了, 优秀的内存分配算法都是在性能和内存利用率之间寻找平衡点, jemalloc 就是非常典型的例子.</p>
<h3 id="jemalloc-架构设计"><a href="#jemalloc-架构设计" class="headerlink" title="jemalloc 架构设计"></a>jemalloc 架构设计</h3><p>jemalloc 有五个重要的数据结构: arena, bin, chunk, run, tcache</p>
<p>这五个数据结构可以分为三类:</p>
<ul>
<li>物理布局相关: chunk, run</li>
<li>核心管理相关: arena, bin</li>
<li>线程本地缓存: tcache</li>
</ul>
<p>5 个数据结构含义:</p>
<ol>
<li>chunk: 负责管理用户内存块的数据结构</li>
</ol>
<ul>
<li>chunk 以 Page 为单位管理内存, 默认大小是 4M, 即 1024 个连续 Page</li>
<li>jemalloc 向操作系统获取内存是以 chunk 为单位的</li>
<li>每个 chunk 可被用于多次小内存的申请, 但是在大内存分配的场景下只能分配一次</li>
</ul>
<ol>
<li>run: 是 chunk 中的一块内存区域, jemalloc 从操作系统获取一个 chunk 的内存后, 会将 chunk 切分成 run 进行管理</li>
</ol>
<ul>
<li>每个 bin 管理相同类型的 run, 最终通过操作 run 完成内存分配</li>
<li>run 结构具体的大小由不同的 bin 决定, 例如 8 字节的 bin 对应的 run 只有一个 Page, 可以从中选取 8 字节的块进行分配</li>
</ul>
<ol>
<li>arena: jemalloc 的核心管理器, 多线程环境下默认数量为处理器核数 4 倍</li>
</ol>
<ul>
<li>arena 管理着 jemalloc 的 chunk, 包括释放掉的 chunk 以及正在使用的 chunk, 对于正在使用的 chunk, arena 会将其切分成 run 进行管理</li>
</ul>
<ol>
<li>bin: jemalloc 核心管理器的子管理器, 即 arena 的次级管理器</li>
</ol>
<ul>
<li>负责 small bin 的分配, 从 arena 申请 run, 并将 run 划分成 region 进行实际的 small 分配</li>
<li>每个 bin 管理的内存大小是按分类依次递增. 因为 jemalloc 中小内存的分配是基于 Slab 算法完成的, 所以会产生不同类别的内存块</li>
</ul>
<ol>
<li>tcache: 从属于某个线程的缓存分配器, 是每个线程私有的缓存<ol>
<li>tcache 按照策略从 arena&#x2F;bin 中获取一定数量 的 <code>small bin</code> 及 <code>部分 large</code> 放在本地缓存, 线程的大部分申请都是从 tcache 中获取, 大部分释放都是放回 tcache, tcache 也会按照某种策略将部分缓存放回 arena&#x2F;bin</li>
</ol>
</li>
</ol>
<p>jemalloc 架构图:</p>
<p><img src="/imgs/netty/netty-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-jemalloc-%E6%9E%B6%E6%9E%84.png" alt="netty-内存分配器-jemalloc-架构"></p>
<p>上图体现了 jemalloc 中的一些重要数据结构和重要工作流程:</p>
<ul>
<li>每个线程会和 2 个 arena 绑定(为了方便, 图中画了一个), 一个用于 application 内存分配, 一个用于 internal 内存分配, 不过目前 internal 数据 主要分配在 base 和 arena 0 中, 并没有用到 internal 绑定的 arena</li>
<li>每个 arena 会被多个线程使用, 这个取决于线程的数量和 CPU 核数</li>
<li>每个线程有一个自己的 tcache, tcache 中会缓存所有类型的 small bin 和 少数几类 large, 其并不是真的缓存, 而是保存指向内存的指针, 被缓存的内存会在 run 或者 chunk 中标记为已经分配</li>
<li>线程申请属于 tcache 范围内的内存时, 首先从 tcache 中获取, 如果 tcache 中有, 则直接获取, 没有的话, 如果是 small, 则 tcache 从 arena 中获取内存来填充, 再分配 给线程, 如果是 large, 则 线程 重新向 arena 申请</li>
<li>tcache 会根据策略, 选择时机向 arena 释放内存(flush), 或者从 arena 获取内存填充 bin (fill)</li>
<li>线程申请不属于 tcache 的 large 时, 或者申请 huge 时, 直接向 arena 申请</li>
<li>arena 使用红黑树管理脏的 chunk&#x2F;huge (被释放的 chunk&#x2F;huge), 实际 arena 使用多棵 红黑树管理被释放的 chunk&#x2F;huge, 用于不同的用途, 这里只画了一颗</li>
<li>arena 对可用的 runs 进行分组管理, 每一组使用 堆 维护</li>
<li>arena 中对多组 bin 管理, bin 内部使用 堆 对自己的 run 管理</li>
<li>arena 中的 achunks 使用 链表 维护正在使用的 chunk</li>
</ul>
<h1 id="netty-线程模型"><a href="#netty-线程模型" class="headerlink" title="netty 线程模型"></a>netty 线程模型</h1><h2 id="Java-NIO-新连接处理流程"><a href="#Java-NIO-新连接处理流程" class="headerlink" title="Java NIO 新连接处理流程"></a>Java NIO 新连接处理流程</h2><ol>
<li>通过 I&#x2F;O 多路复用器——Selector 检测客户端新连接<br>对应到 Netty, 新连接通过服务端的 NioServerSocketChannel (底层封装的 JDK 的 ServerSocketChannel) 绑定的 I&#x2F;O 多路复用器 (由 NioEventLoop 线程驱动) 轮询 OP_ACCEPT(&#x3D;16)事件</li>
<li>轮询到新连接, 就创建客户端的 Channel<br>对应到 Netty 就是 NioSocketChannel (底层封装 JDK 的 SocketChannel)</li>
<li>为新连接分配绑定新的 Selector<br>对应到 Netty, 就是通过线程选择器, 从它的第二个线程池——worker 线程池中挑选一个 NIO 线, 在这个线程中去执行将 JDK 的 SocketChannel 注册到新的 Selector 的流程, 将 Netty 封装的 NioSocketChannel 作为附加对象也绑定到该 Selector</li>
<li>向客户端 Channel 绑定的 Selector 注册 I&#x2F;O 读、或者写事件<br>对应到 Netty, 就是默认注册读事件, 因为 Netty 的设计理念是读优先. 以后本条 Channel 的读写事件就由 worker 线程池中的 NIO 线程管理</li>
</ol>
<p>Netty 服务端创建的 boss 和 worker 就是两个线程池, 对于一个服务器的端口, bossGroup 里只会启动一个 NIO 线程用来处理该端口上的客户端新连接的检测和接入流程</p>
<p>NioEventLoopGroup 和线程池对应, NioEventLoop 实例和 NIO 线程对应, 一个 EventLoop 实例将由一个永远都不会改变的 Thread 驱动其内部的 run 方法 (和 Runnable 的 run 不是一个)</p>
<h2 id="netty-reactor-架构"><a href="#netty-reactor-架构" class="headerlink" title="netty reactor 架构"></a>netty reactor 架构</h2><p>根据 Reactor 的数量和处理资源池线程的数量不同, 有 3 种典型的实现:</p>
<ol>
<li>单 Reactor 单线程</li>
<li>单 Reactor 多线程</li>
<li>主从 Reactor 多线程</li>
</ol>
<p>Netty 主要基于 <font color=red>主从 Reactor</font> 多线程模型做了一定的 <font color=red>改进</font>, 其中主从 Reactor 多线程模型 <font color=red face="微软雅黑">有多个 Reactor</font></p>
<h3 id="reactor-设计思想"><a href="#reactor-设计思想" class="headerlink" title="reactor 设计思想"></a>reactor 设计思想</h3><p>I&#x2F;O 复用结合线程池, 就是 Reactor 模式基本设计思想</p>
<blockquote>
<p>基于 I&#x2F;O 复用模型: 多个连接共用一个阻塞对象, 应用程序只需要在一个阻塞对象等待, 无需阻塞等待所有连接. 当某个连接有新的数据可以处理时, 操作系统通知应用程序, 线程从阻塞状态返回, 开始进行业务处理<br>基于线程池复用线程资源: 不必再为每个连接创建线程, 将连接完成后的业务处理任务分配给线程进行处理, 一个线程可以处理多个连接的业务.</p>
</blockquote>
<p>Reactor 对应的叫法:</p>
<ul>
<li>反应器模式</li>
<li>分发者模式 (Dispatcher)</li>
<li>通知者模式 (notifier)</li>
</ul>
<p>reactor 处理流程:</p>
<ol>
<li>一个或多个请求, 同时传递给 <strong>服务处理器(基于事件驱动)</strong>;</li>
<li>服务器端程序处理传入的多个请求, 并将它们同步分派到相应的处理线程, 因此 Reactor 模式也叫 Dispatcher 模式;</li>
<li>Reactor 模式使用 <strong>IO 复用</strong> 监听事件, 收到事件后, 分发给某个线程(进程), <strong>这点就是网络服务器高并发处理关键</strong>.</li>
</ol>
<p><img src="/imgs/netty/netty-thread-reactor-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="netty-thread-reactor-请求处理流程"></p>
<h3 id="reactor-核心组成"><a href="#reactor-核心组成" class="headerlink" title="reactor 核心组成"></a>reactor 核心组成</h3><ul>
<li>Reactor: 负责监听和分配事件, 将 I&#x2F;O 事件分派给对应的 Handler. 新的事件包含连接建立就绪、读就绪、写就绪等</li>
<li>Acceptor: 处理客户端新连接, 并分派请求到处理器链中</li>
<li>Handler: 将自身与事件绑定, 执行非阻塞读&#x2F;写任务, 完成 channel 的读入, 完成处理业务逻辑后, 负责将结果写出 channel. 可用资源池来管理</li>
</ul>
<h3 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h3><p><img src="/imgs/netty/netty-thread-reactor-%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png" alt="netty-thread-reactor-单Reactor单线程"></p>
<ol>
<li>Select 是前面 I&#x2F;O 复用模型介绍的标准网络编程 API, 可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li>Reactor 对象通过 Select 监控客户端请求事件, 收到事件后通过 Dispatch 进行分发</li>
<li>如果是建立连接请求事件, 则由 Acceptor 通过 Accept 处理连接请求, 然后创建一个 Handler 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件, 则 Reactor 会分发调用连接对应的 Handler 来响应</li>
<li>Handler 会完成 Read &#x3D;&#x3D;》 业务处理 &#x3D;&#x3D;》Send 的完整业务流程</li>
</ol>
<p>单 Reactor 单线程模型只是在代码上进行了组件的区分, 但是整体操作还是单线程, 不能充分利用硬件资源. handler 业务处理部分没有异步</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>服务器端用 <strong>一个线程</strong> 通过 <strong>多路复用</strong> 搞定所有的 IO 操作 (包括连接, 读、写等) , 编码简单, 清晰明了, 但是如果客户端连接数量较多, 将无法支撑</p>
<p><strong>优点</strong></p>
<ul>
<li>模型简单, 没有多线程、进程通信、竞争的问题, 全部都在一个线程中完成</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>性能问题, 只有一个线程, 无法完全发挥多核 CPU 的性能. Handler 在处理某个连接上的业务时, 整个进程无法处理其他连接事件, 很容易导致性能瓶颈</li>
<li>可靠性问题, 线程意外终止, 或者进入死循环, 会导致整个系统通信模块不可用, 不能接收和处理外部消息, 造成节点故障</li>
</ul>
<h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h3><p><img src="/imgs/netty/netty-thread-reactor-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="netty-thread-reactor-单Reactor多线程"></p>
<ol>
<li>Reactor 对象通过 select 监控客户端请求事件, 收到事件后, 通过 dispatch 进行分发</li>
<li>如果建立连接请求, 则由 Acceptor 通过 accept 处理连接请求, 然后创建一个 Handler 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求, 则由 reactor 分发调用连接对应的 handler 来处理</li>
<li><strong>handler 只负责响应事件</strong>, 不做具体的业务处理, 通过 read 读取数据后, 会分发给后面的 worker 线程池的某个线程处理业务</li>
<li><strong>worker 线程池</strong> 会分配独立线程完成真正的业务, 并将结果返回给 handler</li>
<li>handler 收到响应后, 通过 send 将结果返回给 client</li>
</ol>
<p>该模型在事件处理器 (Handler) 部分采用了多线程 (线程池)</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<ul>
<li>可以充分的利用多核 cpu 的处理能力</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>多线程数据共享和访问比较复杂, reactor 处理所有的事件的监听和响应, 在单线程运行, 在高并发场景容易出现性能瓶颈</li>
</ul>
<h3 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h3><p><img src="/imgs/netty/netty-thread-reactor-%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="netty-thread-reactor-主从Reactor多线程"></p>
<p>针对单 Reactor 多线程模型中, Reactor 在单线程中运行, 高并发场景下容易成为性能瓶颈, 可以让 Reactor 在多线程中运行</p>
<ul>
<li>Reactor 主线程 MainReactor 对象通过 select 监听连接事件, 收到事件后, 通过 Acceptor 处理连接事件</li>
<li>当 Acceptor 处理连接事件后, MainReactor 将连接分配给 SubReactor</li>
<li>SubReactor 将连接加入到连接队列进行监听, 并创建 handler 进行各种事件处理</li>
<li>当有新事件发生时, subreactor 就会调用对应的 handler 处理</li>
<li>handler 通过 read 读取数据, 分发给后面的 worker 线程处理</li>
<li>worker 线程池分配独立的 worker 线程进行业务处理, 并返回结果</li>
</ul>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>这种模型在许多项目中广泛使用, 包括 Nginx 主从 Reactor 多进程模型, Memcached 主从多线程, Netty 主从多线程模型的支持</p>
<p><strong>优点</strong></p>
<ul>
<li>父线程与子线程的数据交互简单职责明确, 父线程只需要接收新连接, 子线程完成后续的业务处理.</li>
<li>父线程与子线程的数据交互简单, Reactor 主线程只需要把新连接传给子线程, 子线程无需返回数据.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>编程复杂度较高</li>
</ul>
<h3 id="netty-改进-reactor"><a href="#netty-改进-reactor" class="headerlink" title="netty 改进 reactor"></a>netty 改进 reactor</h3><p>Netty 主要基于 <font color=red>主从 Reactor</font> 多线程模型做了一定的 <font color=red>改进</font>, 其中主从 Reactor 多线程模型 <font color=red face="微软雅黑">有多个 Reactor</font></p>
<h4 id="简要概述"><a href="#简要概述" class="headerlink" title="简要概述"></a>简要概述</h4><p><img src="/imgs/netty/netty-thread-reactor-netty%E6%94%B9%E8%BF%9B.png" alt="netty-thread-reactor-netty改进"></p>
<ol>
<li>BossGroup 线程维护 Selector, 只关注 Accecpt;</li>
<li>当接收到 Accept 事件, 获取到对应的 SocketChannel, 封装成 NIOScoketChannel 并注册到 Worker 线程(事件循环), 并进行维护;</li>
<li>当 Worker 线程监听到 selector 中通道发生自己感兴趣的事件后, 就进行处理(就由 handler), 注意 handler 已经加入到通道</li>
</ol>
<h4 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h4><p><img src="/imgs/netty/netty-thread-reactor-netty%E6%94%B9%E8%BF%9B2.png" alt="netty-thread-reactor-netty改进2"></p>
<ol>
<li>Netty 抽象出两组线程池: <strong>BossGroup 和 WorkerGroup</strong><ul>
<li>BossGroup 专门负责接收客户端的连接</li>
<li>WorkerGroup 专门负责网络的读写</li>
</ul>
</li>
<li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup, NioEventLoopGroup 相当于一个 <strong>事件循环组</strong>, 这个组中 <strong>含有多个事件循环</strong> , 每一个事件循环是 NioEventLoop</li>
<li>NioEventLoop 表示一个不断循环的执行处理任务的线程, 每个 NioEventLoop 都有一个 selector, 用于监听绑定在其上的 socket 的网络通讯</li>
<li>NioEventLoopGroup 可以有多个线程, 即可以含有多个 NioEventLoop</li>
<li>每个 Boss Group 中的 NioEventLoop 循环执行的步骤:<ol>
<li>轮询 accept 事件</li>
<li>处理 accept 事件, 与 client 建立连接, 生成 NioScocketChannel, 并将其注册 Worker Group 上的某个 NIOEventLoop 上的 selector</li>
<li>处理任务队列的任务, 即 runAllTasks</li>
</ol>
</li>
<li>每个 Worker Group 中的 NioEventLoop 循环执行的步骤:<ol>
<li>轮询 read&#x2F;write 事件</li>
<li>处理 I&#x2F;O 事件, 即 read&#x2F;write 事件, 在对应的 NioScocketChannel 上处理</li>
<li>处理任务队列的任务, 即 runAllTasks</li>
</ol>
</li>
<li>每个 Worker NIOEventLoop 处理业务时, 会使用 pipeline(管道). pipline 中包含了 channel, 即通过 pipline 可以获取到对应的 channel, 并且 pipline 维护了很多的 handler(处理器)来对我们的数据进行一系列的处理</li>
<li>handler(处理器) 可以用 Netty 内置的, 也可以自己定义</li>
</ol>
<h2 id="netty-的-FastThreadLocal"><a href="#netty-的-FastThreadLocal" class="headerlink" title="netty 的 FastThreadLocal"></a>netty 的 FastThreadLocal</h2><h3 id="JDK-ThreadLocal-基本原理"><a href="#JDK-ThreadLocal-基本原理" class="headerlink" title="JDK ThreadLocal 基本原理"></a>JDK ThreadLocal 基本原理</h3><p>ThreadLocal 可以理解为线程本地变量, 它是 Java 并发编程中非常重要的一个类. ThreadLocal 为变量在每个线程中都创建了一个副本, 该副本只能被当前线程访问, 多线程之间是隔离的, 变量不能在多线程之间共享. 这样每个线程修改变量副本时, 不会对其他线程产生影响.</p>
<p>接下来我们通过一个例子看下 ThreadLocal 如何使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_NAME_LOCAL = ThreadLocal.withInitial(() -&gt; Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TradeOrder&gt; TRADE_THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tradeId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">TradeOrder</span> <span class="variable">tradeOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TradeOrder</span>(tradeId, tradeId % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;已支付&quot;</span> : <span class="string">&quot;未支付&quot;</span>);</span><br><span class="line">                TRADE_THREAD_LOCAL.set(tradeOrder);</span><br><span class="line">                System.out.println(<span class="string">&quot;threadName: &quot;</span> + THREAD_NAME_LOCAL.get());</span><br><span class="line">                System.out.println(<span class="string">&quot;tradeOrder info: &quot;</span> + TRADE_THREAD_LOCAL.get());</span><br><span class="line">            &#125;, <span class="string">&quot;thread-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TradeOrder</span> &#123;</span><br><span class="line">        <span class="type">long</span> id;</span><br><span class="line">        String status;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TradeOrder</span><span class="params">(<span class="type">int</span> id, String status)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.status = status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, status=&quot;</span> + status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中, 构造了 THREAD_NAME_LOCAL 和 TRADE_THREAD_LOCAL 两个 ThreadLocal 变量, 分别用于记录当前线程名称和订单交易信息.</p>
<p>通过 set()&#x2F;get() 方法设置和读取 ThreadLocal 实例. 一起看下示例代码的运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadName: thread-0</span><br><span class="line">threadName: thread-1</span><br><span class="line">tradeOrder info: id=1, status=未支付</span><br><span class="line">tradeOrder info: id=0, status=已支付</span><br></pre></td></tr></table></figure>

<p>可以看出 thread-1 和 thread-2 虽然操作的是同一个 ThreadLocal 对象, 但是它们取到了不同的线程名称和订单交易信息.</p>
<p>**那么一个线程内如何存在多个 ThreadLocal 对象, 每个 ThreadLocal 对象是如何存储和检索的呢? **</p>
<h4 id="ThreadLocal-实现原理"><a href="#ThreadLocal-实现原理" class="headerlink" title="ThreadLocal 实现原理"></a>ThreadLocal 实现原理</h4><p>既然多线程访问 ThreadLocal 变量时都会有自己独立的实例副本, 那么很容易想到的方案就是在 ThreadLocal 中维护一个 Map, 记录线程与实例之间的映射关系. 当新增线程和销毁线程时都需要更新 Map 中的映射关系, 因为会存在多线程并发修改, 所以需要保证 Map 是线程安全的.</p>
<p>那么 JDK 的 ThreadLocal 是这么实现的吗? 答案是 NO. 因为在高并发的场景并发修改 Map 需要加锁, 势必会降低性能.</p>
<p>JDK 为了避免加锁, 采用了相反的设计思路. 以 Thread 入手, 在 Thread 中维护一个 Map, 记录 ThreadLocal 与实例之间的映射关系, 这样在同一个线程内, Map 就不需要加锁了.</p>
<p>从源码中可以发现 Thread 使用的是 ThreadLocal 的内部类 ThreadLocalMap.</p>
<h4 id="ThreadLocalMap-内部实现"><a href="#ThreadLocalMap-内部实现" class="headerlink" title="ThreadLocalMap 内部实现"></a>ThreadLocalMap 内部实现</h4><p>ThreadLocalMap 其实与 HashMap 的数据结构类似, 但是 ThreadLocalMap 不具备通用性, 它是为 ThreadLocal 量身定制的.</p>
<p>ThreadLocalMap 是一种使用线性探测法实现的哈希表, 底层采用数组存储数据.</p>
<p>ThreadLocalMap 会初始化一个长度为 16 的 Entry 数组, 每个 Entry 对象用于保存 key-value 键值对. 与 HashMap 不同的是, Entry 的 key 就是 ThreadLocal 对象本身, value 就是用户具体需要存储的值.</p>
<p>ThreadLocal 在新建对象时会初始化一个 threadLocalHashCode 字段, threadLocalHashCode 初始化源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment">     * to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment">     * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment">     * searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment">     * (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment">     * in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment">     * are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment">     * less common cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment">     * zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment">     * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment">     * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next hash code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面源码可知, 每次新建对象, Hash 值就会固定增加 <code>0x61c88647</code>.</p>
<p>为什么取 <code>0x61c88647</code> 这个数呢? 实验证明, 通过 <code>0x61c88647</code> 累加生成的 threadLocalHashCode 与 2 的幂取模, 得到的结果可以较为均匀地分布在长度为 2 的幂大小的数组中.</p>
<p>为了便于理解, 我们采用一组简单的数据模拟 ThreadLocal.set() 的过程是如何解决 Hash 冲突的:</p>
<p><img src="/imgs/netty/netty-thread-ThreadLocal-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png" alt="netty-thread-ThreadLocal-线性探测法"></p>
<ol>
<li>threadLocalHashCode &#x3D; 4, threadLocalHashCode &amp; 15 &#x3D; 4; 此时数据应该放在数组下标为 4 的位置. 下标 4 的位置正好没有数据, 可以存放.</li>
<li>threadLocalHashCode &#x3D; 19, threadLocalHashCode &amp; 15 &#x3D; 4; 但是下标 4 的位置已经有数据了, 如果当前需要添加的 Entry 与下标 4 位置已存在的 Entry 两者的 key 相同, 那么该位置 Entry 的 value 将被覆盖为新的值. 我们假设 key 都是不相同的, 所以此时需要向后移动一位, 下标 5 的位置没有冲突, 可以存放.</li>
<li>threadLocalHashCode &#x3D; 35, threadLocalHashCode &amp; 15 &#x3D; 3; 下标 3 的位置已经有数据, 向后移一位, 下标 4 位置还是有数据, 继续向后查找, 发现下标 6 没有数据, 可以存放.</li>
</ol>
<p>set() 方法源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the value associated with key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 计算数组的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断该索引能否插入, 不能插入的则寻找下一个索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; <span class="comment">// 初始化 e</span></span><br><span class="line">            e != <span class="literal">null</span>;     <span class="comment">// 该索引位置是 null, 可以插入, 跳出循环</span></span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123; <span class="comment">// 寻找下一个索引位置</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 元素已存在, 直接更新 value, 然后 return</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// k == null &amp;&amp; e!= null 说明 key 被垃圾回收了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 被回收的话就需要替换掉过期的值, 把新的值放在这里返回</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 来到这里, 说明 key 在 tab 中不存在, 但是找到了可以插入的空位置</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">// 进行扩容</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal.get() 的过程也是类似的, 也是**根据 threadLocalHashCode 的值定位到数组下标, 然后判断当前位置 Entry 对象与待查询 Entry 对象的 key 是否相同, 如果不同, 继续向下查找. **</p>
<p>由此可见, **ThreadLocal.set()&#x2F;get() 方法在数据密集时很容易出现 Hash 冲突, 需要 O(n) 时间复杂度解决冲突问题, 效率较低. **</p>
<h4 id="ThreadLocalMap-中-Entry-设计原理"><a href="#ThreadLocalMap-中-Entry-设计原理" class="headerlink" title="ThreadLocalMap 中 Entry 设计原理"></a>ThreadLocalMap 中 Entry 设计原理</h4><p>Entry 继承自弱引用类 WeakReference, Entry 的 key 是弱引用, value 是强引用. 在 JVM 垃圾回收时, 只要发现了弱引用的对象, 不管内存是否充足, 都会被回收.</p>
<p>**为什么 Entry 的 key 要设计成弱引用? **</p>
<p>我们试想下, 如果 key 都是强引用, 当 ThreadLocal 不再使用时, 然而 ThreadLocalMap 中还是存在对 ThreadLocal 的强引用, 那么 GC 是无法回收的, 从而造成内存泄漏.</p>
<p>虽然 Entry 的 key 设计成了弱引用, 但是当 ThreadLocal 不再使用被 GC 回收后, ThreadLocalMap 中可能出现 Entry 的 key 为 NULL, 那么 Entry 的 value 一直会强引用数据而得不到释放, 只能等待线程销毁.</p>
<p>**如何避免 ThreadLocalMap 内存泄漏? **</p>
<p>ThreadLocal 已经帮助我们做了一定的保护措施, 在执行 ThreadLocal.set()&#x2F;get() 方法时, ThreadLocal 会清除 ThreadLocalMap 中 key 为 NULL 的 Entry 对象, 让它还能够被 GC 回收.</p>
<p>除此之外, 编码时当线程中某个 ThreadLocal 对象不再使用时, 立即调用 remove() 方法删除 Entry 对象. 如果是在异常的场景中, 记得在 finally 代码块中进行清理, 保持良好的编码意识.</p>
<h3 id="FastThreadLocal-为什么快"><a href="#FastThreadLocal-为什么快" class="headerlink" title="FastThreadLocal 为什么快"></a>FastThreadLocal 为什么快</h3><p>FastThreadLocal 的实现与 ThreadLocal 非常类似, Netty 为 FastThreadLocal 量身打造了 <code>FastThreadLocalThread</code> 和 <code>InternalThreadLocalMap</code> 两个重要的类.</p>
<p>FastThreadLocalThread 是对 Thread 类的一层包装, 每个线程对应一个 InternalThreadLocalMap 实例. 只有 FastThreadLocal 和 FastThreadLocalThread 组合使用时, 才能发挥 FastThreadLocal 的性能优势.</p>
<h4 id="FastThreadLocal-源码定义"><a href="#FastThreadLocal-源码定义" class="headerlink" title="FastThreadLocal 源码定义"></a>FastThreadLocal 源码定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastThreadLocal</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 被初始化为 InternalThreadLocalMap 的第一个 index (目前为 0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">variablesToRemoveIndex</span> <span class="operator">=</span> InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FastThreadLocalThread-源码定义"><a href="#FastThreadLocalThread-源码定义" class="headerlink" title="FastThreadLocalThread 源码定义"></a>FastThreadLocalThread 源码定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will be set to true if we have a chance to wrap the Runnable.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> cleanupFastThreadLocals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InternalThreadLocalMap-源码定义"><a href="#InternalThreadLocalMap-源码定义" class="headerlink" title="InternalThreadLocalMap 源码定义"></a>InternalThreadLocalMap 源码定义</h4><p>可以看出 FastThreadLocalThread 主要扩展了 InternalThreadLocalMap 字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title class_">UnpaddedInternalThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;InternalThreadLocalMap&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">nextIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_ARRAY_LIST_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ARRAY_LIST_CAPACITY_EXPAND_THRESHOLD</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// Reference: https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/ArrayList.java#l229</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ARRAY_LIST_CAPACITY_MAX_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> STRING_BUILDER_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> STRING_BUILDER_MAX_SIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HANDLER_SHARABLE_CACHE_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INDEXED_VARIABLE_TABLE_INITIAL_SIZE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">UNSET</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Used by &#123;<span class="doctag">@link</span> FastThreadLocal&#125; */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] indexedVariables;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Core thread-locals</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> futureListenerStackDepth;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> localChannelReaderStackDepth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Boolean&gt; handlerSharableCache;</span><br><span class="line">    <span class="keyword">private</span> IntegerHolder counterHashCode;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocalRandom random;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, TypeParameterMatcher&gt; typeParameterMatcherGetCache;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Map&lt;String, TypeParameterMatcher&gt;&gt; typeParameterMatcherFindCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String-related thread-locals</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder stringBuilder;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Charset, CharsetEncoder&gt; charsetEncoderCache;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Charset, CharsetDecoder&gt; charsetDecoderCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ArrayList-related thread-locals</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Object&gt; arrayList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BitSet cleanerFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">InternalThreadLocalMap</span><span class="params">()</span> &#123;</span><br><span class="line">        indexedVariables = newIndexedVariableTable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] newIndexedVariableTable() &#123;</span><br><span class="line">        Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[INDEXED_VARIABLE_TABLE_INITIAL_SIZE];</span><br><span class="line">        Arrays.fill(array, UNSET);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextVariableIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nextIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= ARRAY_LIST_CAPACITY_MAX_SIZE || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextIndex.set(ARRAY_LIST_CAPACITY_MAX_SIZE);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;too many thread-local indexed variables&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>从 InternalThreadLocalMap 内部实现来看, 与 ThreadLocalMap 一样都是采用数组的存储方式.</p>
<p>但是 InternalThreadLocalMap 并没有使用线性探测法来解决 Hash 冲突, 而是在 FastThreadLocal 初始化的时候分配一个数组索引 index, index 的值采用原子类 AtomicInteger 保证顺序递增, 通过调用 InternalThreadLocalMap.nextVariableIndex() 方法获得. 然后在读写数据的时候通过数组下标 index 直接定位到 FastThreadLocal 的位置, 时间复杂度为 O(1). 如果数组下标递增到非常大, 那么数组也会比较大, 所以 FastThreadLocal 是通过空间换时间的思想提升读写性能.</p>
<p>FastThreadLocal 的使用方法几乎和 ThreadLocal 保持一致, 只需要把代码中 Thread、ThreadLocal 替换为 FastThreadLocalThread 和 FastThreadLocal 即可.</p>
<p>FastThreadLocal.set() 源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastThreadLocal</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the value for the current thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="comment">// 获取当前线程的 InternalThreadLocalMap</span></span><br><span class="line">            <span class="type">InternalThreadLocalMap</span> <span class="variable">threadLocalMap</span> <span class="operator">=</span> InternalThreadLocalMap.get();</span><br><span class="line">            <span class="comment">// 将 InternalThreadLocalMap 中对应数据替换为新的 value</span></span><br><span class="line">            setKnownNotUnset(threadLocalMap, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setKnownNotUnset</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到数组下标 index 位置, 设置新的 value</span></span><br><span class="line">        <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</span><br><span class="line">            <span class="comment">// 将 FastThreadLocal 对象保存到待清理的 Set 中</span></span><br><span class="line">            addToVariablesToRemove(threadLocalMap, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addToVariablesToRemove</span><span class="params">(InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">        Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;</span><br><span class="line">        <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="literal">null</span>) &#123;</span><br><span class="line">            variablesToRemove = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());</span><br><span class="line">            threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        variablesToRemove.add(variable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the value to uninitialized for the specified thread local map.</span></span><br><span class="line"><span class="comment">     * After this, any subsequent call to get() will trigger a new call to initialValue().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        remove(InternalThreadLocalMap.getIfSet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the value to uninitialized for the specified thread local map.</span></span><br><span class="line"><span class="comment">     * After this, any subsequent call to get() will trigger a new call to initialValue().</span></span><br><span class="line"><span class="comment">     * The specified thread local map must be for the current thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadLocalMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除数组下标 index 位置对应的 value</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> threadLocalMap.removeIndexedVariable(index);</span><br><span class="line">        <span class="comment">// 从数组下标 0 的位置取出 Set 集合, 并删除当前 FastThreadLocal</span></span><br><span class="line">        removeFromVariablesToRemove(threadLocalMap, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 空方法, 用户可以继承实现</span></span><br><span class="line">                onRemoval((V) v);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                PlatformDependent.throwException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title class_">UnpaddedInternalThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title function_">getIfSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((FastThreadLocalThread) thread).threadLocalMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowThreadLocalMap.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">            <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> slowGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title function_">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> &#123;</span><br><span class="line">        <span class="type">InternalThreadLocalMap</span> <span class="variable">threadLocalMap</span> <span class="operator">=</span> thread.threadLocalMap();</span><br><span class="line">        <span class="keyword">if</span> (threadLocalMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> <span class="title class_">InternalThreadLocalMap</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title function_">slowGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InternalThreadLocalMap</span> <span class="variable">ret</span> <span class="operator">=</span> slowThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="literal">null</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> <span class="title class_">InternalThreadLocalMap</span>();</span><br><span class="line">            slowThreadLocalMap.set(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if a new thread-local variable has been created</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setIndexedVariable</span><span class="params">(<span class="type">int</span> index, Object value)</span> &#123;</span><br><span class="line">        Object[] lookup = indexedVariables;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> lookup[index];</span><br><span class="line">            <span class="comment">// 直接将数组 index 位置设置为 value, 时间复杂度为 O(1)</span></span><br><span class="line">            lookup[index] = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 容量不够, 先扩容再设置值</span></span><br><span class="line">            expandIndexedVariableTableAndSet(index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expandIndexedVariableTableAndSet</span><span class="params">(<span class="type">int</span> index, Object value)</span> &#123;</span><br><span class="line">        Object[] oldArray = indexedVariables;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldArray.length;</span><br><span class="line">        <span class="type">int</span> newCapacity;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; ARRAY_LIST_CAPACITY_EXPAND_THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 小于扩容阈值, 扩容到大于 index 且最近的 2 的整数次幂的数</span></span><br><span class="line">            newCapacity = index;</span><br><span class="line">            newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">1</span>;</span><br><span class="line">            newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">2</span>;</span><br><span class="line">            newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">4</span>;</span><br><span class="line">            newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">8</span>;</span><br><span class="line">            newCapacity |= newCapacity &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">            newCapacity ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容到最大容量</span></span><br><span class="line">            newCapacity = ARRAY_LIST_CAPACITY_MAX_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object[] newArray = Arrays.copyOf(oldArray, newCapacity);</span><br><span class="line">        Arrays.fill(newArray, oldCapacity, newArray.length, UNSET);</span><br><span class="line">        newArray[index] = value;</span><br><span class="line">        indexedVariables = newArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取当前线程的 InternalThreadLocalMap 是调用 <code>InternalThreadLocalMap.get()</code> , 逻辑很简单:</p>
<ol>
<li>如果当前线程是 FastThreadLocalThread 类型, 那么直接通过 fastGet() 方法获取 FastThreadLocalThread 的 threadLocalMap 属性即可. 如果此时 InternalThreadLocalMap 不存在, 直接创建一个返回.</li>
<li>当前线程是其他类型, 通过 slowGet() 获取 InternalThreadLocalMap, 可以看出 slowThreadLocalMap 是一个 JDK 原生的 ThreadLocal, ThreadLocal 中存放着 InternalThreadLocalMap, 此时获取 InternalThreadLocalMap 就退化成 JDK 原生的 ThreadLocal 获取.</li>
</ol>
<p>将 InternalThreadLocalMap 中对应数据替换为新的 value 是调用 <code>setKnownNotUnset()</code> :</p>
<ol>
<li>setKnownNotUnset() 主要做了两件事:<ol>
<li>找到数组下标 index 位置, 设置新的 value</li>
<li>将 FastThreadLocal 对象保存到待清理的 Set 中</li>
</ol>
</li>
<li>从源码中可以知道, 如果数组包含 index 索引, 那么直接找到数组下标 index 位置将新 value 设置进去, 事件复杂度为 O(1); 否则, InternalThreadLocalMap 会自动扩容, 然后再设置 value</li>
<li>扩容逻辑类似于 HashMap.tableSizeFor(int cap)</li>
</ol>
<p>将 FastThreadLocal 对象保存到待清理的 Set 中是调用 <code>addToVariablesToRemove()</code>:</p>
<ol>
<li>variablesToRemoveIndex 是静态变量, 被初始化为 InternalThreadLocalMap 的第一个 index (目前为 0), 所以 InternalThreadLocalMap 的 value 数据是从下标为 1 的位置开始存储</li>
<li>由源码可以看出 InternalThreadLocalMap index 为 0 的位置是 FastThreadLocal 类型的 Set 集合</li>
</ol>
<p><code>FastThreadLocal.set()</code> 中 <code>remove()</code> 语句执行过程:</p>
<ol>
<li>调用 InternalThreadLocalMap.getIfSet() 获取当前 InternalThreadLocalMap</li>
<li>InternalThreadLocalMap 将数组 index 位置的元素覆盖为缺省对象 UNSET. 然后清理数组下标 0 位置的 Set 集合中当前的 FastThreadLocal 对象</li>
<li>最后 onRemoval() 方法是 Netty 留的一处扩展, 并没有实现, 用户需要在删除的时候做一些后置操作, 可以继承 FastThreadLocal 实现该方法</li>
</ol>
<h1 id="netty-时间轮"><a href="#netty-时间轮" class="headerlink" title="netty 时间轮"></a>netty 时间轮</h1><p>时间轮是任务调度算法的实现, 与其他专门的任务调度框架不同, Netty 以单个线程为单位来调度任务, 比如 EventLoop, 因此调度的任务数量有限. Netty 借助优先级队列来实现时间轮, runAllTask 发起对定时任务的调度, 主要逻辑是从 scheduledTaskQueue 移动到 taskQueue, 根据优先级队列弹出哪些过期的事件. 当定时任务鉴定完毕并移除完毕后, 就开始执行, 这个动作是在 runAllTask 方法中完成的, 每执行 64 个任务就会检测一次是否达到 runAllTask 的执行时间上限.</p>
<h2 id="时间轮算法"><a href="#时间轮算法" class="headerlink" title="时间轮算法"></a>时间轮算法</h2><p>时间轮算法的设计思想就来源于钟表. 如下图所示, 时间轮可以理解为一种环形结构, 像钟表一样被分为多个 slot 槽位. 每个 slot 代表一个时间段, 每个 slot 中可以存放多个任务, 使用的是链表结构保存该时间段到期的所有任务. 时间轮通过一个时针随着时间一个个 slot 转动, 并执行 slot 中的所有到期任务.</p>
<p><img src="/imgs/netty/netty-%E6%97%B6%E9%97%B4%E8%BD%AE.png" alt="netty-时间轮"></p>
<p>结合上图分析时间轮的任务添加与执行逻辑:</p>
<ol>
<li>假设时间轮被划分为 8 个 slot, 每个 slot 代表 1s, 当前时针指向 2</li>
<li>假如现在需要调度一个 3s 后执行的任务, 应该加入 2+3&#x3D;5 的 slot 中; 如果需要调度一个 12s 以后的任务, 需要等待时针完整走完一圈 round 零 4 个 slot, 需要放入第 (2+12)%8&#x3D;6 个 slot</li>
<li>当时针走到第 6 个 slot 时, 怎么区分每个任务是否需要立即执行, 还是需要等待下一圈 round, 甚至更久时间之后执行呢?</li>
<li>需要把 round 信息保存在任务中. 例如图中第 6 个 slot 的链表中包含 3 个任务, 第一个任务 round&#x3D;0, 需要立即执行; 第二个任务 round&#x3D;1, 需要等待 18&#x3D;8s 后执行; 第三个任务 round&#x3D;2, 需要等待 28&#x3D;8s 后执行.</li>
<li>当时针转动到对应 slot 时, 只执行 round&#x3D;0 的任务, slot 中其余任务的 round 应当减 1, 等待下一个 round 之后执行</li>
</ol>
<h2 id="netty-HashedWheelTimer-源码解析"><a href="#netty-HashedWheelTimer-源码解析" class="headerlink" title="netty HashedWheelTimer 源码解析"></a>netty HashedWheelTimer 源码解析</h2><h3 id="HashedWheelTimer-源码定义"><a href="#HashedWheelTimer-源码定义" class="headerlink" title="HashedWheelTimer 源码定义"></a>HashedWheelTimer 源码定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashedWheelTimer</span> <span class="keyword">implements</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">INSTANCE_COUNTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">WARNED_TOO_MANY_INSTANCES</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSTANCE_COUNT_LIMIT</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MILLISECOND_NANOS</span> <span class="operator">=</span> TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;HashedWheelTimer&gt; leakDetector = ResourceLeakDetectorFactory.instance()</span><br><span class="line">            .newResourceLeakDetector(HashedWheelTimer.class, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, <span class="string">&quot;workerState&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceLeakTracker&lt;HashedWheelTimer&gt; leak;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread workerThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WORKER_STATE_INIT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WORKER_STATE_STARTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WORKER_STATE_SHUTDOWN</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;FieldMayBeFinal&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> workerState; <span class="comment">// 0 - init, 1 - started, 2 - shut down</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> tickDuration;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelBucket[] wheel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">startTimeInitialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = PlatformDependent.newMpscQueue();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">pendingTimeouts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> maxPendingTimeouts;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor taskExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> startTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedules &#123;<span class="doctag">@link</span> TimerTask&#125;s for one-time future execution in a background</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedules the specified &#123;<span class="doctag">@link</span> TimerTask&#125; for one-time execution after</span></span><br><span class="line"><span class="comment">     * the specified delay.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a handle which is associated with the specified task</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException       if this timer has been &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the pending timeouts are too many and creating new timeout</span></span><br><span class="line"><span class="comment">     *                                    can cause instability in the system.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Timeout <span class="title function_">newTimeout</span><span class="params">(TimerTask task, <span class="type">long</span> delay, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases all resources acquired by this &#123;<span class="doctag">@link</span> Timer&#125; and cancels all</span></span><br><span class="line"><span class="comment">     * tasks which were scheduled but not executed yet.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the handles associated with the tasks which were canceled by</span></span><br><span class="line"><span class="comment">     *         this method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Set&lt;Timeout&gt; <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A task which is executed after the delay specified with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Timer#newTimeout(TimerTask, long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executed after the delay specified with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Timer#newTimeout(TimerTask, long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout a handle which is associated with this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handle associated with a &#123;<span class="doctag">@link</span> TimerTask&#125; that is returned by a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Timer&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Timeout</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> Timer&#125; that created this handle.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Timer <span class="title function_">timer</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> TimerTask&#125; which is associated with this handle.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TimerTask <span class="title function_">task</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if and only if the &#123;<span class="doctag">@link</span> TimerTask&#125; associated</span></span><br><span class="line"><span class="comment">     * with this handle has been expired.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if and only if the &#123;<span class="doctag">@link</span> TimerTask&#125; associated</span></span><br><span class="line"><span class="comment">     * with this handle has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to cancel the &#123;<span class="doctag">@link</span> TimerTask&#125; associated with this handle.</span></span><br><span class="line"><span class="comment">     * If the task has been executed or cancelled already, it will return with</span></span><br><span class="line"><span class="comment">     * no side effect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> True if the cancellation completed successfully, otherwise false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashedWheelTimer 实现了接口 io.netty.util.Timer</p>
<p>Timer 接口提供了两个方法, 分别是创建任务 newTimeout() 和停止所有未执行任务 stop(). 从方法的定义可以看出, Timer 可以认为是上层的时间轮调度器, 通过 newTimeout() 方法可以提交一个任务 TimerTask, 并返回一个 Timeout.</p>
<p>Timeout 持有 Timer 和 TimerTask 的引用, 而且通过 Timeout 接口可以执行取消任务的操作</p>
<h3 id="HashedWheelTimer-示例"><a href="#HashedWheelTimer-示例" class="headerlink" title="HashedWheelTimer 示例"></a>HashedWheelTimer 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashedWheelTimerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedWheelTimer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">timeout1</span> <span class="operator">=</span> timer.newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;timeout1: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timeout1.isExpired()) &#123;</span><br><span class="line">            timeout1.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer.newTimeout(timeout -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;timeout2: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        timer.newTimeout(timeout -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;timeout3: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeout2: Wed Apr 26 20:21:22 CST 2023</span><br><span class="line">timeout3: Wed Apr 26 20:21:27 CST 2023</span><br></pre></td></tr></table></figure>

<p>示例中我们通过 newTimeout() 启动了三个 TimerTask:</p>
<ul>
<li>timeout1 由于被取消了, 所以并没有执行</li>
<li>timeout2 和 timeout3 分别应该在 1s 和 3s 后执行. 然而从结果输出看并不是, timeout2 和 timeout3 的打印时间相差了 5s, 这是由于 timeout2 阻塞了 5s 造成的.</li>
</ul>
<p>由此可以看出, <font color=red>时间轮中的任务执行是串行的</font>, 当一个任务执行的时间过长, 会影响后续任务的调度和执行, 很可能产生任务堆积的情况.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904146550652941">Netty 系列——NIO</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/16%20%20IO%20%E5%8A%A0%E9%80%9F%EF%BC%9A%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%E7%9A%84%20Netty%20%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.md">16 IO 加速: 与众不同的 Netty 零拷贝技术</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6974321745519968293">Netty 是如何检测资源泄漏的? </a></li>
<li><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/12%20%20%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%20jemalloc%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md">12 他山之石: 高性能内存分配器 jemalloc 基本原理</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/leebaok/jemalloc-4.2.1-readcode/blob/readcode/readcode/arch.md">jemalloc-4.2.1-readcode</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuxinstyle/p/9872824.html">Netty 入门 3 之—-Decoder 和 Encoder</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24768941/article/details/121866237?spm=1001.2014.3001.5502">Netty(七) Netty 编解码与 TCP 粘包,拆包</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/111testing/p/12810253.html">tcp 粘包与 udp 丢包的原因</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_22254181/article/details/101476568">深入剖析 Linux IO 原理和几种零拷贝机制的实现</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/20%20%20%E6%8A%80%E5%B7%A7%E7%AF%87%EF%BC%9ANetty%20%E7%9A%84%20FastThreadLocal%20%E7%A9%B6%E7%AB%9F%E6%AF%94%20ThreadLocal%20%E5%BF%AB%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F.md">20 技巧篇: Netty 的 FastThreadLocal 究竟比 ThreadLocal 快在哪儿? </a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂 Reactor 模型和 Proactor 模型</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36389060/article/details/124232377">【Netty】模型篇一: Netty 线程模型架构 &amp; 工作原理 解读</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/21%20%20%E6%8A%80%E5%B7%A7%E7%AF%87%EF%BC%9A%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8%E4%B9%8B%E6%97%B6%E9%97%B4%E8%BD%AE%20HashedWheelTimer.md">21 技巧篇: 延迟任务处理神器之时间轮 HashedWheelTimer</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/netty/" rel="tag"># netty</a>
              <a href="/tags/io/" rel="tag"># io</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/2021/11/06/mq/" rel="prev" title="消息队列">
                  <i class="fa fa-chevron-left"></i> 消息队列
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/2022/01/09/IO%E6%B5%81/" rel="next" title="IO流">
                  IO流 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Apomelo</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.16.0/algoliasearch-lite.umd.js" integrity="sha256-zti3IO5mcnIxuJGpYC58EnL1rrahhT+sOUT2uWO45E8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.53.0/instantsearch.production.min.js" integrity="sha256-JAFoxs9krkfi1sqvG1a7Rg2roZXsI+UnI3ElbjW762k=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"N5VN0ybf5xGuqDFhjzC5RlRL-MdYXbMMI","app_key":"ru1RlOeEotFp87wLFIHucgVu","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
